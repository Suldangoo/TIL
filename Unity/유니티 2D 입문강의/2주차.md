## 1장 : 유니티 액션을 코드로 수행하기

- 1주차에선 게임 매니저를 만들고, 인스펙터 창에 직접 오브젝트를 할당하는 방식으로 두 객체간의 통신을 구현했다. 그러나 이 방법엔 명확한 한계가 있다.
- 어떤 맵에 입장한 후에 몬스터가 스폰되는, 동적 등장이 있다면 미리 오브젝트들을 넣기 어려우며, 설사 가능하다 하더라도 몬스터가 10000마리 있다면 10000개를 직접 전부 할당해야 한다.
- 따라서 툴 상에서 가능한 모든 액션은 코드에서 전부 가능하기 때문에, 이 변수 할당 액션을 코드로 할 수 있어야 한다.

```csharp
void CreatePlayer()
{
    GameObject go = new GameObject(); // 오브젝트 생성하기
    // Scene에 배치되며, GC로 수거되지 않는다.

    go.name = "Player"; // 이름 설정하기

    Transform t = go.GetComponent<Transform>(); // 컴포넌트 가져와 할당하기

    t.position = new Vector3(-1, 0, 0); // 컴포넌트 값 변경하기
    go.transform.position = new Vector3(-1, 0, 0); // 컴포넌트 값 즉시 변경하기

    go.AddComponent<SpriteRenderer>(); // 원하는 컴포넌트 추가하기
    SpriteRenderer sr = go.GetComponent<SpriteRenderer>();

    sr.color = Color.green;
    sr.sprite = sprite;

    go.AddComponent<Player>();
    player = go.GetComponent<Player>();
}
```

- Transform 컴포넌트의 경우, 모든 오브젝트가 필수적으로 가지고 있는 컴포넌트이기 때문에 transform이라는 이미 예약된 변수로 사용할 수 있다.
- GameManager에서 새로운 게임 오브젝트를 만들어서 new GameObject();를 할당하면, 메모리상에서만 존재하는 것이 아니라 실제로 씬에 배치까지 된다.
- 그리고 이렇게 참조 타입으로 가져와 만든 것은 그 어떤 변수도 참조하고 있지 않으면 GC에 의해서 수거되지만, new 키워드를 사용해 만든 오브젝트는 우리가 명시적으로 수거하지 않는 이상 GC에 의해 수거되지 않는다.
- 이렇게 코드로 만들면, 일전에 했던 모든 액션이 전부 코드로도 만들어질 수 있다.