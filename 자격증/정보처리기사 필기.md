# ■ 1과목 : 소프트웨어 설계

### 소프트웨어 공학

- 소프트웨어 특징
    - 상품성, 복잡성, 변경 가능성, 복제성
- 시스템 : 하나의 조직을 의미, 입력시 처리,  출력 사이에 제어가 일어나고, 피드백이 이루어짐
- 소프트웨어 위기
    - 비용 초과하는 개발비용 증가, 개발 기간 지연, 인력 부족, 성능 신뢰성 부족, 유지보수 어려움
- 소프트웨어 공학 : 어떻게 소프트웨어를 요구사항에 맞게 저렴하게, 쉽게 만들 수 있을까
    - 소프트웨어 개발, 운영, 유지보수, 폐기에 대한 체계적인 접근
    - 기본 원칙 : 현대적 프로그래밍, 신뢰성, 편리성, 유지보수성, 지속적인 검증 시행

### 소프트웨어 재공학

- 소프트웨어 개발엔 많은 비용이 드므로 기존의 소프트웨어를 재활용하는 방식의 공학
- 개발 시간 비용 감소, 품질 향상, 생산성 향상, 프로젝트 실패 위험 감소
- 유지보수성 향상이 최우선 목표, 재사용을 수월하게 해서 수명 연장
- 과정 : 분석 → 구성 → 역공학 → 이식
- 역공학
    - 기존에 쓰고 있던 소프트웨어를 재분석하여 설계 정보를 재발견, 재구축
    - 간단하고 오래된 것은 문서화
- SW 재공학 관점에서 유지보수 유형엔 Preventive Maintenance
- CASE (CAD의 소프트웨어 엔지니어링 버전, 소프트웨어 개발 자동화 도구)
    - 소프트웨어 개발 전용 도구
    - 개발을 신속하게 하고, 비용이 절약되고, 오류 수정이 쉬워 품질이 향상
    - 생명 주기 전체 단계 연결, 자동화
    - 문서화 및 명세화를 위한 그래픽 기능 제공
    - 개발 단계의 표준화, 자료 흐름도 작성
    - 모델들 사이의 모순 검사 기능 제공, 개발 모형 지원
- CASE의 분류
    - 상위 CASE : 요구분석 및 설계 단계 초기부분 지원
    - 하위 CASE : 실제 코딩 지원
    - 통합 CASE : 소프트웨어 개발 주기 전체 과정을 지원
- 요구사항 분석을 위한 CASE 도구
    - SADT : 소프트테크 사에서 개발한 소프트웨어 설계용 구조적 분석 및 설계 도구, 블록 다이어그램을 채택한 자동화 도구

### 소프트웨어 개발 방법론

- 소프트웨어 생명주기
    - 소프트웨어 개념 형성부터 운용/유지보수까지 변화의 모든 과정
    - 타당성 검토 → 개발 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 운용 → 유지보수
    - 전통적인 방법은 폭포수 모형
        - 처음부터 개발 과정을 전부 정한 뒤 순차적으로 진행되는 모형
    - 나선형 모형
        - 반복적인 작업을 수행하는 점증적 생명주기 모형
        - 계획 수립, 위험 분석, 개발 및 검증, 고객 평가를 반복해 빙글빙글 돌아가는 모형
        - 개발 중 발생할 수 있는 위험을 관리하고 최소화
        - 개발 및 검증 단계에서 프로토타입을 개발하고, 고객 평가 단계로 넘어감
- 하향식 설계 : 제일 상위에 있는 메인 유저 펑션(제일 중요한 것)먼저 만들고 가지를 만들기
- 상향식 설계 : 가장 기본적인 조그만 컴포넌트 먼저 만들고 상위 수준 컴포넌트 설계
- 프로토타입 모형 : 개발될 실제 시스템의 견본
- HIPO : 계층적 입력 처리 출력 구성의 시스템 문서화 기법
    - 가시적 도표, 총체적, 세부적 다이어그램으로 구성
    - 하향식 소프트웨어 개발을 위한 문서화 도구
- V-모델
    - 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델
    - 요구사항 분석, 기능명세 분석, 설계, 개발 / 단위, 통합, 시스템, 인수 테스트
        - 앞 것이 정적 테스트 (코드 작성), 뒷 것이 동적 테스트 (실제로 테스트)
- 애자일 개방 방법론
    - 날렵한, 재빠른의 의미이며 소프트웨어를 빠르고 낭비 없이 제작, 고객이 원하는 것만 협업에 초점을 두고 개발 중 설계 변경에 신속히 대응
    - XP(익스트림 프로그래밍), 스크림, 린, DSDM, FDD
    - 애자일 선언문 : 고객과 잘 소통해서 고객이 원하는거 만들자
- XP
    - 아주 빠르게 양질의 소프트웨어를 만드는 것
    - 핵심 가치 : 고객과의 소통, 단순성, 피드백, 용기(고객 요구사항 반영)와 존중
    - Spike : 어려운 요구사항과 잠재적 솔루션을 고려하기 위해 작성하는 간단 프로그램
    - User Stories : 사용자의 요구사항을 간단한 시나리오로 표현
    - 릴리즈 플래닝 : 몇 개의 스토리가 적용된 제품을 제공
    - 이터레이션 : 하나의 릴리즈를 세분화한 단위, 반복 진행 중 스토리 추가
    - 스몰 릴리즈 : 작은 단위의 실제 프로그램 실행 가능 단위
- XP의 12가지 실천사항
    1. 짝 프로그래밍 : 한 사람은 개발, 한 사람은 검사
    2. 플래닝 게임 : 게임처럼 선수와 규칙, 목표를 두고 기획에 임한다
    3. 테스트 드라이븐 디벨롭먼트 : 실제 코드 작성 전 단위 테스트부터 작성 및 수행
    4. 훌 팀 : 개발 효율을 위해 고객을 프로젝트 팀원으로 상주
    5. 컨티니어스 인티그레이션 : 지속적으로 통합, 상시 빌드 및 배포 가능 상태
    6. 디자인 임프로브먼트 : 기능 변경 없이 중복 제거, 커뮤니케이션 향상, 유연성 재구성
    7. 스몰 릴리즈 : 짧은 주기로 잦은 릴리즈, 고객이 변경사항을 볼 수 있게
    8. 코딩 스탠다드 : 표준 코딩 기법에 맞춰 작성
    9. 콜렉티브 코드 오너쉽 : 시스템의 소스 코드는 팀의 모든 프로그래머가 언제든 수정 가능
    10. 심플 디자인 : 가능한 가장 간결한 디자인 상태 유지
    11. 시스템 메타포 : 최종적으로 개발되어야 할 시스템의 구조 기술
    12. 서스테이너블 : 일주일에 40시간 이상 작업 금지 등 개발자 과도한 업무 금지
- 효과적인 프로젝트 관리 3대 요소 : 사람, 문제, 프로세스 (3P)
- 스크럼
    - 스크럼 팀을 만들어 빠르고 명확하게 개발
    - 스크럼 팀의 역할 : 제품 책임자, 스크럼 마스터, 스크럼 팀
    - 스프린트라는 2~4주의 과정이 반복되며 회의(데일리 스크럼 미팅)가 매일 이루어짐
    - 소멸 차트 : 해야할 일을 기술하고 매일매일 한 일들을 삭제

### 현행 시스템 분석

- 해당 개발사가 어떤 시스템을 구성하는지 확인하는 것
- 개발 시스템의 개발 범위를 파악할 수 있음
- 파악 절차
    - 1단계 : 시스템 구성 파악 - 시스템 기능 파악 - 시스템 인터페이스 현황 파악
    - 2단계 : 아키텍처 파악 - 소프트웨어 구성 파악
    - 3단계 : 시스템 하드웨어 현황 파악 - 네트워크 구성 파악
- 시스템 아키텍처 : 총 시스템들이 어떻게 상호작용하는지, 설계도
    - 시스템의 전체 구조, 행위, 어떻게 작동하는지 설명하는 틀
- 시스템 및 인터페이스 현황 파악
    - 시스템 구성 파악 : 조직 내 업무들이 뭐가 있는지 문서화 (자동은 CASE)
- 시스템 기능 파악 : 각 시스템이 현재 제공하고 있는 기능을 표시
- 인터페이스 현황 파악 : 현황 시스템이 타 단위 업무 시스템과 주고받는 데이터 연계 명시
- EAI : 기업에 있는 모든 어플리케이션을 현대화하고 통합, 조정 도구
- FEP(프론트 엔드 프로세서) : 전위 처리기, 입력 데이터를 프로세서가 처리 전에 미리 처리
- 소프트웨어 구성 파악 : 소프트웨어 품명, 용도, 라이선스 명시
    - 단위 : 사이트, 서버, 프로세서, 코어
- 하드웨어 구성 파악 : CPU 등의 컴퓨터 사양 파악
    - 서버 이중화
- TCO : 일정 기간동안 프로젝트에 들어간 토탈 비용
- 플랫폼
    - 응용 소프트웨어 + 하드웨어 + 시스템 소프트웨어
    - 내가 소프트웨어를 만들기 위한 기반, 운영체제 소프트웨어
    - 종류 : JAVA, .NET, IOS, Android, Windows 등
    - 플랫폼 성능 특성 분석 : 응답 시간, 가용성, 사용률
    - 플랫폼 성능 특성 분석 방법 : 기능 테스트, 사용자 인터뷰, 문서 점검
- 오픈소스 라이선스
    - GNU(리눅스), GNU GPLv1(소스코드 비공개, 바이너리만 배포하는걸 금지) , BSD(수정 강제 아니고, 공개 하지 않아도 되는 초 자유) Apache 2.0 (하둡이라는 저렴한 다수의 컴퓨터를 하나처럼 묶어 대량 데이터 처리 기술)
- 현행 DBMS 분석
    - DBMS : 데이터베이스 관리 시스템, 종속성과 중복성 문제 해결. 일종의 미들웨어
    - DBMS 종류나 버전 등을 분석
    - 고려사항 : 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

### 요구사항 개발

- 요구 공학 : 어떻게 고객이 원하는 것을 정확히 뽑아낼 수 있을까
    - 요구 공학에 도움되는 도구 : 자료 흐름도, 자료 사전, 소단위 명세서
- 요구사항 누락 방지, 상호 이해를 위해 존재, 요구사항 변경 이력 관리
- 요구사항 베이스라인 : 우리가 개발하려는 소프트웨어의 목표 달성 여부 확인 기준
- 요구공학 프로세스
    - 경제성, 기술성, 적법성, 대안성, 타당성 조사가 되어야 함
    - SWEBOK 요구사항 개발 프로세스 : 요구사항 추출 → 분석 → 명세 → 검증
- 요구사항 도출
    - 현재 상태를 파악하고 문제 정의 후, 문제 해결과 목표를 도출하는 것
    - 이해관계자가 식별된다.
    - 요구사항 도출 기법 : 발표, 문서 조사, 설문, 업무 절차 및 양식 조사, 브레인스토밍이나 워크숍 인터뷰, 관찰 및 모델 프로토타입, 유즈 케이스, 벤치마킹, BPR, RFP
- 요구사항 분석 :사용자 요구사항을 걸러내는 과정으로 요구사항 도출 후 정의 문서화
    - 기법 : 사용자 의견 청취, 사용자 인터뷰, 각종 문서 분석, 관찰 및 모델 작성, 설문 조사
- 요구사항 분석 수행 단계
    - 문제 인식 : 인터뷰나 설문조사 등 활용, 요구사항 파악
    - 전개 : 파악한 문제를 자세히 조사
    - 평가와 종합 : 요구를 다이어그램이나 자동화 도구로 종합
    - 검토 : 요구분석 작업의 내용 검토, 재정리
    - 문서화 : 요구사항 분석 내용을 문서화
- 요구사항은 기능 요구사항와 비기능 요구사항으로 분류된다.
    - 기능적 요구사항 : 실제로 어떻게 동작하는가, 완전히 기능 위주
    - 비기능적 요구사항 : 성능, 보안, 품질, 안정성 등의 수행에 보조적인 요구사항
- 요구사항 명세의 기법엔 정형 명세와 비정형 명세로 분류된다.
    - 정형 명세 : 수학적, 모델링 기반, 명세가 간결, 단 낮은 이해도
    - 비정형 명세 : 상태, 기능, 객체 중심 명세, 자연어 기반 (SADT, UseCase), 이해가 용이
- 요구사항 명세 속성 : 정확성, 명확성, 완전성, 일관성, 수정 용이성, 추적성
- 요구사항 확인
    - 요구사항 분석 단계를 거친 후 문서로 만들어진 내용을 확인하고 검증
    - 형상 관리, 일관성 확인, 요구사항 이해했는지 확인
    - 요구사항 관리 도구의 필요성 : 변경으로 인한 비용 편익 분석, 변경 추적, 변경에 따른 영향 평가
- 형상 관리 : 소프트웨어 개발 과정 중 나오는 모든 데이터나 문서들.
- 요구사항 확인 도구 : 프로토타이핑, 모델 검증, 요구사항 검토, 인수 테스트
- 모델 검증 : 분석 단계에서 개발된 모델의 품질을 검증
    - 정적 분석 : 객체 모델에서 객체들 사이에 존재하는 의사소통 경로를 검증
    - 동적 분석 : 직접 실행하여 모델을 검증
- 인수 테스트 : 실제로 고객에게 제공해 요구사항이 만족하는지 확인

### UML

- 개념 모델링 : 현실 세계의 내용을 이해하기 쉽게 도식화하는 것
    - 도메인의 엔티티들과 그들의 관계 및 종속성을 반영한다
    - 대부분 UML을 사용한다.
    - 종류 : 유즈 케이스 다이어그램, 데이터 플로우 모델, 스테이트 모델, 골 베이스드 모델, 유저 인터랙션, 오브젝트 모델, 데이터 모델
- UML : 객체지향 소프트웨어 개발 과정에서 모델링 기술과 방법론을 통합한 범용 모델링 언어
- **럼바우 객체지향 분석 기법**
    - 소프트웨어 구성 요소를 그래픽으로 모형화하는 객체 모델링 기법
    - 객체 모델링 : 시스템에서 요구되는 객체를 찾아내 속성과 연산 식별, 관계 연관화, 집단화, 다이어그램 표시
    - 동적 모델링 : 제어 흐름, 상호작용, 동작 순서 등의 상태를 시간 흐름에 따라 상태 다이어그램
    - 기능 모델링 : 여러 프로세스 간 자료 흐름 표시
- UML 소프트웨어 관점
    - 기능적 관점 : 사용자 측면에서 보는 사용 사례 모델링 (유즈케이스 다이어그램)
    - 정적 관점 : 소프트웨어 내부 구조적 관계 (클래스 다이어그램)
    - 동적 관점 : 시스템 내부 동작 (시퀀스, 스테이트, 액티비트 다이어그램)
- 스테레오 타입 객체를 표현할 땐 길러멧(<<>>)을 사용허며, 저 기호 안에 확장요소를 적는다.
- Public : 어떤 클래스든 접근 가능 +
- Protected : 해당 클래스와 동일 패키지에 있거나, 상속 관계에 있어야 접근 가능 #
- Package : 동일 패키지에 있는 클래스의 객체만 접근 가능 ~
- Private : 해당 클래스로 생성된 객체만 접근 가능 -

### 소프트웨어 아키텍처

- 개발 대상 시스템의 전반적인 구조를 체계적으로 설계하는 것, 설계도
- ISO/IEC 9126 모델로 소프트웨어 품질 특성과 평가 기준을 만들어냄
    - 내외부 품질로 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성 등 구분
    - 사용 품질로 효과성, 생산성, 안정성, 만족도 구분

### UI 표준 및 지침

- UI : 사용자 인터페이스, 유저와 시스템간 상호작용 및 의사소통을 위한 매개체
- **직관성, 유효성, 학습성, 유연성**
- 사용자 중심, 일관성, 단순성, 가시성, 표준화, 접근성, 결과 예측 가능, 명확성, 오류 발생 해결
- UX : 사용자 경험
- UI 설계 도구
    - 와이어프레임 : 기본 레이아웃 선
    - 목업 : 실물 흡사 정적모형
    - 프로토타입
    - 스토리보드 : 앞의 정책, 프로세스, 와이어프레임, 설명이 모두 포함된 설계 문서

### 소프트웨어 설계 모델링

- 목적 : 무엇으로부터 어떻게 만들것인지, 관점을 전환하며 청사진을 만드는 것
- 소프트웨어 설계 분류
    - 상위 설계 : 아키텍처 설계, 데이터 설계, 인터페이스 정의, 사용자 인터페이스 설계
    - 하위 설계 : 모듈 설계, 자료 구조 설계, 알고리즘 설계
- 구조 모델링 : 컴포넌트 유형, 프로시저, 데이터 구조, 연결 구조
- 행위 모델링 : 기능들이 어떤 순서로 수행하고 상호작용하는지, 데이터 흐름 변환, 저장
- 팬 인 : 주어진 모듈을 제어하는 상위 모듈 수
- 팬 아웃 : 주어진 모듈이 제어하는 하위 모듈 수
- 코드의 기능
    - 표준화, 간소화, 분류, 식별, 배열, 연상, 암호화, 오류 검출 (보잉 747)
    - 순차코드 (1234…), 블록코드, 그룹 분류식 (대중소 분류), 10진 분류 (1000, 1100 도서관), 표의 숫자 코드 (길이, 넓이, 부피 등을 나타내는 문자 숫자), 연상 코드 (TV 39)
- 자료 흐름도 (DFD)
    - 버블 차트, 그림 중심으로 자료의 흐름을 표현, 입출력 자료 자체에 대해서
    - 구성 요소 : 프로세스, 자료 흐름 (화살표), 자료 저장소, 단말
- 자료 사전 (DD)
    - 시스템과 관련된 모든 자료의 명세와 자료 속성 파악
    - 정의= 연결 + 생략 (  )  선택 [I] 자료의 반복 { } 주석 **

### 모듈

- 전체 프로그램에서 하나의 작은 기능을 하는 실행 코드
- 재사용이 가능하며 자체 컴파일이 가능, 독립성이 강해야 하며 이것에 따라 결합도와 응집도가 측정
- 서브루틴 = 서브 시스템 = 작업 단위
- **결합도**
    - 서로 다른 두 모듈 간의 상호 의존도, 낮을 수록 좋다.
    - 자료 결합도 : 모듈간의 인터페이스가 자료 요소로만. 영향을 주지 않고 모듈간 내용 모름 (베스트)
    - 스탬프 결합도 : 두 모듈이 같은 자료 구조를 조회함, 배열, 레코드
    - 제어 결합도 : 어떤 모듈이 다른 모듈의 내부 구조를 제어하는 모듈
    - 외부 결합도 : 어떤 모듈이 외부로 선언한 변수를 사용, 참조하는 모듈
    - 공통 결합도 : 여러 모듈이 공통 자료 영역을 사용하는 경우
    - 내용 결합도 : 한 모듈이 다른 모듈의 내부 기능 및 내부 자료를 조회 (워스트)
- **응집도**
    - 한 모듈 내의 명령어의 모임, 관련 있는 것들끼리의 집합도, 높을 수록 좋다.
    - 기능적 응집도 : 모듈 내부의 모든 기능 요소들이 한 문제와 연관 (베스트)
    - 순차적 응집도 : 모듈 내부의 기능에 의한 출력이 다음 기능 요소의 입력으로
    - 교환적 응집도 : 같은 입력과 출력을 사용하는 소작업이 모인 경우
    - 절차적 응집도 : 모듈이 다수의 기능을 가지고, 그 기능을 순차적으로 수행
    - 시간적 응집도 : 특정 시간에 처리되는 여러 기능을 모아 한 개의 모듈로 작성
    - 논리적 응집도 : 유사한 성격을 갖거나 특정 형태 분류 요소들로 하나의 모듈 작성
    - 우연적 응집도 : 모듈 내부의 기능이 서로 관련 없는 요소로만 구성된 경우 (워스트)
- 모듈 vs 컴포넌트
    - 모듈은 자신만으로 동작할 수 있는 명령의 집합
    - 컴포넌트는 독립적인 업무를 수행하는 교체 가능 부품, 모델 한계 극복, 인터페이스로 연결
- 공통 모듈 : 여러 시스템에서 공통으로 사용하는 모듈
- N-S 도표
    - 구조적 프로그램의 순차, 선택, 반복을 사각형으로 도식화
    - 순차 구조, 선택 구조, 케이스, 반복 구조 등을 사각형으로 도식화함

### 객체지향 설계

- 구조적 프로그래밍 : 구조가 되어있어 프로그램 이해가 쉬움, 한 개의 입구와 한 개의 출구 구조
    - GOTO(분기문) 사용하지 않는다.
- 절차적 프로그래밍 : 순서대로 일련의 명령어를 나열, 프로그래밍
    - 함수 기반의 프로그래밍, 규모가 커지면 함수가 많아진다.
- 객체지향 : 현실 세계 대상 체인 개체를 속성과 메소드로 결합해 객체로 모델링하는 것
- 객체지향 프로그래밍 : 소프트웨어 내 오브젝트들이 서로 메시지를 주고받음
- 객체지향 구성 요소
    - 클래스 : 유사한 객체를 정의한 집합으로, 사용자 정의 데이터형, 데이터 추상화를 하는 단위
    - 오브젝트(객체) : 데이터와 함수를 묶어 소프트웨어 모듈로 표현, 속성과 메소드로 구성
- 다섯가지 특징
    - 캡슐화, 정보 은닉 (속성과 메소드를 숨김, 몰라도 됨), 추상화 (추상 클래스, 기능, 제어, 자료 추상화), 상속성, 다형성 (객체가 다양한 모양을 가지는 성질)
- 오버로딩 : 한 클래스 내에서 같은 이름 메소드 여러번
- 오버라이딩 : 상위 클래스에서 정의한 메소드를 하위 클래스에서 재정의
- 객체지향 설계 원칙 (SOLID)
    - 단일 책임의 원칙 : 모든 클래스는 단일 목적으로
    - 개방-폐쇄의 원칙 : 구성요소의 확장은 좋으나 수정은 폐쇄
    - 리스코프치환 원칙 : 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 됨
    - 인터페이스 분리 원칙 : 클라이언트는 자신이 사용하지 않는 메소드와 의존하면 안됨
    - 의존 역전 원칙 : 의존 관계를 맺으면 변하기 어렵고, 변화 빈도가 낮은 것에 의존
- Coad와 Your-don : 객체지향 분석 방법론, E-R 다이어그램 사용해 객체 행위 모델링

### 디자인 패턴

- 자주 사용하는 설계 형태 정형화, 소프트웨어 개발 템플릿, 어려운 문제 해결
- GoF 디자인 패턴 : 네 명이 제안한, 생성 / 구조 / 행위 패턴들
- 생성 패턴
    - 팩토리 메소드, 싱글턴, 프로토타입, 빌더, 추상 팩토리
- 구조 패턴
    - 어댑터, 브릿지, 컴포사이트, 데코레이터, 퍼사드, 플라이웨이트, 프록시
- 행위 패턴
    - 책임 연쇄, 이터레이션, 커맨드, 인터프리터, 메멘토, 옵저버, 스테이트, 스트레이지, 비지터, 템플레이트 메소드, 미디어터 (중재자)

### 인터페이스 요구사항

- 검증 방법 : 프로토타이핑, 테스트 설계, CASE, 요구
    - 동료 검토 : 작성자가 동료에게 설명
    - 워크스루 : 회의 전 명세서 배포, 짧은 검토
    - 인스펙션 : 다른 전문가 팀이 검사해 오류를 찾아내는 것
- 인터페이스  연계
    - DB 링크, DB 커넥션, API, JDBC, 하이퍼링크, 소켓, 웹 서비스, 연계 솔루션

### 미들웨어

- 클라이언트와 서버간의 통신 담당 시스템
- 이기종 하드웨어, 운영체제와 애플리케이션 사이에서 중재
- 유형
    - 데이터베이스
    - TP-Monitor (트랜잭션)
    - ORB (중간 브로커, CORBA)
    - RPC
    - MOM (메시지 기반)
    - WAS (웹 어플리케이션 서버, HTTP, 서버 단에서 애플리케이션 동작)
    - OTM (객체 트랜잭션 모니터)
- DB 미들웨어 : ODBC
- 통신 미들웨어 : RPC, MOM


# ■ 2과목 : 소프트웨어 개발

# ■ 3과목 : 데이터베이스 구축

# ■ 4과목 : 프로그래밍 언어 활용

# ■ 5과목 : 정보시스템 구축 관리