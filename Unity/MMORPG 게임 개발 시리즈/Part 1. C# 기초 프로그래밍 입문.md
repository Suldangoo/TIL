# **2. 개론**

- Visual Studio로 C# 기본 문법에 대해 실습
    - C#은 Microsoft에서 개발한 .NET과 함께 발표된 객체지향 프로그래밍 언어
- VS를 켠 후 C#, Windows 템플릿의 콘솔 앱에서 실습
- .NET 장기 지원 버전을 골라주고, 최상위 문 사용 안 함을 체크해주어야 함
    - 최상위 문 사용 안 함을 체크해야 기본 클래스가 생성된 상태에서 시작함
- 코드를 F5를 눌러 실행하고 나면, 프로젝트 폴더의 bin/Debug/net 폴더에 실행 파일이 생김
    - 디렉토리 주소창에 cmd.enter을 눌러 cmd를 켠 후 dir을 입력해 파일 목록 출력
    - 실행 파일 이름.exe를 입력하고 엔터를 누르면 그 코드가 실행됨

## **컴퓨터 구조**

- 메인보드의 구조를 보면, 대부분의 프로그램이 CPU가 연산하며, RAM이 메모리를 담당한다.
- 즉, 게임 역시 로직은 CPU가 처리하며, 데이터는 RAM이 담당한다.
- 단 RAM은 주기억장치로서 매우 높은 성능을 가지고 있지만, 휘발성 메모리라 컴퓨터를 종료하면 모든 메모리가 삭제되는 단점이 있다.
- 따라서, 데이터를 영구적으로 저장할 수 있는 저장장치인 보조저장장치가 존재한다.
- CPU는 굉장히 고급 인력으로, 중요한 연산을 수행하는데 바쁘다. 그러나 고성능 그래픽 연산 등의 하나하나 난이도는 낮지만 매우 많은 연산을 수행해야 하는 작업이 존재하는데, 이걸 모두 CPU가 담당하게 되면 큰 부하가 오게 된다.
- 따라서 이러한 난이도가 낮지만 많은 양을 처리하는, GPU가 별도로 존재할 수 있다.
- 원하는 게임을 실행한다면, 보조기억장치에 존재하던 게임의 데이터들 중 당장 연산이 필요한 일부가 RAM으로 올라가며, CPU의 연산과 함께 게임이 실행된다.

# **1. 데이터 갖고 놀기**

- C#의 주석 기호는 '//'과 '/* */' 이다.

```csharp
// 주석

/*  여러 줄
    주석    */
```

- 주석을 통해 TODO, 즉 언젠가 해야 할 작업에 대해 대략적인 메모를 남겨둘 수 있다.

### **데이터의 형식**

| int | 정수형 | -1, 0, 1, 2, 3 |
| --- | --- | --- |
| float | 실수형 | 3.14 |
| string | 문자열형 | “Hello” |
| bool | 불리언형 | true / false |
- 이 외에도 다양한 데이터 형식이 존재한다.
- 자신이 어떤 기능을 개발하게 되었을 때, 그 기능에 필요한 데이터들을 설계하고 적합한 형식을 미리 정해두는 것이 좋다.
    - 원하는 데이터에 최적화된 데이터를 사용할 수록, 예외적인 값이 대입되는 잘못된 상황에서 에러를 일으켜 잘못된 로직으로 번지는 일을 막을 수 있다.
- 정수형에는 변수에 넣을 수 있는 숫자의 크기에 따라 여러 타입이 존재한다.

| sbyte | -128 to 127 | 8비트 |
| --- | --- | --- |
| short | -32,768 to 32,767 | 16비트 |
| int | -2,147,483,648 to 2,147,483,647 | 32비트 |
| long | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 64비트 |

### **변수**

- 프로그램에서 데이터를 사용하려면, RAM의 메모리 공간 중 일부를 대여해서 써야 한다.
- 메모리의 모든 공간엔 주소가 할당되어 있다.
- 매 번 데이터 하나를 생성할 때마다 주소를 기입하려면 너무 번거롭기에, 이런 부분은 대부분 프로그래밍 언어와 하드웨어들이 알아서 정해준다.
- 변수는 일종의 바구니이며, 정해진 데이터 형식의 데이터를 메모리에 저장할 수 있다.
- 변수엔 데이터를 read, write / get, set할 수 있다.
- 변수의 이름엔 그 변수를 왜 쓰는지에 대한 이유를 간단하게 명시한다.
    - 예를 들어 플레이어의 체력이라면, 변수의 이름은 hp가 될 수 있다.
    - 이름을 짓는 규칙인 '컨벤션'이 존재하는데, 이는 프로젝트마다 상이하다.
- 데이터 형식과 이름을 통해 변수를 생성하고, 변수 이름에 대입 연산자를 써 원하는 데이터를 입력할 수 있다.

```csharp
int hp; // 한 줄 명령어의 끝엔 세미콜론이 붙는다.
hp = 100; // 대입 연산자(=)를 통해 원하는 변수에 값을 넣을 수 있다.
Console.WriteLine(hp); // 메모리에 저장되어있는 hp 변수의 값을 읽어와 출력한다.
```

- 변수 생성과 초기값 할당을 동시에 할 수 있다.
- hp와 maxHp같은 연관이 있는 변수의 경우, 각각 상수로 선언하기보다 기존 변수를 활용해 초기화를 하면 더 좋다.

```csharp
int maxHp = 100;

int hp = 100; // 좋지 않은 모델
int hp = maxHp; // 더 나은 모델
```

### **진법**

| 2진법 | 0b0000, 0b1010 |
| --- | --- |
| 8진법 | 0144, 012 |
| 10진법 | 0, 1, 2 |
| 16진법 | 0xA2, 0x12FFB2 |
- 10진법의 경우 0, 1, 2...
- 2진법의 경우 0b00, 0b01, 0b10...
    - 컴퓨터는 손가락 10개의 우리와 다르게 전기신호로 논리를 처리하기에, 2진법이 자연스럽다.
- 16진법의 경우 0x0, 0x1, 0xa...
- 비트 연산등을 할 때 다른 진법들이 도움이 된다.
- 16진법은 2진법을 4개 모으면 변환이 가능하다.

### **정수 범위**

- sbyte는 8비트, short는 16비트, int는 32비트, long은 64비트이다.
- sbyte는 2진수를 8개 쓰는 것이므로, 2^8 = 256개의 숫자를 표현 가능하다.
- 컴퓨터에선 최상위 비트를 부호 비트로 사용하며, 2의 보수법으로 표현한다.
    - 0111 1111의 경우엔 127이다.
    - 1111 1111의 경우엔 -1이다.
    - 1000 0000의 경우엔 -128이다.
- 이 원리때문에 sbyte의 크기가 -128부터 127이다.
- 1의 보수 방식으로 음수를 표현하게 되면 +0과 -0이 중복되어 메모리를 낭비하게 되며, 자주 쓰이게 되는 0이 전부 1비트로 표현되기 때문에 전력효율이 좋지 않다.
- 부호가 없는 (unsigned) 자료형으로 결정 시 0부터 시작하여 부호비트까지 전부 수 표현으로 쓴다.
    - 음수가 절대로 쓰일 수 없는 자료형에서 사용하면 좋다.
- 가장 중요한 것은, 데이터 크기를 아끼겠다고 작은 용량의 데이터를 사용했다가, 그것보다 더 큰 데이터가 담기게 될 일이 없도록 하는 것이다.

### float

```csharp
float f = 3.5f;
```

- 정수가 아닌 실수를 표현하는 자료형으로, 정수 그 이상으로 많이 사용된다.
- float형의 숫자를 적을 땐 반드시 숫자 뒤에 f를 붙여주어야 한다.
- float형 역시 정해진 메모리 크기가 있어서, 소수점 뒤에 아무리 많은 숫자를 적더라도 정밀도에 한계가 있어서, 소숫점 뒤의 숫자가 많아질수록 정확한 값이 저장이 안될 수 있으며, 근삿값이 저장된다.
- float와 유사한 부동소수형 데이터 타입인 double이 존재하며, double 데이터 타입엔 숫자를 대입할 때 f를 적지 않아도 된다.
    - 메모리를 더 많이 차지하는 대신, 더 정밀하게 저장할 수 있는 장점이 있다.
    - 그러나 특별한 상황이 아닌 이상 float가 대부분 사용된다.

### string

```csharp
char ch = 'S';
string name = "Suldangoo";
```

- 여러 개의 문자를 나열하여 저장할 수 있는 자료형이다.
- int나 float와 다르게, 역사가 좀 더 최근에 개발된 자료형이기 때문에 다양한 기능이 내장되어있다.
- 문자를 하나만 담는 자료형으로는 char형이 있다.
    - char형은 C++에선 1바이트지만, C#에선 2바이트이다.
- 컴퓨터가 한글, 영어, 중국어 등을 이해하고 저장할 수 있는 것은, 해당 글자와 매칭되는 정수를 저장하고 인코딩을 하는 원리이기 때문이다.
    - 인코딩 방식엔 ASCII, Unicode, UTF-8, 16 등등 다양한 포맷이 존재한다.

### boolean

```csharp
bool isAdmin = true;
bool isAutoPlay = false;
```

- 오로지 true와 false만을 저장하게 되는 아주 작은 데이터 타입.
- 컴퓨터 로직 내에서 true와 false만을 사용하는 경우가 매우 잦기 때문에 존재하는 근간이 되는 자료형이다.
- true와 false는 앞 글자를 소문자로 표기한다.

### 캐스팅

```csharp
int a = 100;
short b = a; // 에러 및 경고가 발생한다.
short b = (short)a;

float c = 3.14;
int d = (int)c;
```

- 데이터의 타입, 형식을 변환하는 것을 캐스팅이라고 한다.
- int → short 처럼 큰 타입에서 작은 타입으로 하는 변환은 너무나 위험하기 때문에 하지 않는 것이 좋다.
- 캐스팅을 하는 방법으로는, 바꾸고싶은 데이터 앞에 소괄호를 씌워 원하는 데이터 타입을 작성하면 된다.
- 그러나 short → int, int → float같은 크기가 비교적 작은 데이터에서 큰 데이터로 옮기거나, 옮겼을 때 호환성에 문제가 없다면 캐스팅 없이도 옮겨질 수 있다.
- C, C++에선 이런 캐스팅 위반에서도 에러가 뜨진 않고 경고만 뜨지만, C#은 이런 상황을 에러라고 인지하고 컴파일시켜주지 않는다.

### 스트링 포맷

```csharp
int a = 100;
string b = (string)a; // 에러가 난다.

string input = Console.ReadLine();
int number = int.Parse(input);

// 아래는 캐스팅은 아니지만, 스트링 포맷
string message = string.Format("당신의 HP는 {0} 입니다.", a);
string message = $"당신의 HP는 {a} 입니다.";
```

- 그러나 int → string은 얘기가 조금 다른데, string은 원시 자료형이 아닌 클래스이기 때문에 간단하게 형변환이 되지 않는다.
- 이렇게 원시 자료형과 클래스간, 혹은 클래스와 클래스간 형변환을 위해선 해당 데이터 타입만을 위한 캐스팅 메서드를 따로 사용해주어야 한다. 메서드나 방법은 여러가지이다.

| string → int | int.Parse(스트링 변수); |
| --- | --- |
| int → string | 인트 변수.ToString(); |

### 산술 연산 (데이터 가공)

```csharp
int hp = 100;
int damage = 10;

hp = hp - damage;
```

- 기본적인 사칙연산, 나머지, 괄호 연산 등은 여타 프로그래밍 언어와 동일하다.
    - 나누기, 나머지를 0으로 하게 되면 당연히 에러가 터진다.
- int 대상으로 나누기 연산을 하게 되면, 소수점 아래 부분은 모두 버려진다.
- float 나누기 int를 하게 되면, 결과로는 float가 나온다.
```jsx
// 축약대입연산자
a += 5;
a *= 2;

a++; // 후위 대입
a--;
++a; // 전위 대입
--a;
```

- 후위 대입은 해당 명령을 실행한 후 연산이 실행된다.
- 전위 대입은 해당 명령을 실행하기 전 연산이 실행된다.

### 비교 연산

```jsx
int a; = 10;
int b; = 5;

a >= b; // true
a == b; // false
a != b; // true
```

- 분기점을 만들기 위한 첫 번째 단계
- CPU가 두 변수를 가져와 연산한다.

### 논리 연산

- 여러가지 조건을 한 번에 파악하거나, 혼합하여 논리적으로 결과를 추론하는 것.
- AND, OR, NOT, XOR 등이 존재한다.

```csharp
&& // AND
|| // OR
! // NOT
```

- 논리연산자를 통해 연산한 결괏값은, 반드시 boolean 형태의 true / false로 나타나게 된다.
- OR 연산자는 C#, C++에서 단축 평가를 사용하고 있기 때문에, 앞 조건이 true가 나온다면 뒤 연산을 절대로 실행하지 않는다.
    - 때문에 오른쪽 조건에 함수 호출이나 사이드 이펙트가 있다면 이 함수가 실행되지 않을 수도 있음을 반드시 염두에 두어야 한다.
### 데이터 마무리

```csharp
var a = 10;
var b = 3.14f;
var c = "Rookiss";
```

- var 타입을 사용하게 되면, 컴파일하는 단계에서 뒤에 담긴 데이터 타입을 보고 자료형을 즉석에서 정해준다.
- 매우 좋아보이지만, 그럼에도 불구하고 직접적으로 타입을 지정해주는게 더 좋다. 그래야 코드의 가독성과 직관성이 매우 좋아지기 때문이다.

# **3. 코드의 흐름 제어**

### if와 else, 분기문

```csharp
if (isDead) { // 첫 번째 중괄호의 위치 (컨벤션)은 팀마다 다르다.
	Console.WriteLine("");
}
else if (isAlive) {
	Console.WriteLine("");
}
else {
	Console.WriteLine("");
}
```

- else if 와 else문을 사용하지 않고, 모두 if문을 사용할 수도 있지만, 그럴 경우 논리적으로 실행되지 않아도 되는 조건문마저 크로스체크를 하여 조금씩 성능을 갉아먹을 수 있다.
- 물론 논리적으로 if문 여러개를 쓰는 것이 정답인 코드가 있을 수 있으니, 코드의 논리를 잘 따져야 한다.

### switch

```csharp
int choice = 0; // 0:가위 1:바위 2:보

switch (choice) {
	case 0 : // case에 대해서는 중괄호를 쓰지 않고, 콜론을 사용한다.
		break; // break를 수행하지 않으면, 아래의 모든 명령어들을 전부 수행한다.
	case 1 :
		break;
	case 2 :
		break;
	default :
		break;
}
```

- switch-case문에서 내부엔 문자열이나 정수를 넣을 수 있다.
    - 최신 C#에서 객체를 넣을 수도 있게 되었다.
- switch-case문으로 적을 수 있는 논리는 모두 if-else로 표현할 수 있다.
- 그러나 if-else로 표현할 수 있는 모든 논리를 switch-case로 표현하지는 못한다.
    - 명제의 역은 참이 아니다.
- 가독성이 참 좋으므로 switch문을 쓰는게 적합한 상황에선 if-else보다 우선적으로 사용한다.

```csharp
// 삼항연산자
int number = 25;

bool isPair = (number % 2) == 0 ? true : false;
```

- 삼항연산자는 취향에 따라 가독성을 나쁘다고 생각하는 개발자도 있다.
- 그러나 잘 숙지하여 다른 개발자가 적은 삼항연산자는 반드시 읽을 줄 알아야 한다.

### 가위바위보

```csharp
Random rand = new Random();
int aiChoice = rand.Next(0, 3); // 0 ~ 2 사이의 랜덤 값

int choice = Convert.ToInt32(Console.ReadLine());

switch (choice) {
	case 0 :
		Console.WriteLine("당신의 선택은 가위입니다.");
		break;
	case 1 :
		Console.WriteLine("당신의 선택은 바위입니다.");
		break;
	case 2 :
		Console.WriteLine("당신의 선택은 보입니다.");
		break;
}

switch (aiChoice) {
	case 0 :
		Console.WriteLine("컴퓨터의 선택은 가위입니다.");
		break;
	case 1 :
		Console.WriteLine("컴퓨터의 선택은 바위입니다.");
		break;
	case 2 :
		Console.WriteLine("컴퓨터의 선택은 보입니다.");
		break;
}

int result; // 승패를 가리는 변수, 0은 무승부, 1은 승리, 2는 패배

// 승패판정
if (choice == aiChoice) {
	result = 0;
}
else if ((choice == 0 && aiChoice == 2) ||
				 (choice == 1 && aiChoice == 0) ||
				 (choice == 2 && aiChoice == 1)) {
	result = 1;
}
else {
	result = 2;
}

switch (result) {
	case 0 :
		Console.WriteLine("비겼습니다.");
		break;
	case 1 :
		Console.WriteLine("승리하였습니다.");
		break;
	case 2 :
		Console.WriteLine("패배하였습니다.");
		break;
}
```

### 상수와 열거형

- 위 가위바위보 코드에서, 우리는 가위, 바위, 보를 숫자 0, 1, 2로 정의했다.
- 이렇게 int 변수의 수에 원하는 정의를 내리니, 코딩도 복잡하며, 추후에 유지관리가 매우 힘들다.
- 이렇게 강제로, 임의적으로 숫자에 의미를 박아넣는 것은 하드코딩이며, 절대로 해선 안될 일이다.

```csharp
const int ROCK = 1; // 전부 대문자를 씀으로서 절대 변하면 안되는 변수라는것을 표시
const int PAPER = 2;
const int SCISSORS = 0;

switch (choice) {
	case SCISSORS :
		Console.WriteLine("당신의 선택은 가위입니다.");
		break;
	case ROCK :
		Console.WriteLine("당신의 선택은 바위입니다.");
		break;
	case PAPER :
		Console.WriteLine("당신의 선택은 보입니다.");
		break;
}
```

- switch-case 문에서 case 뒤에, 값이 유동적으로 변하는 변수는 절대 들어갈 수 없다.
    - 반드시 값이 절대 변하지 않는, 상수가 들어가야 한다.
- 따라서 변수 설정 앞에 const를 넣음으로서 해당 변수를 상수화하고, switch-case문으로도 사용 가능하게 한다.
- 상수를 사용하는 것도 좋지만, 이름이 겹치지 않게 조심해야 하며, 각 변수가 서로 연관이 있는 개념임에도 서로 하나의 그룹으로서 사용할 수 없다.
    - 이 때 사용하는 것이 Enum, 열거형이다.

```csharp
class Program {
	enum Choice { // 열거형 생성
		Rock = 1, // 뒤에 값을 정의하지 않으면 알아서 위에부터 0이 된다.
		Paper = 2,
		Scissors = 0
	}
	
	static void Main(string[] args) {
		// ...
		
		switch (choice) {
			case (int)Choice.Scissors :
				Console.WriteLine("당신의 선택은 가위입니다.");
				break;
			case (int)Choice.Rock :
				Console.WriteLine("당신의 선택은 바위입니다.");
				break;
			case (int)Choice.Paper :
				Console.WriteLine("당신의 선택은 보입니다.");
				break;
		}
	}
}
```

- Enum으로 만들어 하나의 그룹으로서 묶어 자료형처럼 사용할 수 있다.
- Enum으로 선언한 값이 숫자처럼 보여도, Enum 타입이기 때문에 (int)로 한 번 캐스팅을 거쳐주어야 한다.
- 상수든 Enum이든 코드에 따라 맞는, 좋은 타입을 설정하면 되고, 중요한 것은 코드 로직 내부에 숫자를 박아 하드코딩을 하는 일이 없도록 하는 것이다.

### while (반복문)

```csharp
while (조건) {
	...
	
	조건의 변화
}
```

- 조건이 참이라면 아래의 행동을 수행하고, 다시 조건을 체크한다.
- 조건이 바뀌지 않고 계속 참이라면, 무한한 루프를 돌게 된다.
- 반복문을 짤 때 가장 중요한 것은 조건을 제대로 논리적이게 설정하는 것이다.

```csharp
do {
	...
	
	조건의 변화
} while ();
```

- do-while문은 일단은 한 번 실행한 다음, 그 후에 조건을 체크해 빠져나갈지를 결정한다.
- 대부분 그냥 while문을 사용하지만, 꼭 한번 실행해야 하는 상황에선 do-while문을 가끔 사용한다.
    - 예를 들어 로그인 같은 경우이다.
- while, do-while 모두 조건 변수를 그 내부에 정의해서는 안된다.
    - 이는 해당 로컬 변수의 유효 범위를 벗어나는 곳에서 참조를 하려는 행위이기 때문이다.
    - 이런 유효 범위를 스코프라고 한다.

### for

```csharp
for (초기화 식; 조건식; 반복식) {
	...
}
```

- for문이 맨 처음 돌아가기 전, 초기화를 한 번 한다.
- 반복문의 조건을 작성한다.
- 매 번 반복할 때마다 계속해서 호출되어야 할 반복식을 작성한다.
- 이렇게 초기설정을 해두면, 반복문에서 논리적으로 필요한 내용을 미리 작성해두고 시작할 수 있다.
    - 그러나 이 초기값들은 필수 작성이 아니고, 필요한 경우 작성할 수 있다.
- while문은 조건에 담은 객체가 작동 도중 계속 유기적으로 변하여서 언제 끝날 지 모를 때 사용하면 매우 좋다.
    - 예를 들어 스택이나 큐를 넣어두고 DFS, BFS를 구현할 수 있다.
- for문은 특정 횟수만큼 반복해야 할 때 매우 좋다.
- while문도, for문도 조건 안 비교 연산자를 <로 할지, ≤로 할지도 잘 고민해야 한다.

### break, continue

```csharp
for (~) {
	// 특정 조건에서 빠져나가고 싶은 경우
	break;
	
	// 특정 조건에서 아래 명령들을 스킵하고 다음 반복으로 가고싶은 경우
	continue
}
```

- break문은 해당 중괄호만 나가는게 아니라, for문 등 큰 반복문의 키워드가 범위이다.
- continue로 해당 페이지를 빠져나갔다면, 당연히 조건 변수에 증감을 주는 반복식은 실행이 된다.

### 함수 (메소드)

- 지금까지의 코딩은 main 안에 모든걸 욱여넣는 방식
- 이제부터 재사용될 코드들은 하나로 묶어서 하나의 기능으로 캡슐화해야한다.
- 해당 명령어의 묶음을 사용하는 걸 메소드를 사용한다고 한다.
    - C#에서는 메소드지만, 다른 언어에선 펑션, 함수, 프로시저 등등 많은 용어가 있다.

```csharp
한정자 반환형식 이름(매개변수) {

}

static void HelloWorld() {
	...
}

static int Add(int a, int b) {
	return a + b;
}

static void Main(string[] args) {
	HelloWorld();
}
```

- class 안에 Main 함수를 포함하여, 원하는 메서드를 작성한다.
- return 값에  따라 반환 형식을 결정해야 한다.

```csharp
static void AddOne(int n) {
	n++;
}

static void Main(string[] args) {
	int a = 0;
	AddOne(a); // 이거 해도, 값은 1이 아닌, 0 그대로 유지된다.
}
```

- 상식적으로 위 함수에 a를 넣어 변수 값이 1 늘어날 것 같지만, 절대 아니다.
- 변수를 넘기는 방법엔 복사와 참조가 있는데, 여기선 복사로 주기 때문에 완전히 다른 변수가 된다.

```csharp
static void AddOne(ref int n) {
	n++;
}

static void Main(string[] args) {
	int a = 0;
	AddOne(ref a); // 이거 해도, 값은 1이 아닌, 0 그대로 유지된다.
}
```

- 단, 파라미터와 호출 변수에 ref를 넣으면, 그때부턴 복사가 아닌 참조로 파라메터를 가져온다.
- 이렇게 되면 실제로 넣는 원본 변수에 영향을 끼치게 된다.

### ref, out

- ref로 원본을 변화하는 모델과, 그냥 원래 메소드 방식으로 return받는 모델 중 후자가 훨씬 더 범용적이고 코드 디자인적으로 좋다.
- 그럼에도 swap() 함수 등 실제로 ref를 쓰는 편이 좋은 부분도 분명 있다.
- 반대로, 파라메터에 out을 넣어서 원하는 변수만 리턴시키는 기능도 존재한다.

```csharp
static void Divide(int a, int b, out int result1, out int result2) {
	result1 = a / b;
	result2 = a % b;
}

static void Main(string[] args) {
	int result1;
	int result2;
	
	Divide(10, 3, out result1, out result2);
}
```

- out 키워드를 넣음으로서, 해당 함수에서 그 변수에 일어난 결괏값을 그대로 적용해줄수도 있다.
    - 값을 여러개 반환할 경우엔 out을 사용한다.
- ref는 그 파라메터를 넣지 않아도 되지만, out은 반드시 리턴할 변수를 넣어주어야 해서 오류를 잡아준다.
- 또한 반환형이 int인 함수에서 float를 반환할 수 있는 등, 복수의 리턴이 필요할 때 굉장히 좋다.

### 오버로딩

- 메소드 오버로딩, 함수 오버로딩은 과적하다라는 뜻을 가진다.
- 프로그래밍에선, 함수 이름의 재사용을 뜻한다.

```csharp
static int Add(int a, int b) {
	return a + b;
}

static int Add2() {}
static int Add3() {} // 이름을 이렇게 계속 새로 지으며 비슷한 역할을 하는 것은 좋지 않다.

static int Add(float a, float b) { // 파라미터가 다르다면 함수 이름이 같아도 된다.
	return a + b;
}
```

- 파라미터가 반드시 다르다는 가정하에, 같은 함수의 이름을 재사용할 수 있다.
- 그 경우, 함수를 호출하고 호출한 파라미터에 넣는 값에 맞는 함수가 알아서 골라 사용된다.
- 중요한 것은, 파라미터와 이름은 같은데 반환형식이 다른것은 절대 오버로딩이 되지 않는다.

```csharp
static int Add(int a, int b, int c = 1) { // 선택적 매개변수
	return a + b + c;
}
```

- 파라미터, 매개변수에 미리 값을 하나 초기화시킨것을 함수 정의에 작성하면, 해당 인자에 아무런 값을 넣지 않을 경우 알아서 default값을 사용하게 된다.
    - 즉, 필수 파라미터와 옵션 파라미터를 정할 수 있다.
- 만약 넣을 것이라면, 파라미터의 순서를 굉장히 잘 신경써야 한다.
- 호출할 때 파라미터의 순서에서, C++은 그 호출 순서도 신경써야 하지만, C#은 다르다.

```csharp
Add(1, 2, d:2.0f); // 원하는 파라미터에 원하는 값을 넣도록 명시할 수 있다.
```

- 순서와 관계없이 원하는 파라미터에 원하는 값을 넣도록 명시할 수 있다.

### 연습문제

- 구구단

```csharp
namespace CSharp
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 2; i < 10; i++)
            {
                for (int j = 1; j < 10; j++)
                {
                    Console.WriteLine($"{i} * {j} = {i * j}");
                }
            }
        }
    }
}
```

- 별찍기

```csharp
namespace CSharp
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 1; i <= 5; i++)
            {
                for (int j = 1; j <= i; j++)
                {
                    Console.Write("*");
                }
                Console.WriteLine();
            }
        }
    }
}
```

- 팩토리얼

```csharp
using System;

namespace CSharp
{
    class Program
    {
        static int Factorial(int n)
        {
            int result = 1;

            while(n > 1)
            {
                result *= n;
                n--;
            } 

            return result;
        }

        static void Main(string[] args)
        {
            int ret = Factorial(5);
            Console.WriteLine(ret);
        }
    }
}
```

```csharp
using System;

namespace CSharp
{
    class Program
    {
        static int Factorial(int n)
        {
            if (n <= 0)
                return 1;

            return n * Factorial(n - 1);
        }

        static void Main(string[] args)
        {
            int ret = Factorial(5);
            Console.WriteLine(ret);
        }
    }
}
```

# 4. TextRPG

### 디버깅 기초

- 모든 프로그래머는, 프로그래밍보다 디버깅을 훨씬 더 많이 한다.
- 디버깅이란 의사가 환자를 진료하는 것과 같은 의미로, 프로그래머가 한 줄씩 코드를 실행시켜보고, 변수를 바꿔가며 코드에 문제가 있는지, 있다면 어디에 있는지 찾아내는 행위이다.
- VS에서 코드 한 줄의 맨 왼쪽 영역을 클릭하거나, F9를 누르면 브레이크 포인트를 찍는다.
    - 프로그램을 실행하다가 해당 브레이크 포인트에서 일시정지하는 의미이다.
- 해당 장면에서 멈춘 다음, 여러가지 정보를 열람할 수 있는데, 호출 스택이나 변수들의 값을 확인할 수 있다.
- F10을 눌러 프로시저 단위로 실행할 수 있다.
    - 프로시저 단위로 실행하면, 메서드나 함수 단위를 한 번에 실행하고 바로 다음으로 간다.
- F11을 눌러 한 줄씩 실행할 수 있다.
    - 한 줄씩 가면, 호출하는 메서드나 함수로 들어가서 또 한 줄씩 실행하게 된다.
    - 그 때 조사식이라는 것을 보면, 메서드에 들어간 값을 조회할 수 있고, 심지어 변경도 할 수 있다.
- 메소드 안에서 메소드를 호출하면, 콜스택에 함수들이 쌓이며, 함수안에서 실행된 함수가 종료되면, 그 전에 있던 함수로 복귀하게 된다. 이 과정에서 호출 스택을 다루게 되고, 디버깅 과정에서 호출 스택을 볼 수 있다.
- 즉, 몇천줄의 코드 안에서 어떤 메소드 안에 브레이크 포인트를 찍고 실행하게 되면, 호출 스택을 보고 어떤 메서드를 통해 여기까지 도달했는지 알 수 있다.
- VS에선, 종단점. 즉 브레이크 포인트에 조건을 걸어버릴 수 있다! 브레이크 포인트에 우클릭을 하고 조건을 적어놓으면, 해당 조건에 걸릴 때만 브레이크 포인트가 작동을 하게 된다.
- 심지어 브레이크 포인트로 일시정지되었다면, 왼쪽 화살표를 드래그해 조작함으로서 원하는 명령어를 더 실행하게 하는 등, 마음대로 실행 순서를 조작할 수도 있다.

### 게임 제작

- 캐릭터 직업 등, 하나로 묶을 수 있으며 타입이 정해지는 경우엔 Enum을 설정하면 매우 도움이 된다.
- 그리고 직업을 고르는 메서드를 만든다면, 메서드의 반환 타입을 Enum으로 만들었던 ClassType으로 두어 해당 직업을 리턴하는 방식으로 메서드를 만들면 예쁜 구조가 된다.
- 이제 직업에 따라 hp, attack 등을 정해야 할 때, 가장 좋은 구조는 구조체를 만드는 것이지만 우선 거기까지 진도를 나가지 않았으므로, 두 개 이상의 변수를 한 번에 리턴받아야 한다.

```csharp
static void CreatePlayer(out int hp, out int attack) {
 ...
}

int hp;
int attack;
CreatePlayer(out hp, out attack);
```

- 따라서 이렇게 하나의 static 메서드에 out으로, 복사가 아닌 참조 방식으로 두 개 이상의 변수를 한 번에 처리하게 만들 수 있다.
    - out 파라미터가 있는 함수 내부를 구현할 때는, 항상 해당 함수 내에서 out을 무슨 값이든 정의를 해주어야 한다. 그렇지 않으면 에러를 낸다.
    - switch-case 문 등을 사용할 경우, 반드시 default를 사용하여 값을 0이라도 주어야 한다.

### 구조체

- 만약 플레이어의 데이터 컬럼이 Hp, Attack 뿐만 아닌 Mp, Dex, Int, 기타 등등의 수십개의 속성이 생겨나게 되면, 위 사항처럼 하나하나를 out으로 전부 지정하는 것은 여간 귀찮은 일이 아니다.
- 구조체는 내가 원하는 데이터의 모음집을, 자료형과 관계 없이 하나로 모아 묶어 논리 단위를 만드는 것이다.
- struct 예약어를 통해 Enum처럼 정의할 수 있다.

```csharp
struct Player {
	public int hp; // 접근지정자를 public으로 하지 않으면, 기본적으로는 은닉한다.
	public int attack;
	public ClaasType type;
}
```

- 그렇게 되면 해당 구조체를, 하나의 변수 자료형으로서 새로 정의하고, 초기화하여, 이곳저곳에 할당할 수 있게 된다.

```csharp
Player player; // 해당 구조체로 새로운 객체 생성
player.hp = 100; // 해당 객체의 hp 멤버에 값을 초기화
```

# 5. 객체지향 여행

### 객체지향의 시작

- 기존에 하던 것은 절차(procedure)지향으로, 함수를 기반으로 무언가를 만드는 것이다.
- 지금까지 어떤 기능을 만들고자 하면, 해당 기능을 하는 함수를 만들고, 조립하여 프로그램을 만들었다.
- 작고 빠른 방식으로 프로젝트를 진행할 땐 직관적이고 좋으나, 프로젝트가 커질수록 유지보수가 어려워진다.
- 함수 호출 순서가 가장 중요한 이슈가 된다.
    - 어떤 함수 안에서 함수를 호출할 때가 특히 그렇다. 만약 기획이 변경되면 전체적인 코드 흐름을 전부 수정해야하는 문제가 생긴다.
- **객체지향(OOP; Object Oriented Programming)**은, 모든 것을 객체 위주로 생각해서 프로그래밍하는 방식이다.
- 플레이어, 몬스터, NPC, 화살 등 게임 내 모든 것들이 전부 하나의 객체로서 존재하게 된다.
- 객체의 구성 요소는 **속성과 기능**으로 분류할 수 있다.
    - 속성 : hp, attack, pos 등등 데이터
    - 기능 : Move, Attack, Die 등등 해당 객체가 수행하는 행동
- 객체를 정의한다는 것은 붕어빵 틀과 유사하다. 객체를 정의한 후, 실제로 해당 객체가 필요할 때 객체를 찍어내면 된다.

```csharp
class Knight
{
	public int hp; // 접근 지정자는 보통 private로 두고, getter와 setter를 두는 편이다.
	public int attack;
	
	public void Move()
	{
		Console.WriteLine("Knight's Move");
	}
}
```
- 이렇게 만든 객체 설계도로, 메인 코드에서 객체를 생성할 수 있다.

```csharp
Knight knight = new Knight(); // new는 해당 객체를 새로 생성한다는 생성자이다.

knight.hp = 100;
knight.attack = 10;

knight.Move();
```

### 복사와 참조

- 다른 표현으로는 얕은 복사, 깊은 복사라고도 한다.

```csharp
class Knight // 클래스
{
	public int hp;
	public int attack;
}

struct Mage // 구조체
{
	public int hp;
	public int attack;
}

// 같은 역할인데 무엇이 다를까?
```

- 클래스는 요소에 대해 **참조**를 하고, 구조체는 **복사**를 한다.
- 클래스로 만든 객체가 다른 함수에 참조되어 값이 변경될 경우, 주소를 참조하기 때문에, ref 등의 연산자를 쓰지 않아도 그 객체 원본에 그대로 영향을 미치게 된다.
- 단 구조체는 해당 값을 복사한 다른 것이 넘어가기 때문에 원본엔 영향을 끼치지 않는다.
    - 거기에 더불어 구조체는 new 생성자를 쓸 필요가 없다.

```csharp
Knight knight2 = knight;

// 위와 같은 경우, 기존 knight의 주소를 참조해 넘겨주기에 둘은 같은 객체이며, 이름만 두 개가 생겼을 뿐이다.
// 정말 두 개의 객체를 원한다면

Knight knight2 = new Knight();
```

- 혹은 깊은 복사라 하여, 해당 객체 안에 새로운 메서드로 새 객체를 생성해 리턴하게 한다면 깊은 복사가 이루어져 새로운 원본이 만들어진다.

### 스택과 힙

- 프로그램을 실행하면, 운영체제에서 해당 프로그램이 쓸 메모리 영역을 준다.
- 하나는 **스택 메모리**, 하나는 **힙 메모리**이다. 물론 이것 말고도 다른 영역도 있다.
    - 스택 메모리는 불안정하고, 일시적이다.
    - 함수 안에서만 쓰는 지역 변수라던가, 함수 콜스택 위치를 저장한다.
- 구조체와 같은 복사되는 값은 메모리에 본체, 원본이 들어간다.
- 그러나 참조형인 클래스는, 메모리 안에 주소값이 들어간다.
    - 여기서 그럼 참조형의 원본은 어디있나? 한다면, 그곳이 바로 힙 메모리이다.
- 그렇다고 모든 참조가 전부 힙을 가리키고 있다고 생각하면 안된다. ref 구조체를 하게 될 경우, 참조하는 주소값이 stack  내부일 수 있다.
- 스택 영역은 프로그래머가 신경쓸 필요 없다. 공간의 크기가 알아서 늘어나고 줄어들기 때문에, 다 사용한 지역 변수도 전부 회수되기 때문에 자료구조적으로 관리 난이도가 매우 쉽다.
- 그러나 힙 영역은 한 번 메모리를 할당하고 아무런 행동도 하지 않으면 메모리를 그대로 낭비하게 된다. 따라서 언어에 따라 다르지만, 프로그래머가 반드시 메모리를 해제해야한다.
- C#은 특정 객체를 그 어떤 변수도 참조하고있지 않을 때 알아서 메모리를 해제하기 때문에, 메모리 관리 측면에서 C/C++보단 조금 더 난이도가 쉽다.

### 생성자

- 지금까지는 new로 객체 생성 후, 일일히 수동으로 속성값을 넣어주었다.
- 생성자를 사용하면 객체 생성과 동시에 속성값을 설정할 수 있다.

```csharp
class Knight
{
	public int hp;
	public int attack;
	
	public Knight() // 생성자는 클래스와 같은 이름으로, 그 무엇도 붙여선 안된다.
	{
		hp = 100;
		attack = 10;
		Console.WriteLine("기사 생성");
	}
	
	public Knight(int hp) // 인자를 받는 오버로딩이 가능하다.
	{
		this.hp = hp; // 이름이 같기 때문에 문법적 오류를 방지하기 위해 this를 쓴다.
	}
	
	public void Move()
	{
		Console.WriteLine("Knight's Move");
	}
}
```
- 위 예제에서 생성자를 오버로딩 한 부분이 attack를 빼먹었다.
- 물론 새로 쓸 수도 있지만, 코드가 너무 길어지고, 다루는 속성도 많은데 이걸 전부 관리할 수는 없으니, **빈 생성자를 우선 실행한 뒤 값을 덮어씌우는 개념**으로 접근하는 기능이 있다.

```csharp
public Knight(int hp) : this() // 빈 생성자를 우선 실행한다.
{
	this.hp = hp; // 그 후에 원하는 값을 덮어씌우게 된다.
}
```

- 이 기능을 Base라고 하며, Java에서 super와 유사한 개념이다.

### static의 정체

- static이 붙지 않은 클래스 내 필드(속성과 메서드들)는 여러 개의 객체, 인스턴스 내에서 독립적으로 기능하게 된다.
    - Knight1과 Knight2가 둘 다 공격이라는 메서드가 있어도, 둘의 성장에 따라서 공격력의 차이가 다를 수도 있다는 것이다.
- 그러나 static, 정적이라는 키워드가 붙었다면, 해당 필드는 해당 클래스의 객체에 종속되는 것이 아닌, **해당 클래스 자체에 종속**되게 된다.
    - **오로지 하나만 존재**한다는 것이 매우 중요하다.
    - Knight 클래스에서 객체를 수백개 뽑았어도, 그 수백개의 객체는 단 하나의 static 변수를 서로 공유해서 쓰고 있는 것이다.
- 필드에 사용할 수 있으므로 변수뿐만이 아닌 함수, 메서드에도 static을 사용할 수 있다.
    - 이렇게 되면 해당 클래스에 종속되어서, 객체에서 발동하는게 아닌 클래스 자체로 발동하는 것이 가능하다.
    - 중요한 것은, 모든 클래스가 사용하기 때문에, **static 메서드 내부에선 필드 변수 값을 건드릴 수 없다! this 키워드는 당연히 사용하지 못한다.**
    - static 메서드 안에서는 static 필드만 수정할 수 있게 되는 것이다.

```csharp
// 일반적인 메서드를 호출할 때
Knight knight = new Knight(); // 객체 생성
knight.Attack(); // 해당 객체가 해당 행동 수행

// static 메서드를 호출할 때
Knight.Attack(); // 클래스 자체가 해당 행동을 수행하기에, 객체와 무관
```

### 상속성

- 객체지향의 3대 속성을 얘기하라고 한다면 **은닉성, 상속성, 다형성**이 있다.
- 여러 개의 RPG 직업이 있을 때, Hp나 공격력 등의 중복된 속성들이 정말 많음
- 이런 많은 속성을 전부 다 일일히 만들어버리는 것은 정말 비효율적인 작업
- 기사, 궁수, 법사, 도적을 모두 묶을 수 있는 부모 클래스를 만들어 상속시키면 된다.

```csharp
class Player
{

}

class Knight : Player // 콜론을 찍어 상속하고자 하는 부모 클래스의 이름 명시
{

}
```
- 자식 클래스를 생성하게 되면, 부모의 생성자를 우선 실행한 후 자식의 생성자를 실행하게 된다.
- 단 base를 사용하면, 기본 생성자가 아닌 부모의 인자 생성자 또한 사용할 수 있다.

```csharp
class Knight : Player // 콜론을 찍어 상속하고자 하는 부모 클래스의 이름 명시
{
	public Knight() : base(10)
	{
		// 부모의 인자 10인 생성자로 생성 후 자식을 생성하게 된다
		this.hp = 100; // this가 자신을 의미하고
		base.hp = 100; // base가 부모를 의미한다.
	}
}
```

- base 키워드를 사용해 부모의 필드나 생성자에 접근할 수 있다.

### 은닉성

- 객체지향의 3대 속성을 얘기하라고 한다면 **은닉성, 상속성, 다형성**이 있다.
- 자동차에는 정말 수백가지의 기계 부품들과 머신들의 기능이 있지만, 사용자는 핸들 돌리기, 페달 밟기, 문 여닫기만 하면 된다.
    - 자동차의 모든 기능을 전부 사용자에게 다 알려줄필요는 없고, 필요한 기능만 알려주는 것이 사용자 입장에서 더욱 용이하다.
    - 또한 엔진, 기름, 전기장치 기능을 모두 오픈한다면, 사용자가 잘못 다룰 경우 자동차가 고장나거나, 심하면 폭발할 수 있다.
    - 따라서 안전을 위해, 필요한 기능만 노출시키는 것이다.
- 지금까지는 모든 필드의 접근지정자를 public으로 두었다. 모두에게 공개하고, 수정할 수 있다는 뜻이다.
- 그러나 매우 중요한 정보이거나 사용이 제한되어야 하는 정보의 경우엔 public을 사용해선 안된다.

| public | 모두에게 공유해서 사용할 수 있다. |
| --- | --- |
| protected | 본인 클래스와 상속받은 자식 클래스에서 사용할 수 있다. |
| private (혹은 비워놓음) | 본인 클래스 내부에서 정의된 로직에서만 사용할 수 있다. |
- 그래서 보통 필드 변수들은 private로 두고, public인 게터와 세터를 열어둔다.
    - 굳이 변수를 잠궈놓고 게터세터로 하는 이유는, 이곳저곳에서 해당 변수를 조작할 때 문제가 생겼다면, 함수의 콜스택을 보고 문제가 생긴 순간을 포착하기 쉽기 때문이다.
    - 또한 해당 변수에 들어가면 안 되는 값이 들어가는 경우를 필터링하는 로직도 포함시킬 수 있다.
### 클래스 형식 변환

- 만약 RPG게임에서 기사, 법사, 궁수 직업의 클래스가 있고, 이 클래스 객체를 인자로 하는 함수가 있다면, 인자는 어떻게 넣어야 할까?

```csharp
static void EnterGame(Knight knight) {...}
static void EnterGame(Mange mage) {...}
static void EnterGame(Acher acher) {...}
```

- 모든 클래스에 대응되도록 함수를 전부 따로 만들어 오버로딩을 하는 것은 굉장히 비효율적이다.
- 여기서 쓰는 것이, 클래스의 변환성이다.
```csharp
static void EnterGame(Player player) {...}
```

- 기사, 법사, 궁수 모두 동일 속성때문에 Player라는 객체를 상속받았었다.
- 해당 함수의 인자에 기사를 넣든, 법사를 넣든 잘 작동된다.
- 잘 생각해보면, 기사나 법사가 할 수 있는 고유의 기능은 분명 있지만, 부모인 Player가 할 수 있는 것은 기사, 법사, 궁수 너나 할것 없이 상속받았기 때문에 모두가 가능하다.
- 여기까지는 좋은데, 해당 함수에서 법사만 가지고 있는 MP 자원을 써야할 수도 있다면? 그 때는 클래스의 형 변환이 필요하다.
```csharp
Player mage = new Mage(); // 가능
Mage mage = new Player(); // 불가능
```

- Player 자료형의 변수에 Mage를 넣는 것은 가능하다.  해당 변수로 조작할 것(Player의 필드와 메서드)은 모두 Mage에 있지만, Mage에서 조작해야 하는 고유의 기능이 Player 객체에는 없을 수 있기 때문이다.
    - 이는 밴다이어그램으로 해석하면 쉽다.
    - 모든 Mage는 Player인가요? → 예. 따라서 메이지는 플레이어가 되어도 좋습니다.
    - 모든 Player는 Mage인가요? → 아니오. Player중엔 기사도, 궁수도 있습니다. 따라서 Player가 메이지가 되어서는 안됩니다. 해당 Player가 기사라면 어쩌려고요?
- 그러나 Mage → Player → Mage로 변환을 해야할 때는 분명히 있다. 바로 위의 부모를 인자를 받은 함수가 그렇다.
    - Mage → Player는 간단하다. 그냥 Player 변수를 선언해서 넣어주면 된다.
    - 그러나 Player → Mage는 위에서 말한 오류로 인해 불가능하다. 이 땐 임의적으로 캐스팅을 해도 좋다고 개발자가 명시해주어야 한다.
```csharp
Player player = mage;
Mage mage = (Mage)player;
```

- 이렇게 메이지를 플레이어로 바꾸었다고 해서, 해당 객체가 메이지의 기능을 잃어버린 것은 절대로 아니다. 애초에 객체는 참조타입이다. 원본은 분명히 어딘가에 잘 갖추어져 있고, Player일 동안엔 Mage 고유의 기능을 잠시 사용하지 않는 것 뿐이다.
- 그러나 만약 캐스팅을 했으나, 예외로 인해 나이트가 (Mage) 뒤에 들어왔다면 어떻게 될까?
    - 문법상엔 아무런 문제가 없다. 그러나 당연히 프로그램을 실행하면 크래쉬가 난다.
- 때문에 한 번 해당 Player가 정말로 Mage가 맞는지 질문을 하고, 맞다면 통과하면 된다.

```csharp
bool isMage = (player is Mage);

if (isMage)
{
	Mage mage = (Mage)player;
	mage.mp -= 10;
}
```
- is라는 키워드를 사용하면, 해당 객체의 원형이 이 클래스가 맞는지를 물어볼 수 있다. 그 리턴값은 bool로 리턴된다.
- 또 다른 방식으론 as 키워드가 있다.

```csharp
Mage mage = (player as Mage); // Mage라면 한 번에 캐스팅까지 하지만, 아니라면 null 반환

if (mage != null)
{
	mage.mp -= 10;
}
```

- 맞다면 바로 캐스팅하고, 아니라면 null을 반환시켜서, null이 아니라면 원하는 행동을 수행하게끔 할 수도 있다.
- 대부분의 경우에는 as를 사용한다. as가 조금 더 대중적으로 많이 사용되고 코드도 깔끔하기 때문에, 많은 표준 프로그램이 as를 지원한다.
### null

- null은 정말 말 그대로 없다는 뜻이다.
- 내부가 비어있음을 뜻한다.
- 아무것도 참조하지 않는 객체를 만들고 싶다면, null을 이용할 수 있다.

```csharp
Knight knight = null;
```

- 만약 원하는 플레이어를 탐색하는 기능을 만들었다면, 모든 플레이어 탐색 후 원하는 플레이어를 리턴하면 되지만, 해당 플레이어를 찾지 못했다면 null을 리턴하게끔 하여 논리성을 만들 수 있다.

### 다형성

- 객체지향의 3대 속성을 얘기하라고 한다면 **은닉성, 상속성, 다형성**이 있다.
- Polymorphism, 여러 가지 형태를 가지고 있다는 의미이며, 대표적인 것이 **오버라이딩**이다.
- C# 객체지향에서 다형성을 사용하기 위해선 가상함수를 만들어야 한다.
    - 그를 위해 쓰는 키워드가 virtual, override 이다.
- 부모 클래스에서 가상 함수를 만들고, 자식들이 오버라이딩하는 것이다.
    - 오버로딩은 함수 이름의 재사용이고, 오버라이딩은 같은 함수를 다른 형태로 만드는 것이다.
- 이렇게 되면 부모 클래스로 받은 함수에서도 자식 고유의 오버라이딩 메서드를 사용하게 된다.
- C#에선 오버라이딩을 하고 싶다면, 반드시 덮어씌울 원본 함수는 가상함수여야 한다.
- 추가적으로 오버라이딩 함수 안에서 base.Move() 등 부모의 원본함수를 먼저 쓰고 내것을 사용하는 것 또한 가능하다.

```csharp
public sealed override void Move() {}
```

- 또한 sealed 키워드를 오버라이드 앞에 붙여 더 이상 자신의 자식들은 오버라이딩 하지 못하게끔 막는 것 또한 가능하다.