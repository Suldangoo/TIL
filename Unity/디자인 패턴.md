## 1. 싱글턴 패턴 : 게임 매니저

- 싱글턴 패턴의 주요 목적은 유일성을 보장하는 것이다.
- 싱글턴 패턴으로 구현된 클래스는 어떻게 몇 번 호출되더라도 메모리에 오직 하나의 인스턴스만 존재해야 한다. 그 어떤 경쟁도 용납하지 않는다.
- 주로 보드게임 마스터와 같은 게임 매니저나, 백엔드 서비스와 통신, 전역 설정 초기화 등에 사용된다.
- 게임 매니저는 게임의 전체 수명 동안 단 하나의 인스턴스로서 살아있어야 한다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 전역 접근 가능 | 리소스나 서비스의 전역 접근점 지원 |
| 동시성 제어 | 공유 자원에 동시 접근을 제한할 수 있음 |

| 단점 | 단점 설명 |
| --- | --- |
| 유닛 테스트 | 과도한 싱글턴은 싱글턴 종속성을 만들어 단독으로 테스트하는 것이 불가능해짐 |
| 잘못된 습관 | 너무 쉬운 사용법에 전역 접근이 정교한 접근법 설계를 귀찮게 만들 수 있음 |

### 코드 논점

- 제네릭을 활용한 싱글턴 클래스를 만들고 이를 상속받는 것으로 쉽게 확장성을 확보할 수 있다.
- 정적(static) 변수나 함수 사용으로 전역적 접근점을 만들어서 사용한다.
- Awake() 함수의 경우 virtual로 지정하여 상속받은 파생 클래스에서 재정의할 수 있도록 한다.
    - Awake() 함수 내부에서 싱글턴 인스턴스가 있는지 확인하고, 없다면 자신이 싱글턴 인스턴스가 되며, 있다면 스스로를 제거한다.
    - DontDestroyOnLoad 메서드를 사용하여 씬 전환 시에도 오브젝트가 유지되도록 한다.

## 2. 상태 패턴 : 캐릭터 상태 관리

- 상태 패턴은 객체가 여러 상태를 가질 수 있을 때, 상태마다 클래스를 만들어 그 상태에 따라 행동하도록 구조화하는 디자인 패턴이다.
    - 만약 상태 패턴을 사용하지 않으면 if-else 문이나 switch 문으로 현재 상태를 필터링하고 행동하도록 해야 해서 복잡하고 유지보수가 힘들어진다.
- 객체의 유한 상태를 관리하고, 객체가 내부 상태를 기반으로 동작할 수 있도록 하는 것이다.
- 상태 패턴은 클래스를 간소화하고 유지관리가 쉽도록 만들어준다.
- 상태 패턴 구조에는 세 가지 핵심 요소가 있다.
    - Context 클래스 : 객체 내부 상태를 보유하고, 변경하도록 요청하는 인터페이스를 정의
    - IState 인터페이스 : 모든 상태 클래스의 인터페이스로, handle() 메서드 원형
    - 각 ConcreteState 클래스 : 여러 종류의 상태 클래스들로, public으로 IState의 handle 정의
- 객체의 상태를 업데이트할 땐 반드시 상태 패턴의 감독인 Context 클래스를 거쳐야 한다.
- 각 상태마다 Enter(), Update() 등이 존재해서, 현재 상태에 맞는 코드가 캡슐적으로 실행된다.
- 상태 전환은 Context의 Transition()으로만 가능해서 무질서하게 상태가 바뀌지 않는다.

### 코드 논점

- 정의한 유한 상태에서 예상할 수 있는 동작을 캡슐화한다는 목표로 상태 패턴을 구현해야 한다.
- Context 클래스에서 현재 상태를 카리키는 CurrentState를 public 프로퍼티로 만들어 모든 상태 변경을 인식하고, Transition() 함수를 호출해 상태를 전환하도록 구현할 수 있다.
- Transition() 함수는 오버로딩을 통해 파라미터가 없다면 단순히 Handle을, 파라미터로 IState의 상태를 삽입한다면 해당 상태로 현재 상태를 변환한 후 Handle을 할 수 있다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 캡슐화 | 상태가 변할 때 개체에 동적으로 할당할 수 있는 컴포넌트 집합이므로, 상태별 행동 구현 |
| 동시성 제어 | 긴 조건문이나 방대해진 클래스 수정 없이 새로운 상태를 얼마든 추가할 수 있음 |

| 단점 | 단점 설명 |
| --- | --- |
| 블렌딩 | 기본 형태의 상태 패턴은 애니메이션 블렌드를 제공하지 않음 |
| 전환 | 패턴 구현에서 상태 간 관계를 정의하지 않아 이를 구현하려면 더 많은 코드가 필요 |
- 두 단점은 유니티의 애니메이터를 통해 극복할 수 있다. 애니메이션 상태를 쉽게 정의하고 파라미터를 통해 쉽게 트리거를 작동하며 애니메이션 블렌딩을 지원한다.

### 대안

- 블랙 보드, 행동 트리(BT) : NPC 캐릭터의 복잡한 AI 동작을 구현하고자 할 때.
- 유한 상태 머신 : 상태 패턴은 객체의 상태 종속적인 동작 캡슐화, 유한 상태 머신은 트리거 기반으로 상태간 전환에 더 깊이 관여
- 메멘토 : 상태 패턴과 유사하나 이전 상태로 돌아가는 기능을 제공

## 3. 이벤트 버스 패턴 : 게임 이벤트

- 이벤트 버스는 객체가 구독하거나 게시할 수 있는 특정한 전역 이벤트의 목록을 관리하는 중앙 허브이다.
- 이벤트 관리와 관련된 가장 간단한 패턴으로, 한 줄의 코드로 객체에 구독자 혹은 게시자의 역할을 할당한다.
- 객체(게시자)가 이벤트를 발생하게 되면 다른 객체(구독자)가 받을 수 있는 신호를 보내는 것이다.
- 오브젝트는 이벤트 시스템에서 이벤트를 브로드캐스트한다. 구독자만이 알림을 받는 것이다.
- 발행/구독 시스템이라고 부르는 것이 더 명확할 수 있으며, 키워드가 버스이다.
- 즉, 옵저버 패턴은 구독자와 게시자가 서로를 인식하며 의존성이 생기는 반면, 이벤트 버스 패턴은 누가 뭘 하든 관심은 없고 어떤 객체에 무슨 일이 생겼을 때 그걸 구독하고 있는 모든 객체들에게 브로드캐스트하는 것이다. 가운데에 이벤트 허브인 이벤트 버스 중재자가 있고 없고가 가장 큰 차이이다.
    - 예를 들어 옵저버 패턴은 특정 버튼과 특정 메서드가 완전히 결합되어있을 때 사용한다.
    - 그러나 이벤트 버스 패턴은 플레이어가 죽었을 때, 게임 전체에 그걸 알리며, 이 플레이어 사망이 필요한 모든 객체들이 익명적으로 구독하고 모두가 그걸 받는다.
- 전역적이고 빠르게 구현할 땐 이벤트 버스 패턴, 지역적인 이벤트 통신은 옵저버 패턴이다.
- 이벤트 버스 패턴에는 세 가지 주요 구성이 있다.
    - 게시자(Publisher) : 이벤트 버스에서 선언한 특정 종류 이벤트를 구독자에게 게시
    - 이벤트 버스 : 구독자와 게시자 사이의 이벤트 전송 조정
    - 구독자(Subscriber) : 이벤트 버스를 통해 특정 이벤트의 구독자로 자신을 등록

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 분리 | 오브젝트들이 직접 서로를 참조하는게 아닌, 이벤트로 통신 |
| 단순성 | 이벤트의 구독과 게시 매커니즘을 추상화하여 단순성 제공 |

| 단점 | 단점 설명 |
| --- | --- |
| 성능 | 이벤트 시스템 내부엔 오브젝트 간 메시지를 관리하는 저수준 메커니즘이 있어 비용 발생 |
| 전역 | static을 사용해 이벤트 버스를 구현하면 전역성이 넓어져 편하지만, 관리 테스트 어려움 |

### 코드 논점

- 구현에 따라 다르지만, 지원하는 특정 이벤트 종류를 Enum 열거형으로 처리한다.
- Events 딕셔너리를 만들어 이벤트 종류와 구독자 간 관계 목록을 구현한다.
    - private 접근 지정자 및 readonly로 유지하여 다른 오브젝트가 덮어쓰지 못하게 한다.
- 구독, 구독 취소, 게시 메서드를 구현한다.
    - 구독 메서드의 파라미터는 2개로, 하나는 이벤트 종류이며 하나는 콜백 함수이다.
    - UnityAction이 델리게이트 타입이므로 인자로 메서드를 전달할 수 있다.
    - 구독 취소 메서드는 특정 이벤트를 구독하는 오브젝트를 삭제한다.
- 예를 들어 타이머의 경우, 타이머 코루틴을 만들고 그걸 시작하는 StartTimer() 메서드를 private로 만든다. 이후 이걸 이벤트 버스에서 시작 이벤트 Enum에 이 메서드를 구독하면, 이 이벤트가 발생했을 때 콜백으로 해당 코루틴이 실행될 것이다.

### 대안

- 옵저버 패턴 : 오브젝트(서브젝트)가 오브젝트(옵저버) 목록을 유지 및 관리하고, 내부 상태 변경을 알리는 패턴으로, 엔티티 그룹 간의 일대다 관계 설정에 좋다.
- 이벤트 큐 : 게시자가 생성한 이벤트를 큐에 저장하고, 편한 시간에 구독자에게 전달한다.
- Scriptable Object : 유니티에서는 스크립터블 오브젝트로 이벤트 시스템을 만들 수 있다.

## 4. 커맨드 패턴 : 리플레이

- 플레이어 요청을 객체로 캡슐화해서, 요청에 대한 처리를 나중에 하거나 기록, 취소, 재실행할 수 있게 하는 패턴이다.
- 입력을 올바른 순서와 타이밍에 맞게 재생할 수 있게 된다.
- 원래의 방식엔 특정 키를 입력하면 컨트롤러의 특정 행동을 하게끔 하면 되지만, 커맨드 패턴은 플레이어가 특정 키를 누를 때 어떤 작업을 해야 하는지 인풋 핸들러가 알지 못해도 된다.
    - 올바른 명령이 실행되도록 커맨드 패턴 메커니즘이 처리할 것이다.
- 커맨드 패턴에 사용되는 기본 클래스는 아래와 같다.
    - 호출자(Invoker) : 명령을 실행하는 방법을 알고, 실행한 명령을 즐겨찾기할 수도 있는 객체
    - 수신자(Receiver) : 명령을 받아서 수행할 수 있는 종류의 객체
    - 커맨드베이스 : 개별 ConcreteCommand가 무조건 상속해야 하는 추상 클래스로, Execute() 메서드 노출
- 실행 취소, 매크로, AI의 자동화 등이 필요할 때 커맨드 패턴을 사용한다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 분리 | 실행 방법을 아는 객체에게서 작업 호출 객체를 분리할 수 있음 |
| 시퀀싱 | 되돌리기 / 다시 하기 / 매크로 등 구현을 허용하고, 입력을 큐에 쉽게 넣는다 |

| 단점 | 단점 설명 |
| --- | --- |
| 복잡성 | 각 명령이 그 자체로 클래스이기에 수많은 클래스가 필요하다 |

### 코드 논점

- Execute() 추상 메서드를 지닌 추상 클래스 Command를 반드시 만들어야 한다.
- 각 커맨드들이 모두 커맨드를 상속받고, Execute() 메서드 안에서 컨트롤러의 실행해야 하는 기능을 실행시킨다.
- Invoker는 세심한 회계 담당자라, 장부에서 실행된 명령을 추적한다. C#의 키/값 구조의 정렬된 컬렉션인 SortedList 자료형으로 표현한다. 이 배열은 특정 명령이 실행될 때를 계속 추적한다.
    - 타임스탬프도 함께 기록한다.

## 5. 오브젝트 풀 패턴 : 최적화

- 자주 사용되는 오브젝트를 미리 오브젝트 풀에 예약해두고, 새로 생성하거나 파괴하는 일을 최소화하며 객체를 재사용하는 패턴이다.
- 유니티 버전 2021부터 오브젝트 풀링이 API에 통합되어 있어 직접 패턴을 구현하지 않아도 된다.
- 클라이언트가 오브젝트가 필요할 때 오브젝트 풀에 오브젝트를 요청하고, 오브젝트 풀은 예약된 오브젝트를 건네주거나 텅 비었다면 그제서야 새로 오브젝트를 생성해 준다.

```csharp
using UnityEngine.Pool;

ObjectPool<T> // 클래스
IObjectPool<T> // 인터페이스
```

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 예측할 수 있는 메모리 사용 | 특정한 종류의 인스턴스가 특정한 양만큼 유지하도록 예측 가능한 방식으로 메모리 할당 |
| 성능 향상 | 메모리에서 객체를 매번 초기화해도 되지 않아 로딩 비용이 필요 없음 |

| 단점 | 단점 설명 |
| --- | --- |
| 이미 관리되는 메모리에 대한 레이어링 | C#처럼 최신 프로그래밍 언어는 이미 메모리 할당을 최적으로 관리하기에 오브젝트 풀 패턴이 불필요하다고 말하기도 한다. 이는 일부는 사실이지만 때론 거짓이다. |
| 예측 불가능한 객체 상태 | 잘못 처리하면 객체가 초기상태가 아닌 현재상태로 풀에 돌아온다. 상태 초기화가 필수 |

### 코드 논점

- 어렵지 않지만 객체에 자신의 상태를 초기화하는 메서드는 넣어두는 것이 좋다.
- 또한 너무 오랫동안 사용되지 않는 객체엔 스스로 풀로 돌아가야 하므로 자기 파괴 메서드가 필요하기도 하다.
- 오브젝트 풀 클래스에선 풀의 맥스 사이즈나 스택의 기본 캐퍼시티를 지정한다.
- 오브젝트 풀 클래스엔 인스턴스 초기화 및 생성, 잠시 비활성화, 활성화, 풀에 더 이상 공간이 없을 때 호출하는 메모리 확보용 파괴 메서드가 존재한다.

### 대안

- 프로토타입 패턴은 오브젝트 풀 패턴과 비슷하다. 프로토타입은 복제 메커니즘을 사용하는데, 새로운 객체를 생성할 때 비용이 들지 않는다. 새 객체를 초기화하는 대신 프로토타입이라는 참조 객체에서 얕은 복사를 진행한다.

## 6. 옵저버 패턴 : 컴포넌트 분리

- 옵저버 패턴은 한 객체가 주체 역할, 다른 객체가 관찰자 역할을 맡는 객체 간 일대다 관계를 설정하는 것이 핵심 목표이다.
- 주체 역할을 맡은 객체가 내부에서 변경되었을 때 관찰자에게 알려야 한다.
- 옵저버 패턴은 이벤트 버스 패턴과 다르게 주체와 관찰자가 서로를 알고 있어 가볍게 결합된다.
- 주체와 옵저버 모두 인터페이스를 가지지만, 주체 인터페이스가 구현에 더 중요하다.
    - AttachObserver() : 알림받을 관찰자 목록에 객체 추가
    - DetachObserver() : 관찰자 목록에서 관찰자 제거
    - NotifyObserver() : 주체의 관찰자 목록에 추가된 모든 객체에게 알림 발송
- 플레이어를 따라다니는 카메라나 HUD는 플레이어에게 강한 종속성을 가지고, 플레이어의 상태에 따라 자신 또한 메서드를 실행해야 하기에 옵저버 패턴에 적합하다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 역동성 | 주체에 필요한 만큼 객체를 관찰자로 추가하고 런타임에 동적으로 제거 가능 |
| 일대다 | 일대다 관계가 있는 객체 간 이벤트 처리 시스템의 구현 문제를 우아하게 해결 |

| 단점 | 단점 설명 |
| --- | --- |
| 무질서 | 관찰자가 알림받는 순서를 보장하지 않아 종속성을 가지는 옵저버 객체가 충돌 가능 |
| 누수 | 주체는 관찰자에 대한 강한 참조를 가져 메모리 누수 발생 가능 |

### 코드 논점

- 추상 클래스 Subject 클래스를 만들고, Attach, Detach, NotifyObservers 등의 메서드를 정의한다.
- 추상 클래스 Observer 클래스를 만들고, Notify 메서드를 오버라이딩하도록 가상으로 만든다.

### 대안

- 기본 C# 이벤트 시스템도 좋다. 옵저버 패턴보다 구체적이라는 점이 이벤트 시스템의 장점 중 하나이다. 주체에서 일반적인 알림을 받는 대신 다른 객체가 내보내는 특정 이벤트를 수신할 수 있다.

## 7. 방문자 패턴 : 파워업

- 외부에서 객체에 기능을 추가할 때, 객체의 내부 구조를 건드리지 않고 추가하는 디자인 패턴이다.
- 아이템이나 스킬처럼 기능을 적용하는 쪽이 캐릭터를 방문해서, 캐릭터의 속성을 건드리는 것이다.
- 캐릭터 객체는 방문자를 받아들이기만 하고, 뭘 하는지는 방문자쪽에 맡긴다.
    - IVisitor는 방문자가 되고자 하는 클래스가 구현해야 할 인터페이스이다.
    - IVisitable은 방문이 가능한 클래스가 구현해야 하는 인터페이스이다.
    - 방문자 객체가 방문하는 진입점을 제공하는 Accept() 메서드가 필요하다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 개방/폐쇄 | 직접 수정하지 않고도 다른 클래스의 오브젝트와 함께 작동하는 새로운 동작 추가 가능 |
| 단일 책임 | 데이터를 보유하는 객체와 또 다른 방문자 객체는 특정 행동을 도입하는 책임을 지님 |

| 단점 | 단점 설명 |
| --- | --- |
| 접근성 | 방문자는 방문하는 요소의 특정 개인 필드 및 메서드에 필요한 접근이 적을 수 있음 |
| 복잡성 | 싱글턴, 상태, 오브젝트 풀 같은 간단한 패턴보다 훨씬 복잡함 |

### 코드 논점

- 방문자 인터페이스를 만들어 Visit() 메서드를 작성하고, 방문 가능한 수용 객체의 인터페이스를 만들어 Accept() 메서드를 만든다.
- 파워업 클래스는 스크립터블 오브젝트임과 동시에 방문자 인터페이스를 적용한다.
    - 이렇게 되면 누구든 코드를 작성하지 않아도 새로운 파워업을 작성 및 구성할 수 있게 된다.

## 8. 전략 패턴 : 몬스터

- 전략 패턴이란 어떤 행동(전략)을 객체로 캡슐화해서, 그걸 교체할 수 있도록 설계하는 패턴이다.
    - 콘텍스트는 다양하고 구체적인 전략 클래스를 사용하며, 전략 인터페이스로 상호작용한다.
    - 전략 인터페이스는 모든 전략 클래스에서 사용하며 Execute() 메서드를 둔다.
    - 전략은 구체적인 전략 클래스이며, 콘텍스트 객체에 적용할 수 있는 알고리즘 캡슐이다.
- 예를 들어 탄막 슈팅 게임의 보스를 구현할 때 매우 적합하다.
    - 외부 요인 (플레이어 위치, 입력 등) 에 상관 없이 자기각 결정한 전략 (탄막 패턴)만 수행
    - 패턴 캡슐화 후 무작위 선택, 이전 패턴 제외, 특정 체력 이하 필살기 등 전략 선택 로직 분리 가능
    - 플레이어와 다르게 Idle, Attack 등의 상태가 별도로 존재하지 않아 행동이 상태에 따라 자동으로 바뀔 필요가 없어서 상태 패턴보다 전략 패턴이 더 잘 맞다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 캡슐화 | 개별 클래스에 알고리즘 변형을 캡슐화하도록 강제 |
| 런타임 | 런타임에 객체가 사용하는 알고리즘을 교환할 수 있음 |

| 단점 | 단점 설명 |
| --- | --- |
| 클라이언트 | 선택할 전략을 알기 위해 클라이언트가 구현한 알고리즘의 변형과 개별 전략 숙지 |
| 혼란 | 상태 패턴과 구조가 유사해 의도에 따라 무엇을 고를지 어렵고, 패턴 이해가 어려움 |
- 상태 패턴은 객체가 상태에 따라 행동을 바꾸는 것이고, 전략 패턴은 상태는 없으며 행동만 바뀐다.