## 1. 싱글턴 패턴 : 게임 매니저

- 싱글턴 패턴의 주요 목적은 유일성을 보장하는 것이다.
- 싱글턴 패턴으로 구현된 클래스는 어떻게 몇 번 호출되더라도 메모리에 오직 하나의 인스턴스만 존재해야 한다. 그 어떤 경쟁도 용납하지 않는다.
- 주로 보드게임 마스터와 같은 게임 매니저나, 백엔드 서비스와 통신, 전역 설정 초기화 등에 사용된다.
- 게임 매니저는 게임의 전체 수명 동안 단 하나의 인스턴스로서 살아있어야 한다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 전역 접근 가능 | 리소스나 서비스의 전역 접근점 지원 |
| 동시성 제어 | 공유 자원에 동시 접근을 제한할 수 있음 |

| 단점 | 단점 설명 |
| --- | --- |
| 유닛 테스트 | 과도한 싱글턴은 싱글턴 종속성을 만들어 단독으로 테스트하는 것이 불가능해짐 |
| 잘못된 습관 | 너무 쉬운 사용법에 전역 접근이 정교한 접근법 설계를 귀찮게 만들 수 있음 |

### 코드 논점

- 제네릭을 활용한 싱글턴 클래스를 만들고 이를 상속받는 것으로 쉽게 확장성을 확보할 수 있다.
- 정적(static) 변수나 함수 사용으로 전역적 접근점을 만들어서 사용한다.
- Awake() 함수의 경우 virtual로 지정하여 상속받은 파생 클래스에서 재정의할 수 있도록 한다.
    - Awake() 함수 내부에서 싱글턴 인스턴스가 있는지 확인하고, 없다면 자신이 싱글턴 인스턴스가 되며, 있다면 스스로를 제거한다.
    - DontDestroyOnLoad 메서드를 사용하여 씬 전환 시에도 오브젝트가 유지되도록 한다.

## 2. 상태 패턴 : 캐릭터 상태 관리

- 상태 패턴은 객체가 여러 상태를 가질 수 있을 때, 상태마다 클래스를 만들어 그 상태에 따라 행동하도록 구조화하는 디자인 패턴이다.
    - 만약 상태 패턴을 사용하지 않으면 if-else 문이나 switch 문으로 현재 상태를 필터링하고 행동하도록 해야 해서 복잡하고 유지보수가 힘들어진다.
- 객체의 유한 상태를 관리하고, 객체가 내부 상태를 기반으로 동작할 수 있도록 하는 것이다.
- 상태 패턴은 클래스를 간소화하고 유지관리가 쉽도록 만들어준다.
- 상태 패턴 구조에는 세 가지 핵심 요소가 있다.
    - Context 클래스 : 객체 내부 상태를 보유하고, 변경하도록 요청하는 인터페이스를 정의
    - IState 인터페이스 : 모든 상태 클래스의 인터페이스로, handle() 메서드 원형
    - 각 ConcreteState 클래스 : 여러 종류의 상태 클래스들로, public으로 IState의 handle 정의
- 객체의 상태를 업데이트할 땐 반드시 상태 패턴의 감독인 Context 클래스를 거쳐야 한다.
- 각 상태마다 Enter(), Update() 등이 존재해서, 현재 상태에 맞는 코드가 캡슐적으로 실행된다.
- 상태 전환은 Context의 Transition()으로만 가능해서 무질서하게 상태가 바뀌지 않는다.

### 코드 논점

- 정의한 유한 상태에서 예상할 수 있는 동작을 캡슐화한다는 목표로 상태 패턴을 구현해야 한다.
- Context 클래스에서 현재 상태를 카리키는 CurrentState를 public 프로퍼티로 만들어 모든 상태 변경을 인식하고, Transition() 함수를 호출해 상태를 전환하도록 구현할 수 있다.
- Transition() 함수는 오버로딩을 통해 파라미터가 없다면 단순히 Handle을, 파라미터로 IState의 상태를 삽입한다면 해당 상태로 현재 상태를 변환한 후 Handle을 할 수 있다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 캡슐화 | 상태가 변할 때 개체에 동적으로 할당할 수 있는 컴포넌트 집합이므로, 상태별 행동 구현 |
| 동시성 제어 | 긴 조건문이나 방대해진 클래스 수정 없이 새로운 상태를 얼마든 추가할 수 있음 |

| 단점 | 단점 설명 |
| --- | --- |
| 블렌딩 | 기본 형태의 상태 패턴은 애니메이션 블렌드를 제공하지 않음 |
| 전환 | 패턴 구현에서 상태 간 관계를 정의하지 않아 이를 구현하려면 더 많은 코드가 필요 |
- 두 단점은 유니티의 애니메이터를 통해 극복할 수 있다. 애니메이션 상태를 쉽게 정의하고 파라미터를 통해 쉽게 트리거를 작동하며 애니메이션 블렌딩을 지원한다.

### 대안

- 블랙 보드, 행동 트리(BT) : NPC 캐릭터의 복잡한 AI 동작을 구현하고자 할 때.
- 유한 상태 머신 : 상태 패턴은 객체의 상태 종속적인 동작 캡슐화, 유한 상태 머신은 트리거 기반으로 상태간 전환에 더 깊이 관여
- 메멘토 : 상태 패턴과 유사하나 이전 상태로 돌아가는 기능을 제공