# Chapter 05 : CPU 성능 향상 기법

## 빠른 CPU를 위한 설계 기법

### 클럭
- 클럭이란 컴퓨터의 부품들이 일정하게 움직일 수 있도록 하는 일종의 박자 역할이다.
- 만약 클럭 속도가 높아지면, CPU는 명령어 사이클을 더 빠르게 반복하여 속도가 향상될 것.
- **클럭 속도**는 헤르츠(Hz)단위로 측정한다. 이는 1초에 클럭이 몇 번 반복되는지를 나타낸다.
  - 우리가 요즘 쓰는 CPU엔 2.5GHz정도가 적혀있는데, 이는 1초에 클럭이 25억번 반복된다는 것을 나타낸다.
  - 그러나 클럭 속도는 절대 일정하지 않다. 기본 속도와 최대 속도 사이에서 고성능을 요할 때 클럭 속도가 높아질 수 있다.
  - 최대 클럭 속도를 강제로 더 끌어올리는 기법을 **오버클럭킹(Overclocking)**이라고 한다.
- 클럭 속도를 무작정 높이면 발열 문제가 생기기 때문에, 클럭 속도만으론 CPU의 성능을 올리기에 한계가 있다.

### 코어와 멀티코어
- CPU의 정의로 알고 있던 '명령어를 실행하는 부품'은 오늘날 **코어**라는 용어로 사용된다.
- 즉, 여러 개의 코어를 지닌 CPU는 '명령어를 실행하는 부품을 여러 개 포함하는 부품'으로 명칭의 범위가 확대되었다.
- 코어를 여러 개 포함하고 있는 CPU를 **멀티코어 CPU** 또는 **멀티코어 프로세서**라고 한다.
- 코어의 개수에 따라 싱글코어, 듀얼코어, 쿼드코어, 옥타코어 등의 명칭이 붙는다.
- 그러나 무작정 코어가 많다고 속도가 그 수만큼 빨라지진 않는다.

### 스레드와 멀티스레드
- **스레드(thread)**의 사전적 의미는 '실행 흐름의 단위'이다.
- 스레드에는 CPU에서 사용되는 **하드웨어적 스레드**가 있고, 프로그램에서 사용되는 **소프트웨어적 스레드**가 있다.
- **하드웨어적 스레드**
  - 하나의 코어가 동시에 처리하는 명령어 단위를 의미한다.
  - 여러 스레드를 지원하는 CPU는, 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있다.
  - 예를 들어 2코어 4스레드의 CPU는 한 번에 네 개의 명령어를 처리할 수 있다.
  - 즉, 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 **멀티스레드 프로세서** 또는 **멀티스레드 CPU**라고 한다.
  - 인텔의 멀티스레드 기술명으로 **하이퍼스레딩**이라는 용어도 존재한다.
- **소프트웨어적 스레드**
  - 하나의 프로그램에서 독립적으로 실행되는 단위를 의미한다.
  - 프로그래밍 언어나 운영체제를 학습할 때 접하는 스레드는 일반적으로 소프트웨어적으로 정의된 스레드를 의미한다.
  - 소프트웨어 하나가 동시에 각각의 기능이 수행될 수 있도록 하는 것.
- **멀티스레드 프로세서**
  - 멀티스레드 프로세서를 실제로 설계하는 것은 매우 복잡하지만, 핵심은 레지스터에 있다.
  - 하나의 코어로 여러 명령어를 동시에 처리하도록 하려면 PC, SP, MAR, MBR과 같은 필수 레지스터가 여러 개 있으면 된다.
  - 한 번에 하나의 명령어를 처리하는 CPU가 여러 개 있는 것처럼도 보여, 하드웨어 스레드를 **논리 프로세서**라고 부르기도 한다.

## 명령어 병렬 처리 기법

- 빠른 CPU엔 높은 클럭 속도와 멀티코어, 멀티스레드도 중요하지만, CPU가 쉬지 않게끔 하는것도 중요
- 명령어를 동시에 처리하여 CPU를 쉬지 않게 작동시키는 **명령어 병렬 처리 기법**
- 대표적인 명령어 병렬 처리 기법인 **명령어 파이프라인, 슈퍼스칼라, 비순차적 명령어 처리**

### 명령어 파이프라인
- 명령어 처리는 대개 인출, 해석, 실행, 결과 저장의 4단계로 이루어진다.
- 같은 단계가 겹치지 않는다면, CPU는 각 단계를 동시에 실행할 수 있다.
  - 명령어 인출에 쓰는 레지스터와, 명령어 실행에 쓰는 레지스터가 다르기 때문이다.
- 따라서 명령어 4개를 순차적으로 실행하는 것이 아닌, 서로 다른 단계를 동시에 실행하도록 겹쳐 실행하는 것이다.
- 명령어 파이프라인에 명령어들을 넣고 동시에 처리하는 기법을 **명령어 파이프라이닝**이라고 한다.
- 그러나 특정 상황에선 성능 향상에 실패하는 경우도 있는데, 이러한 경우를 **파이프라인 위험**이라고 한다.
- **데이터 위험**
  - 명령어 간 '데이터 의존성'에 의해 발생한다.
  - 어떤 명령어는 이전 명령어가 끝까지 실행되어야만 비로소 실행할 수 있는 경우가 있다.
  - 명령어2가 명령어1의 결괏값을 사용하는 방식이라면, 명령어2는 명령어1의 데이터에 의존적이다.
- **제어 위험**
  - 주로 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생한다.
  - 기본적으로 PC는 다음 실행할 명령어로 갱신되어나, 실행 흐름이 바뀌어 PC값에 변화가 생기면 명령어 파이프라인이 처리중이던 작업들이 모두 헛수고가 된다.
  - 특정 명령어를 전부 실행하고 보니, 먼 곳으로 분기해야하는 결과가 나올 때 발생하는 것이다.
  - 이를 위해 사용하는 기술 중 하나가 **분기 예측**이다.
- **구조적 위험**
  - 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU나 레지스터를 사용하려고 할 때 발생한다.
  - **자원 위험**이라고도 부른다.

### 슈퍼스칼라
- 오늘날의 CPU는 대부분 여러 개의 파이프라인을 이용한다.
- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 **슈퍼스칼라**라고 부른다.
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 **슈퍼스칼라 프로세서** 또는 **슈퍼스칼라 CPU**라고 부른다.
- 슈퍼스칼라 방식을 차용한 CPU는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 한다.

### 비순차적 명령어 처리
- 명령어들을 순차적으로 실행하지 않는 기법으로, OoOE로 줄여 부른다.
- 명령어의 합법적인 새치기라고도 할 수 있다.
- 데이터 의존성이 필요한 명령어가 순차적으로 대기중일 경우, 앞 명령어가 먼저 실행이 완료된 후에야 다음 명령어를 처리할 수 있기 때문에, 의존성이 없는 명령어를 앞으로 당겨와 먼저 실행해두는 것.

## CISC와 RISC
- 명령어 파이프라이닝을 실제로 적용하려면, 명령어가 파이프라이닝에 최적화되어 있어야 한다.
- 즉, CPU가 슈퍼스칼라 기법을 효과적으로 사용하려면 명령어가 파이프라이닝하기 쉽게 생겨야 한다.
- 파이프라이닝하기 쉬운 명령어를 알려면, CPU의 언어인 ISA와 그걸 토대로 설계된 CISC, RISC를 알아야 한다.

### 명령어 집합
- CPU의 종류는 무수히 많은데, CPU가 이해하는 명령어 역시 모두 똑같이 생기지 않다.
- 명령어의 생김새, 연산, 주소 지정 방식 등은 CPU마다 조금씩 차이가 있다.
- CPU가 이해할 수 있는 명령어들의 모음을 **명령어 집합** 또는 **명령어 집합 구조**, **ISA**라고 한다.
- 즉, CPU마다 ISA가 다를 수 있다.
  - 가령 인텔의 노트북은 x86 ISA를 이해하고, 애플의 아이폰은 ARM ISA를 이해하기 때문에, 인텔 CPU와 아이폰은 서로의 명령어를 이해할 수 없다.
- 동일한 소스 코드를 작성해도, ISA가 다른 컴퓨터에서 어셈블리어로 컴파일하면 다른 생김새의 어셈블리어로 변환된다.
- ISA가 같은 CPU끼리는 서로 명령어를 이해할 수 있지만 ISA가 다르면 서로 명령어를 이해할 수 없다는 점에서 CPU의 언어라고도 이해할 수 있다.
- ISA의 생김새에 따라 제어장치가 명령어를 해석하는 방식, 레지스터의 종류와 개수, 하드웨어나 메모리 관리 방법 등 다양한 것들이 달라진다.
- ISA는 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이기도 한 것이다.

### CISC
- Complex Instruction Set Computer의 약자로, '복잡한 명령어 집합을 활용하는 컴퓨터'를 의미한다.
- 여기서 Computer는 CPU 설계 방식을 의미하며, x86-64 역시 대표적인 CISC 기반의 ISA이다.
- CISC는 다양하고 강력한 기능의 명령어 집합을 사용하며, 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용한다.
- 이런 장점으로 CISC는 메모리를 최대한 아껴야 하는 옛 시절에 인기가 높았다.
- 그러나 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하여 크기와 실행 시간이 일정하지 않는 치명적인 단점이 존재했다.
- 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 하기도 했다.
- 명령어 파이프라인은 가급적 명령어의 각 단계에 소요되는 시간이 일정해야 잘 돌아가는데, 위 단점때문에 CISC는 명령어 파이프라이닝에 효율적이지 못한다.
- 또한 진짜 복잡한 명령어들은 사용 빈도가 낮고, 실제로는 자주 사용되는 명령어만 쓰이기도 한다.

