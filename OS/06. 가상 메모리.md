# Chapter 14 : 가상 메모리

## 연속 메모리 할당

- 지금까지는 메모리 내에 프로세스가 연속적으로 배치되는 상황을 가정했고, 이 방식은 **연속 메모리 할당** 방식이라고 한다.

### 스와핑

- 메모리에 적재된 프로세스들 중에서는 현재 실행되지 않는 프로세스가 있을 수 있다.
  - 입출력 작업으로 대기 상태가 되었거나, 오랫동안 사용되지 않은 프로세스들.
- 이런 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그 빈 자리를 다른 프로세스로 채워 실행하는 방식을 **스와핑**이라고 한다.
- 이 때 프로세스들이 쫒겨나는 보조기억장치 일부 영역을 **스왑 영역**이라고 한다.
- 현재 실행되지 않은 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것을 **스왑 아웃**, 반대로 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것을 **스왑 인**이라고 한다.
- 스왑 아웃된 프로세스가 다시 스왑 인 될때는 스왑 아웃되기 전의 물리 주소와 다른 주소에 적재될 수 있다.
- 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.
  - 넘치는 부분을 스와핑하며 실행할 수 있기 때문이다.
- 유닉스, 리눅스, 맥에선 DOS 명령어를 통해 스왑 영역의 크기를 확인하고, 크기를 설정할 수 있다.

### 메모리 할당

- 프로세스는 메모리 내의 빈 공간에 적재되는데, 빈 공간이 여러 개 있을 경우 할당 방식이 다르다.
- 여기엔 대표적으로 최초 적합, 최적 적합, 최악 적합 세 가지 방식이 존재한다.
- **최초 적합**
  - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 **공간이 발견되면** 그 공간에 프로세스를 배치하는 방식이다.
  - 검색을 최소화하고 결과적으로 빠른 할당이 가능하다.
  - 빈 공간이 비교적 큰 공간이더라도 일단 적재하게 된다.
- **최적 적합**
  - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 **작은** 공간에 프로세스를 배치하는 방식이다.
  - 가장 크기에 알맞는 메모리에 적재 가능하지만, 메모리를 모두 검색하게 된다.
- **최악 적합**
  - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 **큰** 공간에 프로세스를 배치하는 방식이다.

### 외부 단편화

- 프로세스를 메모리에 연속으로 배치하는 것은 언뜻 당연해보이나, 사실 이는 메모리를 효율적으로 사용하는 방법은 아니다.
- 왜냐하면, 연속 메모리 할당은 **외부 단편화**(External Fragmentation)라는 문제를 내포하고 있기 때문이다.
- 만약 프로세스 크기가 순서대로 크고 - 작고 - 크고 - 작은 것들이 연속으로 할당되었다고 치자.
  - 이후 작은 프로세스 두 개가 실행이 끝나 메모리를 떠나면, 작은 공간이 두 개 비게 된다.
  - 그 때 남아있는 총 공간이 50MB라고 해도, 50MB짜리 프로세스를 적재할 수 없게 된다.
  - 빈 공간이 큰 프로세스를 적재하기 어려운 상황을 초래하고, 메모리 낭비로 이어지는 현상을 외부 단편화라고 한다.
  - 스와핑을 통해 프로세스가 스왑 아웃되고, 더 작은 프로세스가 스왑 인 될때도 외부 단편화가 발생한다.
- 실제로는 외부 단편화가 많이 일어나면 낭비되는 공간이 더더욱 커진다.
- 외부 단편화를  해결할 수 있는 대표적인 방안으로 메모리를 **압축**하는 방법이 있다.
- 이는 **메모리 조각 모음**이라고도 부른다.
- 여기저기 흩어진 빈 공간들을 하나로 모으는 방식으로, 프로세스를 적당히 재배치해 큰 빈 공간을 만드는 방법이다.
- 압축 방식엔 여러 단점이 있는데, 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지하고 내용을 옮기며 오버헤드를 야기한다.
- 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화할 수 있는지 명확한 방법을 결정하기 어렵다.
- 오늘날 외부 단편화를 없애는 또 다른 해결 방안이 등장했는데, 이가 가상 메모리 기법, 그 중에서도 페이징 기법이다.

## 페이징을 통한 가상 메모리 관리

- 메모리에 프로세스를 연속으로 할당하는 방식은 두 가지 단점이 있다.
  1. 외부 단편화가 야기된다.
  2. 물리 메모리보다 더 크기가 큰 프로세스를 실행할 수 없다.
- **가상 메모리**(Virtual Memory)는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.
- 이를 가능케 하는 가상 메모리 관리 기법은 크게 **페이징**과 **세그멘테이션**이 있다.
- 현대 대부분의 운영체제가 페이징 기법을 다루며, 이는 외부 단편화도 해결한다.

### 페이징이란

- 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 외부 단편화는 발생하지 않는다. 이 기법이 **페이징**(Paging)이다.
- 페이징은 프로세스의 논리 주소 공간을 **페이지**라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임**이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.
- 페이징에서 스와핑을 사용할 수 있는데, 이 경우 프로세스 전체가 스왑 아웃/스왑 인 되는 것이 아닌 **페이지 단위**로 스왑 아웃/스왑 인 된다.
- 페이징 시스템에서의 스왑 아웃을 **페이지 아웃**, 스왑 인은 **페이지 인**이라고도 한다.
- 이는 다르게 말하면 프로세스를 실행하기 위해 그 전체가 메모리에 적재될 필요는 없다는 것이다.
- 이 방식을 통해 물리 메모리보다 더 큰 프로세스를 실행할 수 있게 된다.

### 페이지 테이블

- 문제가 있다면, 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에선 이를 순차적으로 실행할 수가 없다.
- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 모두 알고 있기 어렵기 때문이다.
- 즉, CPU 입장에선 '다음 실행할 명령어 위치'를 찾기가 어려워진다.
- 이를 해결하기 위해 페이징 시스템은, 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소만큼은 연속적으로 배치되도록 **페이지 테이블**을 이용한다.
- 페이지 테이블은 페이지 번호와 프레임 번호를 짝지어주는 이정표이다.
- CPU가 페이지 테이블에 적힌 페이지 번호만 보아도, 해당 페이지가 적재된 프레임을 찾을 수 있게 된다.
- 물리 주소에 프로세스가 어지럽게 정리되어 있어도, 페이지 테이블에서의 논리 주소는 페이지 번호 0번부터 쭉 정리되어 있다.
- 페이징은 외부 단편화 문제를 해결할 수 있지만, **내부 단편화** 문제를 야기할 수 있다.
  - 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아니다.
  - 가령 페이지 단위가 10KB인데, 프로세스 크기가 108KB라면 2KB 만큼의 크기가 남는다. 이런 메모리 낭비를 내부 단편화라고 한다.
  - 내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생하기 때문에, 페이지 크기를 작게 하면 그만큼 낭비되는 크기는 작아지겠지만 페이지 테이블의 크기도 커져 페이지 테이블이 차지하는 공간이 낭비된다.
  - 기본적으로 설정된 페이지보다 큰 페이지를 대형 페이지라고 한다.
- 프로세스마다 각자의 프로세스 테이블을 하나씩 가지고 있고, 각 프로세스의 페이지 테이블은 메모리에 적재되어 있다.
- CPU 내의 **페이지 테이블 베이스 레지스터**(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리키고 있다.
  - 이러한 각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록된다. 또한 프로세스의 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변경된다.
- 그러나 이렇게 페이지 테이블을 두면, 메모리 접근 시간이 두 배로 늘어나게 된다.
  - 페이지 테이블에 접근하는 것, 프레임에 접근하는 것으로 두 번 접근이 필요하기 때문이다.
- 이와 같은 문제를 해결하기 위해 CPU 곁(보통 MMU 내)에 **TLB**(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 둔다.
- TLB는 페이지 테이블의 캐시여서 테이블의 일부 내용을 저장하고, 참조 지역성에 의거해 주로 최근에 사용된 페이지 위주로 가져와 저장한다.
- CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우, 이를 **TLB 히트**라고 한다.
- 이 경우 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요 없이 바로 캐시를 보게
-  된다.
- 만약 페이지 번호가 TLB에 없다면 메모리에 접근할 수밖에 없고, 이를 **TLB 미스**라고 한다.

### 페이징에서의 주소 변환

- 하나의 페이지나 프레임은 여러 주소를 포괄하고 있다. 그렇기에 특정 주소에 접근하려면 아래와 같은 두 가지 정보가 필요하다.
  - 어떤 페이지 혹은 프레임에 접근하고 싶은지
  - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지
- 그렇기에 페이징 시스템에서는 모든 논리 주소가 기본적으로 **페이지 번호**와 **변위**로 이루어져 있다.
- CPU가 32비트 주소를 내보냈다면 페이지 번호는 N비트, 변위는 32-N비트이다.
- 페이지 번호는 말 그대로 접근하고자 하는 페이지 번호이다. 페이지 번호를 알면 페이지 테이블을 통해 그 페이지가 어떤 프레임에 할당되어있는지를 알 수 있다.
- 변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼마나 떨어져있는지를 알기 위한 정보이다.
- 즉 논리 주소는 <페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환된다.