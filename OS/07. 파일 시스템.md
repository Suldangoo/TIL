# Chapter 15 : 파일 시스템

## 파일과 디렉터리

- 우리가 당연하게 사용하는 **파일**과 **디렉터리**는 모두 운영체제 내부 파일 시스템이 관리하는 존재이다.
- 파일과 디렉터리는 모두 보조기억장치에 있는 데이터 덩어리인데, 이를 어떻게 파일과 디렉터리로서 관리하는지가 **파일 시스템**의 핵심이다.

### 파일

- 우리가 일상적으로 컴퓨터를 이용할 땐 파일 단위로 이용한다.
- **파일**(File)이란 하드 디스크나 SSD와 같은 보조기억장치에 저장된 관련 정보의 집합을 의미한다.
- 의미 있고 관련 있는 정보를 모은 논리적 단위를 의미한다.
- 모든 파일에는 이름과 파일을 실행하기 위한 정보, 그리고 파일 관련 부가 정보가 있다. 이 부가 정보를 **속성** 또는 **메타데이터**라고 부른다.
- 파일을 우클릭하여 속성을 살펴보면, 파일 형식이나 위치, 크기 등 다양한 정보가 나오는데, 이러한 정보가 **파일 속성**이다.
- **파일 속성과 유형**
  - 운영체제마다 유지하는 파일 속성은 조금씩 다르지만 대표적인 속성은 다음과 같다.
    - 유형, 크기, 보호, 생성 날짜, 마지막 접근/수정 날짜, 생성자, 소유자, 위치
  - **파일 유형**은 운영체제가 인식하는 파일 종류를 나타낸다.
  - 같은 이름의 파일이어도 텍스트, 실행, 음악 파일 등 유형이 다르면 실행 양상이 달라진다.
  - 파일 유형을 알리기 위해 가장 흔히 사용하는 방식은 이름 뒤에 붙는 확장자(Extension)을 이용하는 것이다. 파일 종류를 알려주는 힌트와도 같다.
- **파일 연산을 위한 시스템 호출**
  - 파일을 다루는 모든 작업은 운영체제에 의해 이뤄진다. 어떤 응용 프로그램도 파일을 임의로 조작할 수 없으며, 파일을 다루려면 운영체제에 부탁해야 한다.
  - 이를 위해 운영체제는 다음과 같은 파일 연산을 위한 시스템 호출을 제공한다.
    - 파일 생성, 삭제, 열기, 닫기, 읽기, 쓰기

### 디렉터리

- 파일들을 일목요연하게 관리하기 위해 **디렉터리**(Directory)를 이용한다.
- 윈도우에서는 디렉터리를 **폴더**(Folder)라고 부른다.
- 옛날 운영체제에는 하나의 디렉터리만 존재했고, 모든 파이링 하나의 디렉터리 안에 전부 담겨있었다. 이런 구조를 **1단계 디렉터리**라고 부른다.
- 하지만 실제로 이런 컴퓨터는 이제 거의 없고, 용량이 커지다 보니 저장할 수 있는 파일이 많아져 1단계 디렉터리로는 파일 관리가 어려워졌다.
- 때문에 여러 계층을 가진 **트리 구조 디렉터리**가 생겨났다.
- 트리 구조 디렉터리는 최상위 디렉터리인 **루트 디렉터리**(/)가 있고, 그 아래 여러 서브 디렉터리(자식 디렉터리)가 있다. 서브 디렉터리는 또 다른 서브 디렉터리를 가질 수 있다.
- 이렇게 디렉터리가 계층적으로 있다 보니 생긴 개념이 **경로**(Path)이다.
  - 경로는 디렉터리를 이용해 파일 위치, 파일 이름을 특정짓는 정보이다.
- **절대 경로와 상대 경로**
  - 같은 디렉터리에는 동일한 이름의 파일이 존재할 수 없지만, 서로 다른 디렉터리에는 동일한 이름의 파일이 존재할 수 있다.
  - 루트 디렉터리부터 파일까지 경로가 다르기 때문에 동일한 이름임에도 공존할 수 있는 것이다.
  - 모든 파일은 루트 디렉터리부터 자기 자신까지 이르는 고유한 경로를 가지고 있고, 이를 **절대 경로**(Absolute Path)라고 한다.
  - 경로를 나타내는 또 다른 대중적 방식으로는 **상대 경로**(Relative Path)가 있다.
  - 상대 경로는 현재 디렉터리부터 시작하는 경로이다.
- **디렉터리 연산을 위한 시스템 호출**
  - 운영체제가 파일 연산을 위한 시스템 호출을 제공하듯이, 디렉터리 연산을 위한 시스템 호출 또한 제공한다.
    - 디렉터리 생성, 삭제, 열기, 닫기, 읽기
- **디렉터리 엔트리**
  - 파일과 디렉터리는 엄연히 다른 별개의 존재라고 생각할 수 있으나, 사실 많은 운영체제는 디렉터리를 그저 특별한 형태의 파일로 간주한다.
  - 즉, 디렉터리도 파일이다. 다만 포함한 정보가 조금 특별할 뿐이다.
  - 파일은 내부에 해당 파일과 관련된 정보를 담고 있다면, 디렉터리는 내부에 해당 디렉터리에 담겨 있는 대상과 관련된 정보를 담고 있다.
  - 보통 이 정보는 테이블(표) 형태로 구성되어있다.
  - 여러 파일 시스템마다 테이블 각각의 엔트리(행)의 구성이 다른데, 거의 모든 파일 시스템이 공통적으로 포함하는 정보는 디렉터리에 포함된 **대상의 이름**과, 그 대상이 보조기억장치 내에 **저장된 위치를 유추할 수 있는 정보**가 담긴다는 것이다.
- 테이블의 엔트리엔 ..(상위 디렉터리)와 .(현재 디렉터리)와 해당 디렉터리 내부에 있는 파일 혹은 디렉터리의 정보가 담겨있다.
- 참고로 루트 디렉터리는 부모 디렉터리가 없어서, 루트 디렉터리의 ..은 자기 자신을 의미한다.

## 파일 시스템

- **파일 시스템**은 파일과 디렉터리를 보조기억장치에 일목요연하게 저장하고 접근할 수 있게 하는 운영체제 내부 프로그램이다.

### 파티셔닝과 포매팅

- 막 공장에서 생성된 하드 디스크나 SSD는 곧바로 사용할 수 없는데, **파티션**을 나누는 작업인 **파티셔닝**과 **포맷** 작업(**포매팅**)을 거쳐야 하기 때문이다.
- **파티셔닝**은 저장 장치의 논리적인 영역을 구획하는 작업을 의미한다.
- 저장 장치에 칸막이들을 세워 정리하기 쉽게끔 구역을 나누는 것이다.
- 이렇게 나누어진 영역 하나하나를 **파티션**(Partition)이라고 한다.
- 포맷 작업, 즉 **포매팅**은 저장 장치를 완전히 삭제하는 것으로 사람들이 알고 있지만, 사실 이는 정확한 표현이 아니다.
- 포매팅이란 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할지 설정하고, 새로운 데이터를 쓸 준비를 하는 작업을 의미한다.
  - 포매팅의 종류를 엄밀히 나누자면 **저수준 포매팅**과 **논리적 포매팅**이 있다. 저수준 포매팅은 저장 장치를 생성하는 공장에서 수행되는 물리적 포매팅이고, 후자는 파일 시스템을 생성하는 포매팅이다.
- 즉, 포매팅을 하면 그 때 파일 시스템이 결정된다.
- 파일 시스템엔 여러 종류가 있고, 파티션마다 다른 파일 시스템을 설정할 수 있다.
- 파티셔닝과 포매팅을 완료하면 파일과 디렉터리를 생성할 수 있다.

### 파일 할당 방법

- 운영체제는 파일과 디렉터리를 **블록**(Block)단위로 읽고 쓴다.
- 하나의 파일이 저장될 때는 하나 이상의 블록에 걸쳐 저장된다.
- 하드 디스크의 가장 작은 저장 단위는 섹터이지만, 운영체제는 하나 이상의 섹터를 블록으로 묶어 사용한다.
- 파일을 보조기억장치에 할당하는 방법은 크게 두 가지로, 연속 할당과 불연속 할당이다. 그리고 불연속 할당에는 크게 연결 할당과 색인 할당이 있다.
- **연속 할당**
  - 연속 할당(Contiguous Allocation)은 가장 단순한 방식이다. 이름 그대로 보조기억장치 내에 연속적인 블록에 파일을 할당하는 방식이다.
  - 연속으로 할당된 파일에 접근할 땐 파일의 첫 번째 블록 주소와 블록 단위의 길이만 알면 된다.
  - 그렇다면 디렉터리 엔트리에 파일 이름과 첫 번째 블록 주소, 길이가 명시된다.
  - 그저 연속적으로 저장하기에 구현이 단순하다는 장점이 있지만, 외부 단편화를 야기한다는 치명적인 문제가 있다.
- **연결 할당**
  - 연속 할당의 문제를 해결할 수 있는 연결 할당(Linked Allocation)은 각 블록 일부에 다음 블록의 주소를 저장하여, 각 블록이 다음 블록을 가리키는 형태로 할당하는 방식이다.
  - 즉, 연결 리스트 형태로 파일들을 관리한다.
  - 불연속 할당의 일종이기에, 파일이 여러 블록에 흩어져 저장되어도 무방하다.
  - 한 블록마다 데이터와 함께 다음 블록의 주소를 가리키는데, 마지막 블록에서는 다음 블록이 없다는 특별한 표시자를 기록한다.
  - 이 또한 디렉터리 엔트리에 파일 이름과 첫 번째 블록 주소, 길이가 명시된다.
  - 연결 할당은 외부 단편화 문제를 해결하지만, 이 또한 단점이 있다.
    1. 반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 한다.
      - 파일의 중간 부분부터 접근하고 싶어도, 그럴 수 없으며 반드시 첫 번째 블록부터 접근해나가야 한다.
      - 즉, 파일 내 임의 위치에 접근하는 속도인 임의 접근(Random Access)속도가 매우 느리다.
    2. 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다.
      - 하나의 블록 안에 파일 데이터와 다음 블록 주소가 모두 있어서 고장이나 오류로 블록에 문제가 생기면, 그 블록 이후의 모든 블록들에 접근할 수 없게 된다.
      - 하드 디스크는 고장에 매우 예민한 장치라, 자칫 헤드가 플래터에 충돌해버리면 데이터를 손상시킬 수 있다.
  - 그래서 오늘날에는 위 내용을 그대로 구현하기보단 이를 조금 변형한 파일 시스템인 FAT 파일 시스템을 주로 사용한다.
- **색인 할당**
  - 색인 할당(Indexed Allocation)은 파일의 모든 블록 주소를 **색인 블록**(Index Block)이라는 하나의 블록에 전부 모아 관리하는 방식이다.
  - 색인 할당은 연결 할당과는 달리 파일 내 임의의 위치에 접근하기 쉽다.
  - 색인 블록을 알면 해당 파일 데이터에 접근할 수 있는데, 때문에 디렉터리 엔트리에 파일 이름과 더불어 **색인 블록 주소**를 명시한다.
  - 색인 할당을 기반으로 만든 파일 시스템이 유닉스 파일 시스템이다.

### 파일 시스템 알아보기

- USB 메모리, SD 카드 등의 저용량 저장 장치에서 주로 사용되는 **FAT 파일 시스템**과 유닉스 계열 운영체제에서 사용되는 **유닉스 파일 시스템**이 유명하다.
- **FAT 파일 시스템**
  - 연결 할당의 단점을 보완한 파일 시스템이 FAT 파일 시스템이다.
  - 앞서 설명한 연결 할당 방식의 근본적인 단점 중 하나가 블록 안에 다음 블록의 주소를 저장하는 점이다.
  - 각 블록에 포함된 다음 블록의 주소들을 한데 모아서 테이블 형태로 관리하면, 앞서 언급한 단점들을 대부분 해소할 수 있다. 이러한 테이블을 **파일 할당 테이블**(FAT; File Allocation Table)이하 **FAT**라고 부른다.
  - FAT 파일 시스템은 버전에 따라 뒤에 숫자가 붙어 FAT12, FAT16, FAT32가 있는데, 이 숫자는 블록을 표현하는 비트 수를 의미한다.
    - 참고로 윈도우에서는 블록이라는 용어 대신 **클러스터**라는 용어를 사용한다.
  - FAT 파일 시스템에서 FAT는 파티션의 앞부분에 만들어진다. 한 파티션을 FAT로 포맷하면 FAT 영역이 만들어지고, 거기에 FAT가 저장되며 뒤이어 루트 디렉터리가 저장되는 영역과 함께 서브 디렉터리와 파일들을 위한 영역이 만들어진다.
  - FAT는 우선 하드 디스크의 파티션 시작 부분에 있지만, 실행 도중 FAT가 메모리에 캐시될 수 있다.
  - FAT가 메모리에 있을 경우 기존 연결 할당보다 다음 블록을 찾는 속도가 매우 빨라져서 임의 접근에도 유리해진다.
  - FAT 파일 시스템의 디렉터리 엔트리에는 파일 이름과 파일의 첫 번째 블록 주소가 명시되는데, 더불어 여러 정보들이 들어있다.
    - 파일 이름, 확장자, 속성, 예약 영역, 생성 시간, 마지막 접근 / 수정 시간, 시작 블록, 파일 크기
- **유닉스 파일 시스템**
  - 유닉스 파일 시스템은 색인 할당 기반이다.
  - 색인 블록을 기반으로 파일의 데이터 블록들을 찾는 방식이며, 유닉스 파일 시스템에선 이 색인 블록을 **i-node**라고 부른다.
  - i-node에는 파일 속성 정보와 열다섯 개의 블록 주소가 저장될 수 있다.
  - FAT 파일 시스템은 파일 속성 정보가 디렉터리 엔트리에 적혀 있었는데, 여기선 i-node에 적혀있다.
  - 유닉스 파일 시스템은 파일마다 i-node가 있고, i-node마다 번호가 부여되어 있다.
  - 그리고 i-node들은 파티션 내 특정 영역에 모여 있다.
  - 단, i-node의 크기는 열다섯 개의 블록 주소를 저장할 수 있는 유한된 크기여서, 블록이 그 이상 큰 파일이 있을 경우 i-node 하나만으로 파일의 데이터 블록을 모두 가리킬 수 없다.
  - 이러한 문제를 다음과 같이 해결할 수 있다.
    1. 블록 주소 중 12개에는 직접 블록 주소를 저장한다.
      - i-node의 블록에 직접적으로 데이터가 저장된 블록 주소가 명시될 수 있고, 이는 **직접 블록**이라고 한다.
      - 열 두개의 직접 블록 주소만으로 파일 데이터 블록을 모두 가리킬 수 있다면 추가적인 작업이 필요 없다.
    2. 1번 내용으로 충분하지 않다면 13번째 주소에 단일 간접 블록 주소를 저장한다.
      - 13번째 블록 주소에 **단일 간접 블록** 주소를 저장하는데, 단일 간접 블록이란 파일 데이터가 저장된 블록이 아닌, 파일 데이터를 저장한 블록 주소가 저장된 블록을 의미한다.
      - 단일 간접 블록에서도 다음 데이터 여러개들을 가리키는 것이다.
    3. 2번 내용으로 충분하지 않다면 14번째 주소에 이중 간접 블록 주소를 저장한다.
      - 13개의 블록 주소로 파일의 모든 블록을 가리킬 수 없다면 i-node의 14번째 블록 주소에 **이중 간접 블록** 주소를 저장한다. 이중 간접 블록 주소는 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록을 의미한다.
      - 즉, 단일 간접 블록들의 주소를 저장하는 블록이다.
    4. 3번 내용으로 충분하지 않다면 15번째 주소에 삼중 간접 블록 주소를 저장한다.
      - 이걸로도 모자라다면 i-node의 마지막 열 다섯 번째 블록 주소에 **삼중 간접 블록** 주소를 저장한다. 삼중 간접 블록이란 이중 간접 블록 주소가 저장된 블록이다.
       - 삼중 간접 블록까지 이용하면 웬만한 크기의 파일은 모두 표현할 수 있다.
  - i-node만 알면 파일 속성뿐만 아니라 파일 크기가 크더라도 파일 데이터를 모두 가리킬 수 있다.
  - i-node가 파일의 모든 것을 담고 있다 해도 과언이 아니다.
  - 그래서 유닉스 파일 시스템의 디렉터리 엔트리엔 파일 이름과 함께 i-node 번호가 명시되어 있다.
  - 유닉스 파일 시스템은 루트 디렉터리의 i-node를 항상 기억하고 있다.
- 파일 시스템을 아우르는 개념은 방대하여 파일 시스템만을 다루는 전공서도 많다.
- 이 외에도 대표적으로 윈도우 운영체제에서 사용되는 **NT 파일 시스템**(**NTFS**), 리눅스 운영체제에서 사용되는 **ext 파일 시스템** 등이 있다.

### 저널링 파일 시스템

- 컴퓨터 이용 도중 갑자기 전원이 나가거나 치명적인 오류로 컴퓨터가 강제 종료되면(**시스템 크래시**), 파일 시스템이 훼손될 수 있다.
- 저널링 파일 시스템이 있기 전에는 이런 상황이 발생하면 부팅 직후 파일 시스템을 검사하고 복구하는 프로그램을 실행했다.
- 유닉스나 리눅스의 fsck이나, 윈도우의 scandisk가 이런 프로그램이다.
- 그러나 이는 파일 시스템 내의 모든 블록을 검사하는 터라 시간이 매우 오래 걸렸다.
- 그래서 등장한 것이 **저널링 기법**을 이용하는 **저널링 파일 시스템**이다.
- **저널링(Journaling) 기법**이란 작업 로그를 통해 시스템 크래시가 발생했을 때 빠르게 복구하기 위한 방법이다.
  1. 작업 직전 파티션의 로그 영역에 수행하는 작업(변경 사항)에 대한 로그를 남긴다.
  2. 로그를 남긴 후 작업을 수행한다.
  3. 작업이 끝났다면 로그를 삭제한다.
- 이 경우 파티션에 별도로 로그 영역이 존재한다.
- 만약 작업 도중 시스템 크래시가 발생하면, 파일 시스템 전체를 검사할 필요 없이 로그 영역에 남긴 로그만 검사해도 된다.
- 로그 영역을 읽어 크래시 당시 어떤 작업을 실행 중이었는지 알아내고, 해당 작업을 완료한다.

