## 1장 : 2D 게임에서의 UI

- 대부분의 2D 게임에서 UI는 굉장히 중요한 요소이다.
- UI는 최종적으로 촬영한 씬 위에 CG를 씌운 것과 유사하다.
- 소스에서 우클릭 - UI Toolkit을 활용하여 UI를 만들 수 있으나, 이건 최근에 만들어진 기술이기 때문에 UGUI라고 불리는 UI를 사용한다.
- UI를 아무거나 하나 만들게 되면 Canvas가 만들어지고, EventSystem이 만들어진다.
    - 무엇보다 UI가 캔버스의 하위 오브젝트로 들어가있음을 확인할 수 있다.
    - UI에서 Image를 만든 것을 Canvas 밖으로 빼면 보이지 않는다.
- UI는 기본적으로 모든 오브젝트에 쓰이던 Transform이 아닌 Rect Transform이 사용된다.
- EventSystem의 역할은, 사용자가 화면에 있는 버튼을 터치하거나 상호작용을 하면 게임 세계에 그 신호를 알리는 역할을 한다.
    - UI를 다 만들었는데 상호작용이 안된다면 EventSystem이 있는지 우선 확인해보아야 한다.
    - 그 다음엔 Canvas의 그래픽 레이캐스터 컴포넌트가 잘 있는지 확인한다.
    - 그 후 모든 UI 오브젝트에 Raycast Target이 체크되어있는지를 확인한다.
    - UI가 상호작용하는 원리는 가상의 레이저를 쏴서 충돌 처리를 하는 것인데, 그것을 레이캐스팅이라고 한다. 이 작업이 이루어져야 실제로 사용자와 프로그램이 상호작용할 수 있다.
- Game 레이아웃의 Game을 Simulator로 바꾸면 원하는 모바일 디바이스 형태로 해상도를 변경할 수 있다.
    - UI를 만들 때 가장 어려운 것은 모든 기종마다 보이는 비율이 다 다르다는 것이다.
- UGUI 중에선 주로 이미지, 텍스트, 버튼 3개를 자주 쓰게 된다.
    - 추후에 모서리와 꼭짓점이 동그란 이미지들이 있는데, 이를 9-slice를 하여 사이즈를 늘여도 어색하지 않게끔 모서리를 고정하는 작업을 해야 한다.
        - Spirte Editor에서 초록색 선을 조정하여 할 수 있다.
    - 그 중 텍스트는 TMP를 사용해야 한다. 이 과정에서 Text Mesh Pro를 인스톨해야 한다.
    - 기본 설정에서는 한글을 지원하지 않는다. 한글 폰트와 설정이 별도로 필요하다.
- 캔버스 하위에 버튼을 만들면 텍스트와 함께 버튼이 만들어진다.
    - 버튼 아래에서 클릭될 때나 기본 상태의 색을 지정할 수 있다.
    - OnClick() 안에 버튼이 클릭되었을 때의 일어날 이벤트를 할당할 수 있다.
- 하이어라키 상에서 더 밑에 있는 오브젝트가 위에 그려짐을 알 수 있다.
- 캔버스 하나를 끄게 되면 해당 캔버스 아래에 들어가있는 모든 오브젝트들이 보이지 않는다.
    - 그래서 보통 개발 단위로 캔버스 하나를 만든 뒤 프리팹으로 만들 수도 있다.
- 보통은 UI 그룹 하나를 묶었다면 그거에 해당하는 스크립트 하나를 생성하는 것이 국룰이다.
    - 초보자들이 자주 하는 실수 중 하나가 너무 많은 스크립트를 만드는 것이다.
    - 오브젝트당 하나씩 스크립트를 만들어버리면 호환이 굉장히 어렵고 유지보수가 어렵다.
- ClickMe라는 이름의 UI 매니저 스크립트를 만들었고, 그 스크립트에 public 함수를 하나 만들었다면 버튼의 OnClick에 해당 함수를 할당할 수 있다.
    - 물론 이런 툴에서의 모든 작업 역시 코드에서 전부 수행할 수 있다.
- 이렇게 OnClick()이라는 함수에 원하는 함수를 씌우는 것은, C#에서의 델리게이트. 즉 대리자 함수와 매우 유사한 개념이며, 실제로도 그런 방식으로 구련하였다.
```csharp
void Start()
{
    _clickButton.onClick.AddListener(OnClickButton);
}
```

- 보통 UI를 갱신하는 함수는 함수 하나에 통합하여 만든 뒤 원하는 타이밍에만 호출하면 된다.
- Raycast Target 체크를 굉장히 신경써야 한다. 상호작용하지 않을 이미지 UI는 모두 Raycast Target을 꺼주는 것이 좋다.
    - 화면을 터치했을 때 가장 먼저 충돌하는 레이캐스트가 상호작용을 이루게 된다.
    - 의도적으로 팝업 메뉴의 배경화면에 레이캐스트를 활성화하여 뒤에 있는 다른 오브젝트들이 상호작용되지 않도록 할 수 있다.
## 2장 : 스케일러와 앵커

- 앵커와 피벗은 화면상에서 UI가 고정되는 기준을 설정하는 방법이다.
- Canvas에서 Canvas Scaler라는 컴포넌트가 있는데, 여기서 UI Scale Mode를 설정할 수 있다.
    - 기본 값은 Constant Pixel Size이다. 이는 UI 요소들의 가로 - 세로 픽셀 길이가 고정됨을 의미한다.
    - 이를 웬만하면 **Scale With Screen Size**로 바꾸어야 한다. 이는 화면의 크기가 달라지면 그에 비례하게 내부 속성들이 같이 달라지게끔 하는 설정이다.
- 그러나 Scale With Screen Size과 해상도 설정만 하는것으론 안된다. 만약 모든 핸드폰이 16:9 고정이었다면 이걸로 끝이지만, 모든 기종이 해상비가 다르기 때문이다.
    - 그를 위해서 Screen Match를 정해야 한다.
    - Match Width or Height로 하면, 화면 해상비가 달라졌을 때 Width를 우선으로 하냐, Height를 우선으로 하냐를 고를 수 있다.
    - 만약 Width를 1로 했다면 해상비가 달라졌을 때 Width가 고정되고, Height가 길어지거나 짧아질 수 있다.
    - 이것은 게임의 UI마다 다르지만, 보통 **Expand**로 설정하여 해상비가 달라졌을 때 화면 늘이기를 설정한다. 이럴 경우 최소한 UI가 화면 밖으로 짤릴 일은 없다.
    - Shrink로 설정하면 요소들이 짤리면서 화면을 줄이게 된다. 단 이 경우 UI가 화면 밖으로 짤릴 경우가 많다.
- 그러나 스케일러만으로 모든 UI가 호환되게 할 수 없다. 상단 바, 하단 바 등이 하단에 있지만 화면비나 사이즈가 달라지면 잘리거나 공중으로 뜬다.
- 이 때 사용되는 것이 **Anchor, 앵커**이다.
    - 해당 요소가 화면의 어느 부분에 기준으로 자리잡을지 핀을 꽂는 개념이다.
    - Rect Transform에서 설정할 수 있다.
    - Shift를 누르면 피벗까지 한 번에 같이 원하는 방향의 가장자리로 옮겨진다.
    - Alt를 누르면 해당 오브젝트가 기준으로 잡은 앵커로 바로 이동된다.
- 만약 상단바, 하단바를 만들고 싶다면 상단으로만 앵커를 잡으면 문제가 된다.
    - 그 땐 상단, 하단에 완전히 꽉 차도록 늘리는 앵커를 사용해야 한다.
    - 만약 상단으로 늘리기 앵커를 잡으면 Width라는 개념이 없어진다. 어차피 위에서 가장 늘어날 때까지 길이가 가변되기 때문이다.
    - 대신 Left와 Right가 새로 생겨서, 왼쪽이나 오른쪽에 여백을 주거나 더 늘리는 작업을 할 수 있다.
- 마지막으로 화면 전체에 꽉 차길 원하는 UI의 경우, 전체화면으로 늘리기 앵커를 사용하면 된다.