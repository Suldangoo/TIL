# 디자인패턴

## 디자인 패턴

- 프로그램 설계 발생 문제를 해결할 수 있도록 하나의 규약 형태로 만들어놓은 것

### 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 하나의 인스턴스를 다른 모듈이 공유하며 사용, 인스턴스 생성 비용이 줄어들음
- 단점
    - TDD (단위테스트) 할 때 어려움, 인스턴스를 독립적으로 만들기가 어려워서.
    - 모듈 간의 결합을 강하게 만듬. 이를 위해 의존성 주입(DI)를 할 수 있음.

### 팩토리 패턴

- 상속 관계에 있는 두 클래스에서, 상위 클래스가 중요 뼈대를 결정하고 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴
- 느슨한 결합을 가지며, 상위 클래스는 인스턴스 생성 방식에 대해 전혀 알 필요가 없어 더 많은 유연성을 가지게 됨
- 공장이라는 상위 클래스, 해당 공장에서 만드는 여러 물품들의 레시피 하위 클래스

### 전략 패턴 (정책 패턴)

- 객체의 행위를 바꿀 때 직접 수정하지 않고, 전략이라고 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주며 상호 교체가 가능하도록 만드는 패턴
- 무언가 물품을 구매할 때 내부에 있는 결제 방식만 네이버 페이 혹은 카카오 페이 등으로 교체 가능한 것을 구현할 때 쓴다.
  
### 옵저버 패턴

- 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴
- 모든 객체들이 매 프레임마다 어떤 객체의 상태를 살펴보는 것은 매우 비효율적이기 때문
- 구현할 땐 주로 프록시 객체를 써서 구현한다.

### 프록시 패턴

- 대상 객체에 접근하기 전, 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 패턴
- 객체의 속성, 변환 등을 보완하며, 보안, 데이터 검증, 캐싱에 사용된다.
- nginx같은 프록시 서버에서도 사용된다.
    - 프록시 서버는 클라이언트가 자신을 통해 다른 네트워크에 간접적으로 접속할 수 있게 해주는 서버이다. 앞단에서 캐싱, 로깅, 데이터 분석을 서버보다 먼저 한다.
    - 공격자의 DDOS를 차단하거나 nginx를 이용해 Node.js로 이루어진 서버 앞단에 둬서 버퍼 오버플로우를 해결할 수도 있다.