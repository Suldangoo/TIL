# ■ 1과목 : 소프트웨어 설계

### 소프트웨어 공학

- 소프트웨어 특징
    - 상품성, 복잡성, 변경 가능성, 복제성
- 시스템 : 하나의 조직을 의미, 입력시 처리,  출력 사이에 제어가 일어나고, 피드백이 이루어짐
- 소프트웨어 위기
    - 비용 초과하는 개발비용 증가, 개발 기간 지연, 인력 부족, 성능 신뢰성 부족, 유지보수 어려움
- 소프트웨어 공학 : 어떻게 소프트웨어를 요구사항에 맞게 저렴하게, 쉽게 만들 수 있을까
    - 소프트웨어 개발, 운영, 유지보수, 폐기에 대한 체계적인 접근
    - 기본 원칙 : 현대적 프로그래밍, 신뢰성, 편리성, 유지보수성, 지속적인 검증 시행

### 소프트웨어 재공학

- 소프트웨어 개발엔 많은 비용이 드므로 기존의 소프트웨어를 재활용하는 방식의 공학
- 개발 시간 비용 감소, 품질 향상, 생산성 향상, 프로젝트 실패 위험 감소
- 유지보수성 향상이 최우선 목표, 재사용을 수월하게 해서 수명 연장
- 과정 : 분석 → 구성 → 역공학 → 이식
- 역공학
    - 기존에 쓰고 있던 소프트웨어를 재분석하여 설계 정보를 재발견, 재구축
    - 간단하고 오래된 것은 문서화
- SW 재공학 관점에서 유지보수 유형엔 Preventive Maintenance
- CASE (CAD의 소프트웨어 엔지니어링 버전, 소프트웨어 개발 자동화 도구)
    - 소프트웨어 개발 전용 도구
    - 개발을 신속하게 하고, 비용이 절약되고, 오류 수정이 쉬워 품질이 향상
    - 생명 주기 전체 단계 연결, 자동화
    - 문서화 및 명세화를 위한 그래픽 기능 제공
    - 개발 단계의 표준화, 자료 흐름도 작성
    - 모델들 사이의 모순 검사 기능 제공, 개발 모형 지원
- CASE의 분류
    - 상위 CASE : 요구분석 및 설계 단계 초기부분 지원
    - 하위 CASE : 실제 코딩 지원
    - 통합 CASE : 소프트웨어 개발 주기 전체 과정을 지원
- 요구사항 분석을 위한 CASE 도구
    - SADT : 소프트테크 사에서 개발한 소프트웨어 설계용 구조적 분석 및 설계 도구, 블록 다이어그램을 채택한 자동화 도구

### 소프트웨어 개발 방법론

- 소프트웨어 생명주기
    - 소프트웨어 개념 형성부터 운용/유지보수까지 변화의 모든 과정
    - 타당성 검토 → 개발 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 운용 → 유지보수
    - 전통적인 방법은 폭포수 모형
        - 처음부터 개발 과정을 전부 정한 뒤 순차적으로 진행되는 모형
    - 나선형 모형
        - 반복적인 작업을 수행하는 점증적 생명주기 모형
        - 계획 수립, 위험 분석, 개발 및 검증, 고객 평가를 반복해 빙글빙글 돌아가는 모형
        - 개발 중 발생할 수 있는 위험을 관리하고 최소화
        - 개발 및 검증 단계에서 프로토타입을 개발하고, 고객 평가 단계로 넘어감
- 하향식 설계 : 제일 상위에 있는 메인 유저 펑션(제일 중요한 것)먼저 만들고 가지를 만들기
- 상향식 설계 : 가장 기본적인 조그만 컴포넌트 먼저 만들고 상위 수준 컴포넌트 설계
- 프로토타입 모형 : 개발될 실제 시스템의 견본
- HIPO : 계층적 입력 처리 출력 구성의 시스템 문서화 기법
    - 가시적 도표, 총체적, 세부적 다이어그램으로 구성
    - 하향식 소프트웨어 개발을 위한 문서화 도구
- V-모델
    - 폭포수 모형에 시스템 검증과 테스트 작업을 강조한 모델
    - 요구사항 분석, 기능명세 분석, 설계, 개발 / 단위, 통합, 시스템, 인수 테스트
        - 앞 것이 정적 테스트 (코드 작성), 뒷 것이 동적 테스트 (실제로 테스트)
- 애자일 개방 방법론
    - 날렵한, 재빠른의 의미이며 소프트웨어를 빠르고 낭비 없이 제작, 고객이 원하는 것만 협업에 초점을 두고 개발 중 설계 변경에 신속히 대응
    - XP(익스트림 프로그래밍), 스크림, 린, DSDM, FDD
    - 애자일 선언문 : 고객과 잘 소통해서 고객이 원하는거 만들자
- XP
    - 아주 빠르게 양질의 소프트웨어를 만드는 것
    - 핵심 가치 : 고객과의 소통, 단순성, 피드백, 용기(고객 요구사항 반영)와 존중
    - Spike : 어려운 요구사항과 잠재적 솔루션을 고려하기 위해 작성하는 간단 프로그램
    - User Stories : 사용자의 요구사항을 간단한 시나리오로 표현
    - 릴리즈 플래닝 : 몇 개의 스토리가 적용된 제품을 제공
    - 이터레이션 : 하나의 릴리즈를 세분화한 단위, 반복 진행 중 스토리 추가
    - 스몰 릴리즈 : 작은 단위의 실제 프로그램 실행 가능 단위
- XP의 12가지 실천사항
    1. 짝 프로그래밍 : 한 사람은 개발, 한 사람은 검사
    2. 플래닝 게임 : 게임처럼 선수와 규칙, 목표를 두고 기획에 임한다
    3. 테스트 드라이븐 디벨롭먼트 : 실제 코드 작성 전 단위 테스트부터 작성 및 수행
    4. 훌 팀 : 개발 효율을 위해 고객을 프로젝트 팀원으로 상주
    5. 컨티니어스 인티그레이션 : 지속적으로 통합, 상시 빌드 및 배포 가능 상태
    6. 디자인 임프로브먼트 : 기능 변경 없이 중복 제거, 커뮤니케이션 향상, 유연성 재구성
    7. 스몰 릴리즈 : 짧은 주기로 잦은 릴리즈, 고객이 변경사항을 볼 수 있게
    8. 코딩 스탠다드 : 표준 코딩 기법에 맞춰 작성
    9. 콜렉티브 코드 오너쉽 : 시스템의 소스 코드는 팀의 모든 프로그래머가 언제든 수정 가능
    10. 심플 디자인 : 가능한 가장 간결한 디자인 상태 유지
    11. 시스템 메타포 : 최종적으로 개발되어야 할 시스템의 구조 기술
    12. 서스테이너블 : 일주일에 40시간 이상 작업 금지 등 개발자 과도한 업무 금지
- 효과적인 프로젝트 관리 3대 요소 : 사람, 문제, 프로세스 (3P)
- 스크럼
    - 스크럼 팀을 만들어 빠르고 명확하게 개발
    - 스크럼 팀의 역할 : 제품 책임자, 스크럼 마스터, 스크럼 팀
    - 스프린트라는 2~4주의 과정이 반복되며 회의(데일리 스크럼 미팅)가 매일 이루어짐
    - 소멸 차트 : 해야할 일을 기술하고 매일매일 한 일들을 삭제

### 현행 시스템 분석

- 해당 개발사가 어떤 시스템을 구성하는지 확인하는 것
- 개발 시스템의 개발 범위를 파악할 수 있음
- 파악 절차
    - 1단계 : 시스템 구성 파악 - 시스템 기능 파악 - 시스템 인터페이스 현황 파악
    - 2단계 : 아키텍처 파악 - 소프트웨어 구성 파악
    - 3단계 : 시스템 하드웨어 현황 파악 - 네트워크 구성 파악
- 시스템 아키텍처 : 총 시스템들이 어떻게 상호작용하는지, 설계도
    - 시스템의 전체 구조, 행위, 어떻게 작동하는지 설명하는 틀
- 시스템 및 인터페이스 현황 파악
    - 시스템 구성 파악 : 조직 내 업무들이 뭐가 있는지 문서화 (자동은 CASE)
- 시스템 기능 파악 : 각 시스템이 현재 제공하고 있는 기능을 표시
- 인터페이스 현황 파악 : 현황 시스템이 타 단위 업무 시스템과 주고받는 데이터 연계 명시
- EAI : 기업에 있는 모든 어플리케이션을 현대화하고 통합, 조정 도구
- FEP(프론트 엔드 프로세서) : 전위 처리기, 입력 데이터를 프로세서가 처리 전에 미리 처리
- 소프트웨어 구성 파악 : 소프트웨어 품명, 용도, 라이선스 명시
    - 단위 : 사이트, 서버, 프로세서, 코어
- 하드웨어 구성 파악 : CPU 등의 컴퓨터 사양 파악
    - 서버 이중화
- TCO : 일정 기간동안 프로젝트에 들어간 토탈 비용
- 플랫폼
    - 응용 소프트웨어 + 하드웨어 + 시스템 소프트웨어
    - 내가 소프트웨어를 만들기 위한 기반, 운영체제 소프트웨어
    - 종류 : JAVA, .NET, IOS, Android, Windows 등
    - 플랫폼 성능 특성 분석 : 응답 시간, 가용성, 사용률
    - 플랫폼 성능 특성 분석 방법 : 기능 테스트, 사용자 인터뷰, 문서 점검
- 오픈소스 라이선스
    - GNU(리눅스), GNU GPLv1(소스코드 비공개, 바이너리만 배포하는걸 금지) , BSD(수정 강제 아니고, 공개 하지 않아도 되는 초 자유) Apache 2.0 (하둡이라는 저렴한 다수의 컴퓨터를 하나처럼 묶어 대량 데이터 처리 기술)
- 현행 DBMS 분석
    - DBMS : 데이터베이스 관리 시스템, 종속성과 중복성 문제 해결. 일종의 미들웨어
    - DBMS 종류나 버전 등을 분석
    - 고려사항 : 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용

### 요구사항 개발

- 요구 공학 : 어떻게 고객이 원하는 것을 정확히 뽑아낼 수 있을까
    - 요구 공학에 도움되는 도구 : 자료 흐름도, 자료 사전, 소단위 명세서
- 요구사항 누락 방지, 상호 이해를 위해 존재, 요구사항 변경 이력 관리
- 요구사항 베이스라인 : 우리가 개발하려는 소프트웨어의 목표 달성 여부 확인 기준
- 요구공학 프로세스
    - 경제성, 기술성, 적법성, 대안성, 타당성 조사가 되어야 함
    - SWEBOK 요구사항 개발 프로세스 : 요구사항 추출 → 분석 → 명세 → 검증
- 요구사항 도출
    - 현재 상태를 파악하고 문제 정의 후, 문제 해결과 목표를 도출하는 것
    - 이해관계자가 식별된다.
    - 요구사항 도출 기법 : 발표, 문서 조사, 설문, 업무 절차 및 양식 조사, 브레인스토밍이나 워크숍 인터뷰, 관찰 및 모델 프로토타입, 유즈 케이스, 벤치마킹, BPR, RFP
- 요구사항 분석 :사용자 요구사항을 걸러내는 과정으로 요구사항 도출 후 정의 문서화
    - 기법 : 사용자 의견 청취, 사용자 인터뷰, 각종 문서 분석, 관찰 및 모델 작성, 설문 조사
- 요구사항 분석 수행 단계
    - 문제 인식 : 인터뷰나 설문조사 등 활용, 요구사항 파악
    - 전개 : 파악한 문제를 자세히 조사
    - 평가와 종합 : 요구를 다이어그램이나 자동화 도구로 종합
    - 검토 : 요구분석 작업의 내용 검토, 재정리
    - 문서화 : 요구사항 분석 내용을 문서화
- 요구사항은 기능 요구사항와 비기능 요구사항으로 분류된다.
    - 기능적 요구사항 : 실제로 어떻게 동작하는가, 완전히 기능 위주
    - 비기능적 요구사항 : 성능, 보안, 품질, 안정성 등의 수행에 보조적인 요구사항
- 요구사항 명세의 기법엔 정형 명세와 비정형 명세로 분류된다.
    - 정형 명세 : 수학적, 모델링 기반, 명세가 간결, 단 낮은 이해도
    - 비정형 명세 : 상태, 기능, 객체 중심 명세, 자연어 기반 (SADT, UseCase), 이해가 용이
- 요구사항 명세 속성 : 정확성, 명확성, 완전성, 일관성, 수정 용이성, 추적성
- 요구사항 확인
    - 요구사항 분석 단계를 거친 후 문서로 만들어진 내용을 확인하고 검증
    - 형상 관리, 일관성 확인, 요구사항 이해했는지 확인
    - 요구사항 관리 도구의 필요성 : 변경으로 인한 비용 편익 분석, 변경 추적, 변경에 따른 영향 평가
- 형상 관리 : 소프트웨어 개발 과정 중 나오는 모든 데이터나 문서들.
- 요구사항 확인 도구 : 프로토타이핑, 모델 검증, 요구사항 검토, 인수 테스트
- 모델 검증 : 분석 단계에서 개발된 모델의 품질을 검증
    - 정적 분석 : 객체 모델에서 객체들 사이에 존재하는 의사소통 경로를 검증
    - 동적 분석 : 직접 실행하여 모델을 검증
- 인수 테스트 : 실제로 고객에게 제공해 요구사항이 만족하는지 확인

### UML

- 개념 모델링 : 현실 세계의 내용을 이해하기 쉽게 도식화하는 것
    - 도메인의 엔티티들과 그들의 관계 및 종속성을 반영한다
    - 대부분 UML을 사용한다.
    - 종류 : 유즈 케이스 다이어그램, 데이터 플로우 모델, 스테이트 모델, 골 베이스드 모델, 유저 인터랙션, 오브젝트 모델, 데이터 모델
- UML : 객체지향 소프트웨어 개발 과정에서 모델링 기술과 방법론을 통합한 범용 모델링 언어
- **럼바우 객체지향 분석 기법**
    - 소프트웨어 구성 요소를 그래픽으로 모형화하는 객체 모델링 기법
    - 객체 모델링 : 시스템에서 요구되는 객체를 찾아내 속성과 연산 식별, 관계 연관화, 집단화, 다이어그램 표시
    - 동적 모델링 : 제어 흐름, 상호작용, 동작 순서 등의 상태를 시간 흐름에 따라 상태 다이어그램
    - 기능 모델링 : 여러 프로세스 간 자료 흐름 표시
- UML 소프트웨어 관점
    - 기능적 관점 : 사용자 측면에서 보는 사용 사례 모델링 (유즈케이스 다이어그램)
    - 정적 관점 : 소프트웨어 내부 구조적 관계 (클래스 다이어그램)
    - 동적 관점 : 시스템 내부 동작 (시퀀스, 스테이트, 액티비트 다이어그램)
- 스테레오 타입 객체를 표현할 땐 길러멧(<<>>)을 사용허며, 저 기호 안에 확장요소를 적는다.
- Public : 어떤 클래스든 접근 가능 +
- Protected : 해당 클래스와 동일 패키지에 있거나, 상속 관계에 있어야 접근 가능 #
- Package : 동일 패키지에 있는 클래스의 객체만 접근 가능 ~
- Private : 해당 클래스로 생성된 객체만 접근 가능 -

### 소프트웨어 아키텍처

- 개발 대상 시스템의 전반적인 구조를 체계적으로 설계하는 것, 설계도
- ISO/IEC 9126 모델로 소프트웨어 품질 특성과 평가 기준을 만들어냄
    - 내외부 품질로 기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성 등 구분
    - 사용 품질로 효과성, 생산성, 안정성, 만족도 구분

### UI 표준 및 지침

- UI : 사용자 인터페이스, 유저와 시스템간 상호작용 및 의사소통을 위한 매개체
- **직관성, 유효성, 학습성, 유연성**
- 사용자 중심, 일관성, 단순성, 가시성, 표준화, 접근성, 결과 예측 가능, 명확성, 오류 발생 해결


# ■ 2과목 : 소프트웨어 개발

# ■ 3과목 : 데이터베이스 구축

# ■ 4과목 : 프로그래밍 언어 활용

# ■ 5과목 : 정보시스템 구축 관리