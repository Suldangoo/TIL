# Chapter 04 : CPU의 작동 원리

## ALU와 제어장치
- CPU 내부에는 계산을 담당하는 ALU, 명령어를 읽고 해석하는 제어장치, 임시 저장 장치인 레지스터가 있다.
- 큰 개념은 Chapter 01 - 2에 있으므로 기억이 나지 않는다면 리마인드할 것.

### ALU
- ALU는 CPU 내에서 산술 연산과 논리 연산을 담당하는 부품이다.
- ALU는 레지스터를 통해 피연산자를 두 개 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다.
- 받아들인 피연산자와 제어 신호에 따라 다른데, 연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있으며, 메모리 주소가 될 수도 있다.
- 이 결괏값은 바로 메모리에 저장되지 않으며 일시적으로 레지스터에 저장된다.
- 그 외에도 ALU는 계산 결과와 더불어 **플래그**를 내보닌다.
- **플래그**
  - 이진수만 보고선 음양수를 판단하기 어렵기 때문에, 음수와 양수를 판단하기 위해 플래그를 사용한다.
  - 즉, ALU는 결괏값뿐만 아니라 연산 결과에 대한 추가 정보를 내보내야 할 때가 있다.
  - 예를 들어 방금 계산 결과는 음수라던가, 결괏값이 레지스터보다 클 때 오버플로우가 났다는 등의 추가 정보가 플래그이다.
- **플래그의 종류**
  - 부호 플래그 : 연산한 결과의 부호를 나타낸다. (부호 플래그가 1일땐 음수, 0일땐 양수)
  - 제로 플래그 : 연산 결과가 0인지 여부를 나타낸다. (제로 플래그가 1일땐 0, 0일땐 0이 아님)
  - 캐리 플래그 : 연산 결과 올림수나 빌림수가 발생했는지를 나타낸다. (캐리 플래그가 1일땐 발생, 0일땐 발생하지 않음)
  - 오버플로우 플래그 : 오버플로우가 발생했는지를 나타낸다. (오버플로우 플래그가 1일땐 발생, 0일땐 발생하지 않음)
  - 인터럽트 플래그 : 인터럽트가 가능한지를 나타낸다. (인터럽트 플래그가 1일땐 가능함, 0일땐 가능하지 않음)
  - 슈퍼바이저 플래그 : 커널 모드인지, 사용자 모드인지를 나타낸다. (슈퍼바이저 플래그가 1일땐 커널 모드, 0일땐 사용자 모드로 실행중)
- 발생한 플래그는 **플래그 레지스터**라는 이름의 레지스터에 저장된다.
- 이 밖에도 ALU 내부에는 가산기, 보수기, 시프터, 오버플로우 검출기 등의 회로가 존재한다.
### 제어장치
- 제어장치는 제어 신호를 내보내고, 명령어를 해석하는 부품이다.
- 제어 신호는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.
- 제어장치는 굉장히 정교하기 때문에, 받아들이고 내보내는 정보들이 굉장히 많다.
- **제어장치는 클럭 신호를 받아들인다.**
  - **클럭**이란 컴퓨터의 모든 부품들이 일정하게 움직일 수 있게 하는 시간 단위이다.
  - 하나의 명령어가 여러 클럭에 걸쳐 실행될 수도 있다.
- **제어장치는 해석해야 할 명령어를 받아들인다.**
  - CPU가 해석해야 할 명령어는 명령어 레지스터라는 특별한 레지스터에 저장된다.
  - 제어장치는 이 명령어 레지스터에서 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 부품들에게 명령을 내린다.
- **제어장치는 플래그 레지스터 속 플래그 값을 받아들인다.**
  - 제어장치는 플래그 값을 받아들이고, 이를 참고하여 제어 신호를 발생시킨다.
- **제어장치는 시스템 버스, 그 중에서 제어 버스로 전달된 제어 신호를 받아들인다.**
  - 제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 외부 장치도 발생시킬 수 있다.
  - 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 한다.
- 제어장치가 내보내는 정보에는 크게 CPU 외부에 전달하는 제어 신호와, CPU 내부에 전달하는 제어 신호가 있다.
- CPU 외부에 제어 신호를 전달한다는 것은 곧 제어 버스로 제어 신호를 내보낸다는 것이다.
- 이러한 제어 신호에는 크게 메모리에 전달하는 제어 신호와 입출력장치에 전달하는 제어 신호가 있다.
- 메모리에 저장된 값을 읽거나 쓰고싶다면 메모리로, 입출력장치의 값을 읽거나 쓰고싶다면 입출력장치로 제어 신호를 내보낸다.
- CPU 내부에 전달하는 제어 신호는 크게 ALU에 전달하는 제어 신호와 레지스터에 전달하는 제어 신호가 있다.
- ALU에는 수행할 연산을 지시하기 위해, 레지스터에는 레지스터 간에 데이터를 이동시키거나 저장된 명령어를 해석하기 위해 제어 신호를 내보낸다.

## 레지스터
- 프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다.
- 레지스터만 잘 관찰해도 프로그램의 자세한 실행 과정과 CPU 내의 일들을 모두 알 수 있다.

### 반드시 알아야 할 레지스터
- 상용화된 CPU 속 레지스터는 굉장히 종류가 많으며 이름과 크기도 제각각이나, 많은 CPU에서 공통으로 포함하는 레지스터가 있다.

1. **프로그램 카운터 (PC;Program Counter)**
   - 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장한다.
   - 명령어 포인터라고 부르기도 한다.
   - 지속적으로 1씩 증가하며 다음 명령어를 읽을 준비를 하는 레지스터이다.
     - 물론 JUMP 2500과 같은 특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행되면 1씩 증가되지 않고 바로 이동한다.
2. **명령어 레지스터 (IR;Instruction Register)**
   - 해석할 명령어를 저장하는 레지스터이다.
3. **메모리 주소 레지스터 (MAR;Memory Address Register)**
   - 메모리의 주소를 저장하는 레지스터이다.
   - CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때, 메모리 주소 레지스터를 거친다.
4. **메모리 버퍼 레지스터 (MBR;Memory Buffer Register)**
   - 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터이다.
   - 메모리에 쓰고 싶은 값이나, 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다.
   - CPU가 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거친다.
5. **범용 레지스터 (General Purpose Register)**
   - 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터이다.
   - 데이터와 주소를 모두 저장할 수 있으며, 일반적으로 CPU 내부엔 여러 개의 범용 레지스터들이 있다.
6. **플래그 레지스터**
   - ALU 연산 결과에 따른 플래그를 저장하는 레지스터이다.
   - 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터이다.
7. **스택 포인터와 베이스 레지스터**
   - 스택 주소 지정 방식과 변위 주소 지정 방식이라는 특별한 주소 지정 방식에 사용되는 레지스터이다.

### 특정 레지스터를 이용한 주소 지정 방식 : 스택 주소 지정 방식
- **스택 포인터(Stack Pointer)** 레지스터는 스택 주소 지정 방식이라는 주소 지정 방식에 사용된다.
- 여기서 스택 포인터란 스택의 꼭대기를 가리키는 레지스터이다.
- 스택 주소 지정 방식은 스택을 활용한 주소 지정 방식인데, 데이터가 들어있는 스택을 활용해 주소를 지정한다.
- 스택은 메모리 내부의 **스택 영역**에 존재한다.

### 특정 레지스터를 이용한 주소 지정 방식 : 변위 주소 지정 방식
- 변위 주소 지정 방식이란 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다.
- 따라서 변위 주소 지정 방식을 사용하는 명령어엔 연산코드 / 레지스터 / 오퍼랜드 값이 적혀있다.
- 이때 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 두 가지 방식으로 나뉜다.
- **상대 주소 지정 방식**
  - 오퍼랜드와 프로그램 카운터 값을 더하여 유효 주소를 얻는 방식이다.
  - 프로그램 카운터엔 다음에 읽어 들일 명령어의 주소가 적혀있기 때문에, 오퍼랜드에 적혀있는 숫자만큼 차이가 나는 곳의 주소를 참조한다.
  - 예를 들어, 오퍼랜드에 값이 -3이라면 읽어야 할 명령어로부터 세 번째 이전 번지로 접근하게 되는 것이다.
  - 이 방식은 if문과 유사하게 모든 코드 실행이 아닌 분기하여 특정 주소의 코드를 실행할 때 사용된다.
- **베이스 레지스터 주소 지정 방식**
  - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식이다.
  - 베이스 레지스터는 '기준 주소'를 의미하며, 오퍼랜드는 '기준 주소로부터 떨어진 거리'를 의미한다.
  - 상대 주소 지정 방식이 현재 명령어에 오차값을 준 것이라면, 베이스 레지스터 주소 지정 방식은 원하는 주소로부터 오차값을 준 것이다.

## 명령어 사이클과 인터럽트

- CPU가 하나의 명령어를 처리하는 과정엔 어떤 정해진 흐름이 있는데, 이런 정형화된 흐름을 **명령어 사이클**이라고 한다.
- 이 정해진 흐름을 따라 명령어를 처리해 나가지만, 간혹 이 흐름이 끊어지는 상황이 발생하는데 이를 **인터럽트**라고 한다.

### 명령어 사이클 (Instruction Cycle)
- 명령어를 메모리에서 CPU로 가지고 오는 단계를 **인출 사이클(Fetch Cycle)**이라고 한다.
- 인출해온 명령어를 실행하는 단계를 **실행 사이클(Execution Cycle)**이라고 한다.
- 프로그램을 이루는 수많은 명령어는 일반적으로 이 인출 사이클과 실행 사이클을 반복하며 실행된다.
  - 명령어를 가져와 실행하면, 해당 명령어에는 또 다음 명령어를 인출해오라는 명령어가 적혀있는 느낌이다.
- 그러나 간접 주소 지정 방식처럼 바로 명령어를 실행하는게 아닌 한 번 더 메모리에 접근을 해야하는 단계가 있을 수 있는데, 이 단계를 **간접 사이클(Indirect Cycle)**이라고 한다.

### 인터럽트 (Interrupt)
- CPU가 작업을 수행하던 도중 방해를 받아 잠시 중단될 때 발생하는 신호를 **인터럽트**라고 한다.
- CPU가 하던 일을 중단할 정도의 중요도를 가진 일이 도중에 발생할 때 일어난다.
- **동기 인터럽트(Synchronous Interrupts)**
  - CPU에 발생하는 인터럽트이다.
  - 가령, CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트이다.
  - 이런 점에서 동기 인터럽트는 **예외(Exception)**라고 부르기도 한다.
- **비동기 인터럽트**
  - 주로 입출력장치에 의해 발생하는 인터럽트이다.
  - CPU가 프린터같은 입출력장치에 작업을 부탁하고, 작업을 끝낸 프린터가 완료 알림으로 인터럽트를 보낸다.
  - 일반적으로 비동기 인터럽트를 **인터럽트**라고 칭하기도 하고, **하드웨어 인터럽트**라고 칭하기도 한다.

### 하드웨어 인터럽트
- CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 알림과도 같은 하드웨어 인터럽트를 사용한다.
  - 프린터에게 입출력 작업을 부탁한 뒤 끝날 때까지 사이클을 낭비하지 않기 위해 존재하는 것이다.
- 하드웨어 인터럽트 처리 순서
  1. 입출력장치는 CPU에게 **인터럽트 요청 신호**를 보낸다.
  2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
  3. CPU는 인터럽트 요청을 확인하고, **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
  4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
  5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
  6. 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행을 재개한다.
- 현재 CPU에게 실행 흐름을 끊어도 되는지 물어보는 것을 **인터럽트 요청 신호**라고 한다.
- 이 때, CPU가 인터럽트 요청을 수용하기 위해선 플래그 레지스터의 **인터럽트 플래그**가 활성화되어 있어야 한다.
  - CPU가 중요한 작업을 처리해야 해서 인터럽트를 받아들일 수 없을 땐 인터럽트 플래그가 불가능으로 설정된다.
  - 그러나, 인터럽트 플래그가 불가능으로 설정되어 있을지라도 무시할 수 없는 인터럽트도 존재한다. 정전이나 하드웨어 고장이 속한다.
    - 이를 막을 수 없는 인터럽트라고 한다.
- CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 **인터럽트 서비스 루틴**이라는 프로그램을 실행한다.
  - 인터럽트 서비스 루틴은 인터럽트를 처리하기 위한 프로그램이며, **인터럽트 핸들러**라고도 부른다.
  - 키보드가 어떤 인터럽트 요청을 보냈을 땐 어떻게 작동한다, 같은 작동 메뉴얼이 담긴 프로그램이다.
- CPU는 수많은 인터럽트 서비스 루틴들을 구분하기 위해 **인터럽트 벡터**를 이용한다.
  - 인터럽트 벡터는 인터럽트 서비스 루틴을 식별하기 위한 정보이다.
  - 인터럽트 벡터를 알면 서비스 루틴의 시작 주소를 알 수 있어 인터럽트 서비스 루틴을 완전 처음부터 시작할 필요가 없어진다.
- 정리하자면 CPU가 인터럽트를 처리한다라는 말은, 인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 되돌아온다는 말과 같다.
- 덧붙여, 인터럽트 서비스 루틴을 실행하기 위해 지금까지 CPU가 수행하고 있던 일, 즉 레지스터에 저장되어있던 값을 백업해야 한다.
  - 그렇기에 CPU는 인터럽트 서비스 루틴을 실행하기 전, 프로그램 카운터 값 등 재개에 필요한 모든 내용을 **스택에 백업**한다.

## 예외와 예외의 종류
- 예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한다.
- 예외를 처리하고 나면 CPU는 다시 본래 하던 작업으로 되돌아와 실행을 재개한다.
- 여기서 CPU가 본래 하던 작업으로 되돌아왔을 때 예외가 발생한 명령어부터 실행하느냐, 예외가 발생한 명령어의 다음 명령어부터 실행하느냐에 따라 **폴트**와 **트랩**으로 나뉜다.

### 폴트 (Fault)
- 폴트는 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외이다.
- 보조기억장치에 있는 데이터를 가져온다고 가정했을 때, 잠깐 작업을 폴트시키고 데이터를 메모리로 가져와 다시 재개하는 방식으로 사용된다.

### 트랩 (Trap)
- 트랩은 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외이다.
- 주로 디버깅을 할 때 사용한다.
- 특정 코드가 실행되는 순간 프로그램을 멈추게 하고, 프로그램 상태를 보기 위해 일부러 실행을 중지할 때 트랩이 발생하는 것이다.

### 중단 (Abort)
- CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외이다.

### 소프트웨어 인터럽트 (Software Interrupt)
- 시스템 호출이 발생했을 때 나타난다.