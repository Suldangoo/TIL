# Chapter 05 : 정렬

## 정렬의 개요

- 정렬은 정해진 데이터를 기준에 따라 순서대로, 체계적으로 정리하는 알고리즘이다.
- 정렬을 하는 이유는 ‘탐색’ 때문이다. 정렬된 데이터들은 이진 탐색 등의 아주 효율적인 탐색이 가능해지며, 상위나 하위의 데이터들을 빠르고 쉽게 탐색할 수 있기 때문이다.
- 정렬의 고전 알고리즘엔 버블 정렬, 삽입 정렬, 선택 정렬, 퀵 정렬 등이 존재한다.

## 버블 정렬

- 자료구조를 순회하여 이웃한 요소들끼리 데이터를 교환하며 정렬을 수행하는 방식이다.
- 이동하는 배열 요소의 길이가 반드시 이웃되어있다.
- 오름차순 정렬을 기준으로 가장 뒤에서부터 큰 값이 순차적으로 들어온다.
- 단, 버블 정렬은 다른 정렬 알고리즘들보다도 성능이 좋지 않다.
    - O(n^2)에 상수 계수도 높지만, 안정 정렬이라는 특성이 있다.

## 삽입 정렬

- 책장에 꽂힌 책을 제자리에 꽂는 과정과 유사하다.
- 순차적으로 자료구조를 순회하며 순서에 어긋나는 요소를 올바른 위치에 삽입하는 알고리즘이다.
- 순서에 맞는 곳에 끼워넣을 때, 기존에 있는 요소와 자리를 바꾼다.
- 버블 정렬과 같게 O(n^2)이지만 상수계수가 낮고 버블 정렬보다는 효율적이다.

## 퀵 정렬

- 퀵 정렬은 분할정복에 바탕을 둔 알고리즘이다.
- 기준 요소 (Pivot)을 정하고, 그보다 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 나누는 반복이다.
    - 기준 선정 → 분할과 정복 → 반복이다.
- 이걸 코드로 구현할 때 약간의 문제가 있다.
    - 배열을 사용한다면 퀵 정렬의 분할과정은 어떻게 해야 할까?
        - 피벗을 기준으로 노드를 이동시킬 때 링크드 리스트는 삽입과 삭제가 편하지만, 배열은 오버헤드가 심하다. 따라서 배열의 경우엔 기준 요소를 찾았다면 그보다 작은 값, 큰 값을 각각 찾아 순서를 교체하는 방식으로 구현한다.
    - 반복되는 분할 과정을 어떻게 구현할까?
        - 이는 재귀함수로 쉽게 구현할 수 있다. 퀵 소트 함수를 만들고, 가장 왼쪽부터 기준까지와 기준부터 가장 오른쪽까지의 범위를 재귀함수로 구현할 수 있다.
- 퀵 정렬은 위 두 정려보다 훨씬 시간복잡도가 빠르고 효율적이다.
    - 분할정복인 점에서 O(n log n)의 시간복잡도를 가진다.
    - 단 퀵정렬은 이론상 최악의 경우 O(n^2)이 나올 수도 있지만, 이론상으로의 수치이지 흔한 수치가 아니여서 이걸 시간복잡도로 치지 않는다.
- C언어에서는 기본적으로 표준 라이브러리의 퀵 정렬 함수 qsort()가 존재한다.
  <aside>
🎮

RPG 게임에서 인벤토리에 희귀도순이나 획득 순 정렬은 많이 보았을 것이다.
그 외에도 리더보드에서 점수를 정렬할 때도 정렬을 많이 쓰는데, 이 경우엔 정렬 알고리즘보다는 실시간 갱신을 위해 우선순위 큐를 사용하는 것이 효율적이다.

보통 게임 내에서 정렬을 직접 구현할 일은 없지만, 사용한다면 퀵 정렬, 병합 정렬을 많이 사용한다.

</aside>

# Chapter 06 : 탐색

## 탐색의 개요

- 데이터를 찾는 알고리즘이다.
- 가장 원시적이면서도 확실하지만 비효율적인 탐색은 처음부터 끝까지 하나씩 열람해보기이다.
- 그러나 정렬된 배열에선 이진 탐색 등이 가능해진다.

## 순차 탐색

- 우직하게 처음부터 끝까지 모든 요소를 비교하여 데이터를 찾는 탐색 알고리즘이다.
- 성능은 좋지 않지만 정렬되지 않은 배열에서 가장 신뢰도가 높다.
- 데이터 크기가 작고 버그를 만들 가능성이 적을 때 유용하다.
- 보통 데이터를 탐색할 땐 자주 사용되는 항목이 데이터 앞쪽에 배치되는것이 좋다.

### 전진 이동법

- 탐색된 항목을 데이터의 가장 앞으로 옮기는 방법이다.
- MS 워드의 최근 문서 목록과 같은 기능이다.
- 한 번 탐색된 항목이 다음에 또 다시 검색될 가능성이 높은 데이터에 한해 사용한다.

### 전위법

- 전위는 위치를 바꾼다는 뜻으로, 탐색된 항목을 이전 항목과 교환하는 전략을 취하는 알고리즘이다.
- 포인트는 한 칸만 앞으로 옮기는 것이다. 크게 점프를 뛰어 앞에있는게 뒤로 가지는 않는다.
- 자주 탐색된 항목을 조금씩 앞으로 옮기는 방식이다.

### 계수법

- 데이터 내 각 요소가 탐색된 횟수를 별도의 공간에 저장, 횟수가 높은 순으로 데이터를 재구성하는 전략의 알고리즘이다.
- 전위법을 사용하면 처음부터 앞에 있던 데이터는 계속해서 선두를 유지할 가능성이 높다. 그러나 계수법을 사용하면 확실히 데이터의 사용 빈도에 따라 정렬이 된다.
- 그러나 이도 단점이 있는데, 별도의 공간을 유지해야 하고 계수 결과에 따라 재배치하는 데에 비용이 많이 든다.

## 이진 탐색

- 정렬된 데이터에서 사용할 수 있는 고속 탐색 알고리즘이다. 탐색 범위가 절반씩 줄어들기에 O(log n)의 시간 복잡도가 소요된다.
    - 중앙에 있는 요소를 고르고, 목표값과 비교하여 작다면 왼쪽, 크다면 오른쪽으로 포인터를 이동한다.
    - 포인터와 탐색값이 일치하면 리턴한다.
- 처음엔 1/2, 다음엔 1/4, 그 다음엔 1/8… 탐색 범위가 절반씩 줄어들기 때문에 O(log n)이 걸리게 된다.
- 이진 탐색 구현의 경우엔 Left와 Right 변수를 사용하여 if문으로 절반씩 줄여가도록 하면 된다.
- C언어에서의 표준 라이브러리의 이진 탐색 함수는 bsearch()이다.
    - 첫 번째 매개변수로 찾고자 하는 목표값 데이터 주소, 두 번째 매개변수로 데이터 배열의 주소를 가리키는 포인터, 세 번째 매개변수로 데이터 요소의 개수, 즉 크기를 입력한다.

## 이진 탐색 트리

- 이진 탐색을 위한 트리이자, 탐색을 위한 이진 트리
- 이진 탐색 자체는 정렬된 배열에만 사용할 수 있는 알고리즘이기 떄문에, 링크드 리스트로는 위와 같은 작업이 불가능하다. 링크드 리스트는 헤드와 테일 사이 중앙 요소를 알 수 없기 때문이다.
- 즉 링크드 리스트에서도 이진 탐색을 하기 위해 이진 탐색 트리를 활용할 수 있는 것이다.
- 이진 트리는 왼쪽 자식 노드가 나보다 작고, 오른쪽 자식 노드가 나보다 크다.
- 탐색은 노드의 크기를 보고 왼쪽, 혹은 오른쪽으로 이동하며, 삽입 역시 같다.
- 그러나 이진 탐색 트리에서의 삭제는 좀 까다롭다. 특유의 뒤처리가 굉장히 어렵기 때문이다.
    - 삭제하는 노드가 잎 노드라면 문제될 것이 없다.
    - 그러나 자식이 있는 경우엔, 자식이 한 개이거나 두 개인 경우가 각각 다르다.
    - 자식이 하나라면 자식이 자신의 자리를 대체하여 부모 선이 새로 그어진다.
    - 자식이 두 개라면, 삭제된 노드의 우측 하위 트리에서 최솟값 노드를 찾아 삭제된 노드로 위치를 옮겨야 한다.
- 그러나 이진 트리도 문제점이 있다. 편향 트리가 되어버리면 배열과 다를게 없어 효율이 극단적으로 떨어진다.
- 따라서 스스로 균형을 잡는 알고리즘을 지닌 트리가 나타난다.

## 레드 블랙 트리

- 스스로 균형있게 높이가 유지되고, 회전연산을 통해 왼쪽 서브 트리와 오른쪽 서브 트리가 높이 차이가 크게 나지 않는 트리 중 가장 많이 쓰이는 트리가 레드 블랙 트리이다.
- 레드 블랙 트리는 enum을 통해 RED 혹은 BLACK의 컬러를 가지게 된다.
- 레드 블랙 트리의 규칙은 다음과 같다.
    - 모든 노드는 빨간색이거나 검은색이다.
    - 뿌리 노드는 검은색이며, 잎 노드도 검은색이다.
    - 빨간 노드의 자식은 모두 검은색이다.
        - 검은색 노드는 검은색 노드나 빨간색 노드 모두 자식으로 가질 수 있다.
    - 뿌리 노드와 모든 잎 노드 사이에 있는 검은색 노드의 수는 모두 동일하다.
- 잎 노드는 NIL로 표시되어, 아무 데이터도 갖고 있지 않지만 색만 검은 색인 더미 노드이다. 이걸 센티넬 노드라고 한다.
- 굳이 더미 노드인 센티넬 노드를 쓰는 이유는, 레드 블랙 트리의 구현을 용이하게 만들기 위해서이다.
    - NIL 노드를 양쪽 자식으로 연결하면, 모든 잎 노드는 검은색이다라는 규칙이 항상 지켜질 수 있기 때문이다.
- 회전 연산을 통해서 부모와 자식 노드의 위치를 바꾸고, 균형을 조정할 수 있다.

<aside>
🎮

게임에서 탐색은 큰 의미를 가진다.

게임은 그 어떤 소프트웨어들보다 탐색을 정말 많이 쓰는 종류 중 하나이다. 플레이어를 검색하거나, 몬스터를 검색하거나, 아이템을 검색하는 일이 비일비재하게 많이 일어나는데, 몬스터도 객체지향에선 수많은 종류가 있기 때문에 ID를 통해 몬스터를 검색하거나, 이름을 통해 검색하는 등 프로그래머가 특정 오브젝트를 검색해야하는 일이 많이 일어난다.

하지만 맵 속에 존재하는 모든 오브젝트에서 원하는 오브젝트를 찾기 위해선, 정렬되어있지 않은 맵에서 불규칙적인 오브젝트를 찾는 것이기에 반드시 순차 탐색을 해야 한다. 이는 그렇게 좋지 않은 성능을 보여준다.

따라서 보통은 게임 엔진 내에서 최적화된, 내장 탐색 메서드를 쓴다. 이를 통해 ID로 검색을 하거나 이미 지정된 오브젝트를 바로 불러올 수 있다.

게임 컨텐츠 내에서 직접 탐색을 구현할 땐, 이진 탐색이 도움될 수 있다. 특히나 이진 트리는 게임 내에서 많이 사용되는 편이므로, 탐색 알고리즘을 만들어 유저에게 편의적인 기능을 제공하는 것 또한 가능하다.

</aside>

# Chapter 07 : 우선순위 큐와 힙

## 우선순위 큐 개요

- 일반적으로 선입 선출의 자료구조를 큐라고 했었다. 그러나 우선순위 큐는 나오는 순서가 들어왔던 순서대로가 아닌, 요소들의 우선순위가 높은 것이 먼저 나오는 특수한 형태의 큐이다.
- 우선순위 큐는 우선순위 속성을 갖는 데이터의 삽입과 제거 연산을 지원하는 ADT이다.
- 한 마디로 큐의 내부 속성이 우선순위대로 정렬되며, 먼저 들어온 것이 크게 의미가 없는 큐이다.

## 힙

- 이 힙은 프로그래밍 언어에서 사용하는 자유 저장소 (Free Store) 의 힙이 아니다.
- 힙은 순서 속성을 만족하는 완전 이진 트리이다.
- 힙 순서 속성상 트리 내의 모든 노드가 부모 노드보다 커야 한다는 규칙이 있다.
    - 이것이 최소 힙이다.
- 이진 탐색은 불가능하지만, 힙에서 가장 작은 데이터를 갖는 노드는 뿌리 노드라는 것은 확실하다.

### 힙의 삽입 연산

- 새로운 노드가 추가되면, 완전 이진 트리를 유지하는 가장 끝에 노드를 추가한다.
- 이후 부모 노드와 크기를 비교하여, 자신이 더 작다면 부모와 순서를 교환한다.
    - 이것이 그만 교환될 때까지 계속해서 부모와 비교해 반복한다.