# Part 1. 언리얼 엔진 블루프린트

# 개요

- 블루프린트는 언리얼 엔진에서 제공하는 기본적인 비주얼 스크립팅 툴
- 블루프린팅을 하면 간단한 기능을 손쉽게 구현하거나 프로토타입을 만들기 쉽고, UI나 애니메이션 등 일부분은 C++보다 오히려 유리하다.

## 환경설정

- 언리얼 엔진을 가동하면 언리얼 프로젝트 브라우저가 나타난다.
- 게임 - 기본(Black) 로 개발 스타트, 블루프린트 설정
- 데스크탑 / 맥시멈 / 시작 콘텐츠는 없이 시작
    - 시작 콘텐츠는 간단한 에셋과 메테리얼이 들어가있는 상태로 시작
- 창 - 레이아웃 불러오기 - UE4 클래식 레이아웃으로 설정
- Ctrl + N 으로 뉴 레벨 (새로운 맵) 생성
    - 보통 Basic으로 생성
- 언리얼의 씬과 같이 콘텐츠(Assets) 폴더 내에 Maps라는 폴더를 생성해서 Ctrl + S를 누르면 저장 브라우저가 뜨고, Maps에 저장 가능
- 환경 설정으로 들어가 프로젝트 - 맵 & 모드 - 에디터 시작 맵과 게임 기본 맵을 방금 만든 DevMap으로 설정
- 게임 프로젝트가 생성되었고, 프로젝트 경로에 .uproject 파일로 남아있음

## 언리얼 엔진 기초

- 뷰포트 : 유니티의 게임 씬. 에셋들이 배치되어 있는 게임 공간
    - 우클릭을 한 상태로 WASD로 키보드 / 마우스로 조작이 가능
    - Q, E를 눌러 위 아래로도 업다운이 가능
    - QWER을 통해 물체를 잡고, 회전하고, 키우는 조작이 가능 (유니티와 동일)
    - 사물을 선택한 채 End 키를 눌러 땅에 붙이기
    - 사물을 선택한 채 F 키를 눌러 포커싱하기
- 컨텐츠 브라우저 : 유니티의 에셋. 소스 코드나 파일 등 준비물을 보관
- 액터 배치 : 언리얼에서 자체적으로 만들어준 기본 에셋들
    - 조명, 도형, 다양한 기능들
    - 리스트에서 원하는 것을 집어 뷰 포트로 드래그하여 소환 가능
- 아웃라이너 : 유니티의 하이어라키. 맵에 배치된 모든 오브젝트가 보여짐
    - 조명같은 생성하지 않은 오브젝트도 눈 모양을 눌러 꺼보면 무엇인지 알게 됨
    - 계층 구조로 이루어져있어 오브젝트의 자식 오브젝트로 두어 하나로 만들 수 있음
- 디테일 패널 : 오브젝트의 세부적인 정보. 인스펙터 창과 유사
- 따로 카메라를 배치하지 않으면, 재생 버튼을 누를 때 보고 있던 화면 그대로 게임 시작
    - 게임을 시작하면 아웃라이너에 카메라 액터를 비롯한 필요한 오브젝트들이 생성됨
    - Shift + F1이나 F8을 눌러 재생 중에 잠시 바깥으로 나올 수 있음

## 블루 프린트

- 윈도우의 왼쪽, 그래프 모양의 아이콘이 블루프린트 메뉴
- ‘레벨 블루프린트 열기’를 눌러 블루프린트를 켤 수 있음
- 나온 창을 잡아 왼쪽 윈도우 탭에 추가할 수 있음
- 레벨 블루프린트는 쉽게 말해 해당 맵(씬)에서의 블루프린트
    - 레벨을 하나 만들 때마다 하나씩 딸려 만들어짐
    - 레벨당 하나씩 짝이 있어서, 다른 레벨을 만들면 또 새로 작성을 해주어야 함
- 블루프린트에 노드를 추가하고, 작업을 했다면 꼭 컴파일 - 세이브
- 이벤트 : 어떤 상황에서 호출 될 것이라는 트리거
    - BeginPlay 이벤트 (트리거) : 게임이 실행될 때 딱 한 번만 호출되는 이벤트
    - 틱 이벤트 : 게임 실행 도중 매 프레임마다 계속 호출되는 이벤트
    - 이벤트는 약속된 시기에 나오는 것들이 아주 많이 있으며, 직접 만들 수도 있음.
    - 키보드 1을 검색하면, 1 버튼을 누를 때마다 호출되는 이벤트가 생성됨
- 조작
    - 우클릭으로 이동, 휠로 확대 축소, 좌클릭으로 선택 및 드래그
    - Ctrl + C, V, D로 복사 붙여넣기가 가능
    - 노드간의 선을 더블클릭하여 선을 두개로 분리하거나, 원하는대로 휘게 할 수 있음
    - 선이 연결된 화살표를 우클릭하여 연결된 선을 모두 끊을 수 있음
        - Alt + 좌클릭
    - 이미 연결된 선을 다른 노드로 옮기고싶다면 Ctrl + 좌클릭으로 드래그
    - 원하는 노드들을 전부 선택한 후 Q를 누르면 일렬로 정리가 됨
- 원하는 블루프린트들을 드래그해서 C를 누르면 주석을 입력할 수 있음

# 변수

## 변수 타입

- 그 어떠한 게임, 프로그램들도 모두 데이터와 로직으로 구성되어 있음.
- 데이터와 로직 두 가지를 정복할 수 있다면 세상의 모든 프로그램을 만들 수 있음.
- 블루프린트 창에서 왼쪽에 변수(Variables)에 +를 눌러 새로운 변수를 생성
- 오른쪽 기본값에 변수의 기본 초기화값을 설정할 수 있게 됨
- 변수를 만들 땐 이름과 타입을 골라주어야 함
    - 언리얼에선 앞 글자가 대문자인 것으로 변수 이름을 짓는 것이 일반적이다. (컨벤션)
    - 부울(Boolean) : True, False 두 가지의 형태가 존재 가능한 변수
        - 불리언 변수는 이 변수가 불리언이란걸 나타내기 위해 변수 이름 앞에 소문자 b를 붙이기도 한다. (ex : bSound)
        - 그렇게 되면 우측 초기값에서도 앞 소문자 b는 무시하고 이름을 출력해준다.
    - 바이트(byte) : 정수형, 0~255로 크기가 작음 (커스터마이징 수치)
    - 인티저(integer) : 정수형, -21억 ~ 21억
    - 인티저64(integer64) : 정수형, 굉장히 크기가 큼
    - 플로트(float) : 실수형, 부동소수. 3.14
    - 네임(Name) : 문자열, 언리얼 내부에서 사용하며, 절대 바뀌지 않고, 빠르게 검색 가능
        - 해시를 사용해서 매우 빠르게 검색 가능하며 용량이 적음
    - 스트링(String) : 문자열, 일반적인 상황에 변화가 있고, 딱히 다국어 변환이 필요 없을때
    - 텍스트(Text) : 문자열, 깃발 아이콘과 함께 로컬라이징 기능을 제공
        - 다른 언어로 번역이 된다면 텍스트가 변환이 될 때 사용
        - Tools - 로컬리세션 (현지화) 대시보드에서 여러 언어를 추가할 수 있음

## Get, Set

- 메모리에 할당된 변수에 특정 값을 쓰는 것을 Set
- 메모리의 변수에 쓰여있는 값을 읽어오는 것을 Get
- 블루프린트 노드로 <Set 변수명>, <Get 변수명> 을 사용한다.
- Set 노드를 사용하면 원하는 값을 직접 입력할 수 있고, Get 노드를 사용하면 읽어온 값을 다른 노드에 연결할 수 있다.
- Get 노드를 가져와 Print Text 노드에 연결하면, 자동으로 int를 Text로 캐스팅해주는 노드도 생겨난다.
- Set 노드의 아웃풋도 설정한 값을 그대로 출력해주는 거라서, 즉시 Get을 할 것이라면 Set노드의 아웃풋을 바로 연결해도 무관하다.
- 굳이 Get, Set 노드를 찾아서 꺼내지 않아도, 왼쪽 변수에서 드래그해서 가져올 수도 있다.
    - Ctrl + 드래그 시 Get 노드가 불러와진다.
    - Alt + 드래그 시 Set 노드가 불러와진다.

## 사칙연산

- 노드에 단순한 덧셈 / 뺄셈 / 곱셈 / 나눗셈 노드가 존재한다.
- 노드 검색에 ‘+’ 만 입력해도 바로 나온다.
- 왼쪽에 두 개 이상의 노드를 연결하면, 두 노드에 연산을 한 후 오른쪽으로 배출하는 형태이다.
- 왼쪽 노드 연결 점(핀, Pin)을 우클릭하고 원하는 형태의 타입으로 변경할 수 있다.
    - 물론, 굳이 일일이 설정하지 않아도 원하는 변수를 연결하면 알아서 변경된다.
- 나머지는 평범하나, 나눗셈은 조금 주의해야 한다.
    - 절대로 어떤 수를 0으로 나눌 수 없다. 그나마 언리얼은 0으로 나눈 값을 0으로 잡아준다.
    - 인티저끼리의 나눗셈을 한다고 그 결과가 부동소수가 되지 않는다.
    - 즉, float로 핀을 설정해주고 나눗셈을 해야 정확한 결과가 나온다.
    - 물론 둘 중 하나만 float로 해두면 float가 더 우선순위가 높아 소수점이 유지된다.
    - 만약 int끼리 나눗셈을 하고 싶다면, 일시적으로 float 형태로 캐스팅을 해주어야 한다.
        - To Float라는 Conversions 노드를 통과해야 함

### 단축연산

- 굳이 사칙연산을 쓰지 않아도, ++나 --는 별도의 노드가 존재한다.

## 비교연산

- 두 숫자 중 무엇이 더 크고 작은지 판별하는 노드가 존재한다.
- 노드 검색에 ‘<’ ‘>’ ‘≤’ ‘≥’ ‘==’ ‘!=’ 를 검색해 얻을 수 있다.
- 그 결괏값에 따라 출력으로 True 혹은 False를 리턴한다.
- 결괏값을 어떤 Boolean 변수에 할당할 수 있다.
    - 직접 변수를 새로 만들어서 Set 노드를 만들고, 할당할 수 있다.
    - 그러나 일일이 그렇게 하지 않고, 출력 선을 끌고 온 뒤 ‘변수로 승격’을 누르면 새 변수가 만들어진다.

### 포맷 텍스트

- Format Text(포맷 텍스트)는 어떤 문자열에 변수 값을 대입해야 할 때 사용하는 노드이다.
- 원하는 문장을 입력하고, 변수값을 넣고싶은 부분에 {0}를 입력하고 엔터를 누르면 핀이 나온다.
    - 0은 그저 파라메터 값을 의미하고, {Count}처럼 이름을 지정해줘도 좋다.

## 디버깅

- 값을 테스트할 때 print text를 마구 뿌려서 디버깅을 할 수도 있지만 옳은 방법이 아님
- 그럴때 사용하는 것이 바로 디버깅 기능
- 원하는 노드에 F9를 찍으면 빨간 동그라미가 생성되며 브레이크 포인트가 찍힘
    - 실행해나가다가 브레이크 포인트에서 실행이 멈춤
    - 메모리에 적재된 변수들의 값도 바로바로 확인이 가능
- F10을 누르면 다음 노드로 넘어가게 됨
- 반드시 에러가 떴을 때 디버깅을 해야 변수값을 추적하며 손쉽게 수정이 가능함

## 논리연산

- AND Boolean / OR Boolean / NOT Boolean 등등 여러 논리 연산자가 존재한다.
- 꼭 뒤에 Boolean을 붙여야 검색이 가능하다.
- Add Pin을 통해 3개 이상의 조건을 동시에 측정할 수도 있다.

# 흐름 제어

- 어떤 조건이나 상황에 따라 코드가 특정 방향으로 흐르게 하는 것
- 크게 **분기문**과 **반복문** 두 가지로 구분이 가능하다.

## Branch, Sequence, Flip Flop

### 브랜치

- 앞에 불리언이 들어갔을 때 참과 거짓에 따라 분기가 일어나는 것
- 값이 True냐, False냐에 따라 분기를 만들어주는 노드
- 굉장히 중요한 노드라서 단축키 ‘B’를 누르고 좌클릭을 하면 바로 생성된다.
- if - else문 대신 존재하는 분기문이다.

### 시퀀스

- 노드가 진행됨에 따라 Then 0을 모두 실행하고, 실행이 끝나면 Then 1을 모두 실행하는 방식으로 반복이 일어나는 노드이다.
- 단축키 ‘S’를 누르고 좌클릭을 하면 바로 생성된다.
- 코드 정리 차원에서 매우 유용하게 사용할 수 있다.

### 플립 플랍

- A → B → A → B → … 하는 방식으로 길이 바뀌는 노드이다.
- 로직 회로가 여러 번 실행될 때, 처음엔 A가 실행되었다가 다음엔 B가 실행되었다가 하는 방식으로 기찻길이 바뀌는 것과 유사하다. (혹은 전등 스위치)
- Is A는 현재 실행하고 있는게 A인지 B인지를 나타내주는 불리언 출력이다.

## Min, Max, Clamp

- Min, Max 둘 다 파이썬과 유니티에도 존재하는 함수
- 두 인자로 넣은 값 중 더 크거나 작은 것을 리턴한다.
- Clamp는 Min과  Max 두 함수를 합쳐놓은 개념
    - 정해진 값을 Min보다 작아지지 않게, Max보다 커지지 않게 막아주는 함수
    - Clamp는 경계를 포함해서 리턴한다.

## For Loop, While Loop

- For Loop, While Loop 둘 다 노드로서 존재하는 반복문
- While Loop
    - 컨디션이 참이라면 반복하다가 거짓이 되면 빠져나오는 노드
    - 무한 루프가 실행되면 에러가 터짐
- For Loop, For Loop with Break
    - First Index에서 Last Index까지 인덱스에 변화를 주며 반복
    - First Index에서 1씩 더해가는데, 인덱스를 모두 포함하기 때문에 0부터 5까지 했다면 0과 5를 포함하여 (마지막 값을 포함) 반복 후 벗어나게 된다
    - 도중 빠져나오고 싶을 때 break가 포함된 노드를 사용
    - 앞 진행 사항 도중 break로 진행 선을 뒤로 연결해주면 됨
        - 선 정리할 때 더블클릭으로 포인트 생성 후 컨트롤 클릭으로 정리

## Gate, MultiGate, Do Once, Do N

### Gate

- 마치 성문같은 노드
- Start Closed가 체크되어 있다면 더 이상 진행되지 않고, 체크가  해제되어 있다면 진행된다.
- Enter로 흐름이 왔을 때 현재 컨디션에 따라 Exit로 보낼지 말지 결정
- Open으로 흐름이 들어오면 Closed가 열린다
- Close로 흐름이 들어오면 Closed가 닫힌다
- Toggle로 흐름이 들어오면 현재 Closed의 상태가 반대로 변한다

### MultiGate

- 출구를 여러 개 둘 수 있는 게이트 노드이다
- 한번 Enter될 때마다 매번 출구가 하나씩 바뀌게 된다
- 최종적으로 다 실행했다면 더 이상 출구가 없어 실행 흐름이 막힌다
- Start Index를 설정해 시작하는 출구를 정할 수 있다
- Loop를 켜면 끝까지 다 진행된 뒤 다시 처음으로 돌아가게 된다
- is Random을 켜면 출구 순서가 랜덤으로 변한다
- Reset 흐름을 켜버리면 닫힌 모든 문들이 열리며 초기화된다
- NPC가 매번마다 랜덤한 대화를 출력할 때 매우 효과적이다

### Do Once

- 한 번만 실행을 시켜주는 노드이다.
- 한 번 엔터가 되면 컴플리티드로 실행이 되는데, 그 이후론 막혀버린다.
- Reset으로 흐름을 작동하면 다시 열리게 된다.
- 게이트보다 좀 더 기능이 축소된 노드이다.

### Do N

- N번만 실행을 통과시켜 주는 노드이다.
- 첫 실행 시 1로 시작하는 것부터 N까지 실행되는 카운터 변수를 사용할 수 있다.
- Reset으로 흐름을 작동하면 다시 열리게 된다.
- For Loop와 유사하다.

## Enum

- 플레이어의 상태에 따라 그에 맞는 애니메이션을 틀어주어야 함
- 즉, 상태라는 것을 관리해야 함
- 변수 하나를 만들어 0이면 Idle, 1이면 공격… 이런식으로 하드코딩은 좋지 않음
- 이럴 때 열거형을 사용해야 하며, Enum이 존재함.
- 열거형 블루프린트 파일을 만들 때 이름 앞에 E를 붙이는 것이 일반적
- 들어가서 이너머레이터 추가 (혹은 Add Enumerator) 로 여러 상태를 생성 가능
- 디스플레이 이름에 원하는 상태인 Idle, Moving 등을 넣어주면 그것이 하나의 타입이 됨
- 이후 변수를 생성해서 아까 만들어두었던 Enum 파일의 이름을 검색
- 변수를 만든다음 디테일을 보면, 기본값에서 정수형이 아닌 원하는 타입들이 선택 가능하게 됨
- 기존 변수에선 비교연산자로 ==를 사용했으나, Enum에선 Equal(Enum)을 사용해야 함
- 그러나 색상을 보면 byte와 색상이 같은데, 엔진 내부적으로는 구조가 다를 바가 없기 때문
- 바이트를 열거형으로 바꾸는 노드가 존재
- 열거형을 이용하면 상황에 따라 분기를 하고 싶을 때, branch를 써도 되지만 switch라는 좋은 분기문이 있다.
    - 한글로는 E~ 켜기
    - switch를 사용하면 정말 단순하게 현재 상태에 따라 어떤 분기를 가게 될지 간단하게 설정 가능
- 무언가 원하는 이벤트를 작동시키고 싶을 때, 커스텀 이벤트를 생성 가능

# 함수

## 함수 기초

- 항상 사용하던 get, set, print text들이 모두 언리얼에 있는 기본 내장함수
- 블루프린트 왼쪽 메뉴에서 Functions의 +를 클릭해 직접 함수를 만들 수 있다.
    - 그러나 이 기능은 엄밀히 말하면 C++의 멤버 함수
    - 일단 일반 함수로 진행한 뒤 객체지향을 공부할 때 쓸 것
- 블루프린트에선 우클릭 - 블루프린트에서 블루프린트 함수 라이브러리
- 이것이 C++에서 말하는 정적 함수 (스태틱 함수)
- 여기서 만들어진 함수는 다른 블루프린트에서 노드로 만들어 정의된 내용의 함수를 언제든 호출 가능
- 함수에서 오른쪽 디테일을 보면 입력과 출력을 확인할 수 있고, 추가할 수 있다.
    - 입력을 추가하면 다른 블루프린트에서 함수를 호출할 때 입력값을 넣을 수 있다.
    - 출력을 추가하면 출력 반환 노드가 생기고, 원하는 값을 함수 안에서 넣어줄 수 있다.
    - 우리가 항상 쓰던 노드들과 마찬가지로, 왼쪽의 구멍과 오른쪽의 구멍이 생긴 것을 알 수 있다.
- 추후 프로젝트의 규모가 커지면 함수 단위로 코드를 짜야 코드의 양이 많아지지 않는다.
- 만약 프로젝트 내에서 한 번밖에 쓰지 않을 명령어 집합이 있다면 굳이 함수로 만들지 않는 것이 성능은 더 좋지만, 두 번 이상 쓰게 될 것이라면 함수로 만들어 코드의 가독성을 높이는 것이 훨씬 좋다.
  
## 로컬 변수

- 함수 블루프린트 라이브러리 내에서 왼쪽 목록에서 함수들을 고를 수 있다.
- 또한, 그 아래에서 로컬 변수 (Local Variables)를 관리할 수 있다.
- 이 변수는 지역 변수로, 기존 레벨 블루프린트에서 만든 변수들은 멤버 변수에 해당한다.
- 이 지역 변수는 해당 함수 안에서만 사용하는 변수로, 함수 밖에서는 효력이 없는 함수이다.
    - 즉, 그 함수 라이브러리 안에서라도 다른 함수라면 지역 변수가 사라진다.
    - 해당 변수 안에서만 임시로 쓰는 변수이다.
    - 또한 이 변수는 함수에 종속적이어서, 변수를 만들었다고 바로 메모리를 차지하는 것이 아닌, 함수가 호출될 때 메모리에 적재된다.
- 예전에 만든 멤버 변수는 동적 할당을 통해 객체지향적으로 객체가 스폰이 될 때마다 사용하게 된다.
- 지역 변수는 멤버 변수처럼 메모리에 중첩적으로 사용되는 변수는 아니다.
- 메모리는 힙 영역과 스택 영역으로 나뉜다.
    - 스택 영역은 불안정하고 임시적으로 사용하는 영역이다.
    - 힙 영역은 안정적이고 프로그래머가 직접 할당하고 해제하는 영역이다.
- 멤버 변수를 만들고, 객체가 생성이 될 때마다 힙 영역에 변수가 써지고, 지역 변수나 매개 변수를 사용하면 스택 영역에 변수가 써진다.
    - 매개 변수라는 것은 함수의 파라미터로서 받는 변수이다.
- 함수 호출이 종료되면 그 변수가 사라져 더이상 유효하지 않게 된다.
    - 즉, 지역 변수는 어차피 함수가 종료되면 반환하니까 메모리를 엄청 아끼겠다고 효율적으로 변수를 만들 필요가 비교적 없다.

## 복사와 참조

- 복사와 참조는 매우 중요한 개념이다.
- 악명높은 C언어의 포인터와 굉장히 밀접한 관련이 있다.
- 두 변수의 값을 변경할 때, 서로를 set해주면 먼저 실행된 쪽의 값이 사라진다.
    - 즉, 이 문제에선 제 3의 변수인 Temp를 생성해 임시 저장을 해주어야 한다.
- 이 로직을 별도의 함수로 만들어보자.
    - 기존의 멤버 변수에 Set이나 Get을 하고싶지만, 함수 안에선 찾을 수 없다.
    - 일단 레퍼런스 변수 설정 (Set by Ref var) 를 사용해 기존의 변수에 다른 값을 넣어준다.
- 함수 내부에서 로직이 완성되어서 출력해보니 분명 값이 잘 바뀌었는데, 함수 바깥으로 다시 돌아와 결국 코드를 전체 실행을 하면 결과가 제대로 반영되지 않는다.
- 플레이어의 HP를 깎는 함수를 만들어서, 실행시켰더니, 함수 내부에선 분명 깎았는데 결론적으론 전혀 값이 변하지 않는 상황들이 일어나게 된다.
- 기본적으로 우리가 알고있는 INT 등의 기본적인 변수 타입은 모두 **복사 타입**으로 동작한다.
- 이러한 변수들을 함수의 파라미터로 주게 되면, **진짜 그 변수가 들어가는 것이 아닌, 그 변수의 값만 복사**되어서 들어가게 된다.
    - 즉, 그 함수 안에서 파라미터 안에 값을 어떻게 조작을 하고 바꾸건 뭘 하건 원본 변수엔 아무런 영향을 주지 않는다.
- 만약 이런 결과를 원치 않고, 진짜로 원본 값에 영향을 주길 원한다면 **참조 타입**으로 전달을 해야 한다.
- 언리얼 함수 블루프린트의 디테일에서 입력 파라미터를 눌러보면 참조전달 (Pass-by-Reference)가 존재한다.
- 이걸 체크할 경우, 변수의 복사값이 아닌, 그 변수의 **메모리 주소값**을 참조해 보내주기 때문에 원본에도 영향을 주게 된다.
- 또한, 비주얼적으로도 노드의 변수 구멍이 동그라미에서 다이아몬드 모양으로 바뀐다.
- 추후에 블루프린트 클래스 등을 만들어 사용하게 될텐데, 얘네들은 **기본적으로 패시브가 참조 타입**이기 때문에, 똑같은 변수인데도 INT 등과는 다르게 동작하게 될 것이다.

## 고급 디버깅

- 단순 디버깅보다 좀 더 기능이 깊다.
- 함수가 다른 함수를 타고, 또 그 함수가 다른 함수를 타고 들어가는 스택이 깊은 구조일 때 유용하다.
- 특정 함수가 버그가 난다고 해서, 해당 함수에서 F9로 브레이크 포인트를 찝어봤자 해당 함수를 호출하는 경우의 수가 매우 많으면 별로 의미가 없을 수 있다.
- 이럴 때 **콜스택(어떻게 해당 함수까지 도달했는지의 현재 스택 구조)** 을 살펴보아야 한다.
- Debug - Blueprint Debugger 에서 블루프린트 디버거를 볼 수 있다.
- 그러면 브레이크 포인트(F9)를 찝어 멈춘 시점에서 현재까지 도달한 콜스택을 볼 수 있다.
- 여기서 다음 포인트로 넘어가는 두 가지 차이 (F10, F11)을 알 수 있다.
    - F10으로 넘어가는 경우엔 현재 블루프린트 페이지에서 함수를 무시하고 다음 노드로 진행.
    - F11로 넘어가는 경우엔 함수를 지나간다면 해당 함수로 이동해 다음 노드로 세부 진행.
- F9, F10, F11과 블루프린트 디버거만을 가지고 웬만한 디버깅이 가능하다.
- 반드시 버그가 있을 때 눈대중으로 찾지 말고 꼭 디버깅을 해서 세부 분석을 하는 것이 좋다.