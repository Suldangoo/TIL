# Part 01 자료구조

- 자료구조란 컴퓨터가 데이터를 효율적으로 다룰 수 있게 도와주는 데이터 보관 방법과 데이터에 관한 연산의 총체를 뜻한다.
    - int와 float같은 단순 자료구조와, 배열, 스택, 그래프같은 복합 자료구조로 구분된다.
    - 복합 자료구조 또한 선형 자료구조와 비선형 자료구조로 구분된다.
- 추상 데이터 형식 (Abstract Data Types) 은 자료구조가 갖춰야 할 일련의 연산들이며, 어떠한 자료구조의 정의와 연산만을 제공하며 그 디테일한 구현 방식은 알려줄 필요가 없는 다양한 자료구조의 혼합체이다.
    - 예를 들어 ADT는 특정 위치에 접근하거나, 뒤에 추가, 중간에 삽입 / 삭제같은 연산을 제공한다.
- 알고리즘이란 어떤 문제를 풀기 위한 단계적 절차이다.
- 알고리즘에 입력을 넣으면, 그 입력값에 따라 다양한 형태의 논리가 돌아가고, 무언가를 출력하게 된다.
- C언어에서 코드를 컴파일하면 실행파일이 만들어지고, 그 파일을 실행하면 메모리 레이아웃이 형성된다. 가장 밑에 텍스트와 데이터의 정적 메모리가 할당되고, 그 위의 모든 공간은 위에서부터 밑으로 스택, 밑에서부터 위로 힙이 차지한다. 힙을 자유 저장소, 스택을 자동 메모리라고도 부른다.
    - 스택은 알아서 데이터를 추가하고 삭제하며 스스로 관리가 된다.
    - 힙은 마음대로 데이터를 할당할 수 있지만, 그만큼 데이터를 다 썼다면 다시 할당을 해제해주어야 한다. 해제를 해주지 않는다면 영구적으로 메모리를 차지하게 된다.
        - 이 명령어는 각각 malloc(), free()이다.

# Chapter 01 : 리스트

## 리스트의 개념

- 리스트 ADT는 목록 형태로 이루어진 데이터며, 개별 요소를 노드라고 부른다.
- 첫 번째 노드를 헤드, 마지막 노드를 테일이라고 한다.
- 리스트에 노드를 추가하거나, 삽입하거나, 제거하거나, 반환하는 연산이 있다.
- 배열은 지정한 시점에서 크기를 지정해주고 더 이상 크기를 바꿀 수 없지만, 리스트는 유연하게 크기를 바꿀 수 있다.

## 연결 리스트

- 노드와 노드들을 연결해 만든 연결 리스트는 한 노드가 다음 노드에 대한 포인터를 가지고 있다.
- 노드 중간에 데이터를 추가하고 삭제하는 것이 매우 쉽다.
- 연결 리스트의 노드를 생성하는 공간에 자동 메모리는 적합하지 않는다. return할 때 자동 메모리의 특성상 이미 제거된 메모리를 참조하기 때문에 어떤 에러를 야기할지 모른다.
- 즉 자유 메모리에 새 노드를 만들 땐 malloc(), 노드를 반환할 땐 free()를 사용하여 SLL을 구현한다.
- 그러나 연결 리스트는 탐색에서 큰 단점을 가진다. 배열은 특정 주소에 O(1)의 시간 복잡도로 접근이 가능하지만, 연결리스트는 모든 노드를 전부 순회하며 노드를 탐색해야 한다.

### 연결 리스트의 장단점

- 단점
    - 다음 노드를 가리키려는 포인터 때문에 각 노드마다 추가적인 메모리가 필요하다.
    - 특정 노드에 접근하기까지 비용과 시간이 매우 크다.
- 장점
    - 새로운 노드의 추가, 삽입, 삭제가 쉽고 빠르다.
    - 현재 노드의 다음 노드를 얻어오는 연산에 대해선 비용이 발생하지 않는다.

## 이중 연결 리스트

- 연결 리스트의 탐색 기능을 개선한 자료구조로, 기존 연결 리스트는 헤드에서 테일 방향으로만 탐색이 진행 가능했지만 이중 연결 리스트는 포인터 변수를 두 개 가지고 양방향으로 탐색이 가능한 자료구조이다.
- 노드를 도중에 추가할 때, 이전 노드의 다음 노드 주소와, 다음 노드의 이전 노드 주소를 모두 수정해주어야 한다.

## 환형 연결 리스트

- 테일의 다음 노드가 헤드를 가리키고, 헤드의 이전 노드가 테일을 가리키는 원형 형태의 연결 리스트이다.
- 즉 테일에 접근하는 비용이 거의 없는 것이나 다름없을 정도로 끝을 빠르게 알 수 있어서 끝 노드에 새로운 노드를 추가하는 연산의 비용이 획기적으로 개선된다.
- 기존의 노드 추가 연산은 테일로 이동하여 추가하는 것이지만, 환형 연결 리스트에선 테일과 헤드 사이에 새 노드를 삽입하면 그만이다.

<aside>
💡

1. 삽입, 삭제, 탐색을 연결 리스트와 배열의 성능을 비교하며 설명하시오.

연결 리스트는 삽입과 삭제가 매우 빠르고 쉽지만, 탐색이 모든 노드를 순회해야 해서 느리다.
그러나 배열은 탐색이 매우 빠르지만, 삽입과 삭제가 뒤의 모든 데이터를 하나씩 옮기는 작업이 필요해서 느리다.
</aside>

<aside>
💡

1. 환형 링크드 리스트가 아닌 링크드 리스트에서 테일 노드의 위치를 바로 아는 방법은?

리스트의 구조체에 테일 노드의 주소를 저장하는 변수 하나를 추가해서,
테일 노드가 변경될 때마다 해당 변수에 테일 노드의 주소를 저장한다.
</aside>

<aside>
💡

1. 노드의 개수를 알아낼 때 N개의 노드를 전부 순환하는 것이 아닌, 즉시 크기를 알아내는 방법은?

리스트의 구조체에 size 변수를 하나 두고, 노드를 삽입할 때 size를 증가, 삭제할 때 감소시키면 된다. 이 경우 해당 리스트가 비어있는지도 size를 통해 바로 알 수 있다.
</aside>

<aside>
🎮

단일 연결 리스트는 비슷한 오브젝트간의 연결을 구현할 때 주로 사용된다. 빠른 삽입과 삭제가 가능하지만, 탐색은 할 필요가 없는 예시 중에선 오브젝트 풀링이 있다.
슈팅 게임 등에서의 모든 탄막 오브젝트를 연결 리스트에 담아 맵 밖으로 나간 탄막은 삭제, 새로 추가된 탄막은 삽입하여 모든 오브젝트를 쉽게 관리하는 감독 자료구조로 사용할 수 있다.
또한 삭제된 탄막은 삭제가 아닌, 테일에 새로 삽입하는 방식으로 풀링을 할 수도 있다.
거기에 더불어 순차적으로 진행되는 연계 퀘스트를 저장해두는 자료구조에서도 연결 리스트를 사용할 수 있다.

이중 연결 리스트는 양방향으로 탐색이 가능하기 때문에, 좌우로 이동하는 모든 인터페이스에서 유용하게 사용되는데, 특히 인벤토리나 UI 메뉴 시스템에서 주로 사용된다.

환형 연결 리스트는 턴제 게임의 페이즈에서 정말 자주 사용된다. 특히 TCG게임 장르의 경우, 드로우 페이즈, 메인 페이즈, 배틀 페이즈, 엔드 페이즈 등 자신의 턴이 끝나면 바로 다음 턴의 드로우 페이즈로 이동하는 경우가 있다. 지금이 어떤 턴인지 관리하는 부분에서 환형 연결 리스트를 사용하면 매우 편리하다.
또한 이중 연결 리스트와 마찬가지로, UI 메뉴에서 가장 오른쪽으로 도달하면 다시 왼쪽의 첫 번째로 갈 수 있는 방식으로도 사용 가능하다.

보통 게임에서 연결 리스트를 쓸 땐 이중 연결 리스트가 가장 많이 사용되는데, 이는 좌우로 이동해야 하는 인벤토리, 애니메이션 트랜지션, UI 메뉴 네비게이션 등에서 주로 사용되기 때문이다.

</aside>

# Chapter 02 : 스택

## 스택의 개념

- 스택은 반드시 꼭대기에서만 무언가 작업이 이루어지는 자료구조이며, 데이터의 추가, 반환, 입/출력 규칙이 스택의 끝부분에서만 이루어진다.
- 스택은 가장 마지막에 들어간 데이터가 먼저 나오고(LIFO), 가장 먼저 들어간 데이터가 나중에 나온다(FILO).
- 스택 ADT의 연산은 삽입(Push)과 삭제(Pop) 연산 두 가지 뿐이다. 그 외의 기능은 이 두 연산을 보조하는 기능에 지나지 않는다.

## 배열 기반 스택

- 배열 기반 스택은 구현이 간단하지만 용량을 동적으로 변경하는 비용이 크다는 단점이 있다.
- 배열 기반 스택은 구조체에 용량, 최상위 노드의 위치, 노드 배열 필드를 가지고 있어야 한다.
- 자유 저장소에 노드 배열을 할당하고, Nodes 필드가 자유 저장소 배열의 첫 번째 요소를 가리킨다.
- Capacity 변수는 해당 스택이 담을 수 있는 총 용량 변수이다.
- Top 변수는 초기엔 -1로 초기화한다. 첨자가 0인 것은 첫 번째 주소를 가리키는 형태이기 때문이다.
- 노드 삽입 연산은 Top에 1을 더한 곳에 새 노드를 입력하도록 구현하며, 제거는 Top 노드를 하나 낮추면 된다.

## 링크드 리스트 기반 스택

- 배열 기반 스택보다 좋은 점은 용량에 제한을 두지 않아도 된다는 것이다.
- 단, 배열과 달리 인덱스를 활용해 노드에 접근할 수 없으므로, 링크드 리스트는 자신의 위에 위치하느 노드에 대한 포인터를 갖고 있어야 한다.
- 즉 Capacity 변수는 필요가 없으며, Top 포인터만 가지고 있으면 된다. Top 포인터도 솔직히 필요는 없으나, 매번 삽입과 삭제를 할 때 마지막 데이터까지 순차 탐색을 해야하기에 보유하는 편이 훨씬 성능이 좋다.

## 스택을 활용한 사칙 연산

- 우리는 중위 표기법을 사용해 식을 계산하지만, 컴퓨터는 스택으로 사칙연산을 계산하기 때문에, 후위 표기법을 사용하여 (연산자가 숫자의 뒤에 오는) 계산한다.
- 이렇게 되면 숫자를 스택에 담고, 스택에 담겨있는 숫자를 바탕으로 새로 입력된 것이 연산자라면 해당 연산자를 통해 위 두 개의 숫자를 연산하고 그걸 최상위 노드로 대체하면 된다.
- 또한 중위 표기식을 후위 표기식으로 변환하는 알고리즘도 존재한다.
    - 토큰을 읽고 피연산자라면 토큰을 결과에 출력, 연산자라면 최상위 노드에 담긴 연산자보다 우선순위가 높은지 검사한 후, 출력하거나 스택에 삽입한다.