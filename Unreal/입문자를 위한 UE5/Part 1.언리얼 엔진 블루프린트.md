# Part 1. 언리얼 엔진 블루프린트

# 개요

- 블루프린트는 언리얼 엔진에서 제공하는 기본적인 비주얼 스크립팅 툴
- 블루프린팅을 하면 간단한 기능을 손쉽게 구현하거나 프로토타입을 만들기 쉽고, UI나 애니메이션 등 일부분은 C++보다 오히려 유리하다.

## 환경설정

- 언리얼 엔진을 가동하면 언리얼 프로젝트 브라우저가 나타난다.
- 게임 - 기본(Black) 로 개발 스타트, 블루프린트 설정
- 데스크탑 / 맥시멈 / 시작 콘텐츠는 없이 시작
    - 시작 콘텐츠는 간단한 에셋과 메테리얼이 들어가있는 상태로 시작
- 창 - 레이아웃 불러오기 - UE4 클래식 레이아웃으로 설정
- Ctrl + N 으로 뉴 레벨 (새로운 맵) 생성
    - 보통 Basic으로 생성
- 언리얼의 씬과 같이 콘텐츠(Assets) 폴더 내에 Maps라는 폴더를 생성해서 Ctrl + S를 누르면 저장 브라우저가 뜨고, Maps에 저장 가능
- 환경 설정으로 들어가 프로젝트 - 맵 & 모드 - 에디터 시작 맵과 게임 기본 맵을 방금 만든 DevMap으로 설정
- 게임 프로젝트가 생성되었고, 프로젝트 경로에 .uproject 파일로 남아있음

## 언리얼 엔진 기초

- 뷰포트 : 유니티의 게임 씬. 에셋들이 배치되어 있는 게임 공간
    - 우클릭을 한 상태로 WASD로 키보드 / 마우스로 조작이 가능
    - Q, E를 눌러 위 아래로도 업다운이 가능
    - QWER을 통해 물체를 잡고, 회전하고, 키우는 조작이 가능 (유니티와 동일)
    - 사물을 선택한 채 End 키를 눌러 땅에 붙이기
    - 사물을 선택한 채 F 키를 눌러 포커싱하기
- 컨텐츠 브라우저 : 유니티의 에셋. 소스 코드나 파일 등 준비물을 보관
- 액터 배치 : 언리얼에서 자체적으로 만들어준 기본 에셋들
    - 조명, 도형, 다양한 기능들
    - 리스트에서 원하는 것을 집어 뷰 포트로 드래그하여 소환 가능
- 아웃라이너 : 유니티의 하이어라키. 맵에 배치된 모든 오브젝트가 보여짐
    - 조명같은 생성하지 않은 오브젝트도 눈 모양을 눌러 꺼보면 무엇인지 알게 됨
    - 계층 구조로 이루어져있어 오브젝트의 자식 오브젝트로 두어 하나로 만들 수 있음
- 디테일 패널 : 오브젝트의 세부적인 정보. 인스펙터 창과 유사
- 따로 카메라를 배치하지 않으면, 재생 버튼을 누를 때 보고 있던 화면 그대로 게임 시작
    - 게임을 시작하면 아웃라이너에 카메라 액터를 비롯한 필요한 오브젝트들이 생성됨
    - Shift + F1이나 F8을 눌러 재생 중에 잠시 바깥으로 나올 수 있음

## 블루 프린트

- 윈도우의 왼쪽, 그래프 모양의 아이콘이 블루프린트 메뉴
- ‘레벨 블루프린트 열기’를 눌러 블루프린트를 켤 수 있음
- 나온 창을 잡아 왼쪽 윈도우 탭에 추가할 수 있음
- 레벨 블루프린트는 쉽게 말해 해당 맵(씬)에서의 블루프린트
    - 레벨을 하나 만들 때마다 하나씩 딸려 만들어짐
    - 레벨당 하나씩 짝이 있어서, 다른 레벨을 만들면 또 새로 작성을 해주어야 함
- 블루프린트에 노드를 추가하고, 작업을 했다면 꼭 컴파일 - 세이브
- 이벤트 : 어떤 상황에서 호출 될 것이라는 트리거
    - BeginPlay 이벤트 (트리거) : 게임이 실행될 때 딱 한 번만 호출되는 이벤트
    - 틱 이벤트 : 게임 실행 도중 매 프레임마다 계속 호출되는 이벤트
    - 이벤트는 약속된 시기에 나오는 것들이 아주 많이 있으며, 직접 만들 수도 있음.
    - 키보드 1을 검색하면, 1 버튼을 누를 때마다 호출되는 이벤트가 생성됨
- 조작
    - 우클릭으로 이동, 휠로 확대 축소, 좌클릭으로 선택 및 드래그
    - Ctrl + C, V, D로 복사 붙여넣기가 가능
    - 노드간의 선을 더블클릭하여 선을 두개로 분리하거나, 원하는대로 휘게 할 수 있음
    - 선이 연결된 화살표를 우클릭하여 연결된 선을 모두 끊을 수 있음
        - Alt + 좌클릭
    - 이미 연결된 선을 다른 노드로 옮기고싶다면 Ctrl + 좌클릭으로 드래그
    - 원하는 노드들을 전부 선택한 후 Q를 누르면 일렬로 정리가 됨
- 원하는 블루프린트들을 드래그해서 C를 누르면 주석을 입력할 수 있음

# 변수

## 변수 타입

- 그 어떠한 게임, 프로그램들도 모두 데이터와 로직으로 구성되어 있음.
- 데이터와 로직 두 가지를 정복할 수 있다면 세상의 모든 프로그램을 만들 수 있음.
- 블루프린트 창에서 왼쪽에 변수(Variables)에 +를 눌러 새로운 변수를 생성
- 오른쪽 기본값에 변수의 기본 초기화값을 설정할 수 있게 됨
- 변수를 만들 땐 이름과 타입을 골라주어야 함
    - 언리얼에선 앞 글자가 대문자인 것으로 변수 이름을 짓는 것이 일반적이다. (컨벤션)
    - 부울(Boolean) : True, False 두 가지의 형태가 존재 가능한 변수
        - 불리언 변수는 이 변수가 불리언이란걸 나타내기 위해 변수 이름 앞에 소문자 b를 붙이기도 한다. (ex : bSound)
        - 그렇게 되면 우측 초기값에서도 앞 소문자 b는 무시하고 이름을 출력해준다.
    - 바이트(byte) : 정수형, 0~255로 크기가 작음 (커스터마이징 수치)
    - 인티저(integer) : 정수형, -21억 ~ 21억
    - 인티저64(integer64) : 정수형, 굉장히 크기가 큼
    - 플로트(float) : 실수형, 부동소수. 3.14
    - 네임(Name) : 문자열, 언리얼 내부에서 사용하며, 절대 바뀌지 않고, 빠르게 검색 가능
        - 해시를 사용해서 매우 빠르게 검색 가능하며 용량이 적음
    - 스트링(String) : 문자열, 일반적인 상황에 변화가 있고, 딱히 다국어 변환이 필요 없을때
    - 텍스트(Text) : 문자열, 깃발 아이콘과 함께 로컬라이징 기능을 제공
        - 다른 언어로 번역이 된다면 텍스트가 변환이 될 때 사용
        - Tools - 로컬리세션 (현지화) 대시보드에서 여러 언어를 추가할 수 있음

## Get, Set

- 메모리에 할당된 변수에 특정 값을 쓰는 것을 Set
- 메모리의 변수에 쓰여있는 값을 읽어오는 것을 Get
- 블루프린트 노드로 <Set 변수명>, <Get 변수명> 을 사용한다.
- Set 노드를 사용하면 원하는 값을 직접 입력할 수 있고, Get 노드를 사용하면 읽어온 값을 다른 노드에 연결할 수 있다.
- Get 노드를 가져와 Print Text 노드에 연결하면, 자동으로 int를 Text로 캐스팅해주는 노드도 생겨난다.
- Set 노드의 아웃풋도 설정한 값을 그대로 출력해주는 거라서, 즉시 Get을 할 것이라면 Set노드의 아웃풋을 바로 연결해도 무관하다.
- 굳이 Get, Set 노드를 찾아서 꺼내지 않아도, 왼쪽 변수에서 드래그해서 가져올 수도 있다.
    - Ctrl + 드래그 시 Get 노드가 불러와진다.
    - Alt + 드래그 시 Set 노드가 불러와진다.

## 사칙연산

- 노드에 단순한 덧셈 / 뺄셈 / 곱셈 / 나눗셈 노드가 존재한다.
- 노드 검색에 ‘+’ 만 입력해도 바로 나온다.
- 왼쪽에 두 개 이상의 노드를 연결하면, 두 노드에 연산을 한 후 오른쪽으로 배출하는 형태이다.
- 왼쪽 노드 연결 점(핀, Pin)을 우클릭하고 원하는 형태의 타입으로 변경할 수 있다.
    - 물론, 굳이 일일이 설정하지 않아도 원하는 변수를 연결하면 알아서 변경된다.
- 나머지는 평범하나, 나눗셈은 조금 주의해야 한다.
    - 절대로 어떤 수를 0으로 나눌 수 없다. 그나마 언리얼은 0으로 나눈 값을 0으로 잡아준다.
    - 인티저끼리의 나눗셈을 한다고 그 결과가 부동소수가 되지 않는다.
    - 즉, float로 핀을 설정해주고 나눗셈을 해야 정확한 결과가 나온다.
    - 물론 둘 중 하나만 float로 해두면 float가 더 우선순위가 높아 소수점이 유지된다.
    - 만약 int끼리 나눗셈을 하고 싶다면, 일시적으로 float 형태로 캐스팅을 해주어야 한다.
        - To Float라는 Conversions 노드를 통과해야 함

### 단축연산

- 굳이 사칙연산을 쓰지 않아도, ++나 --는 별도의 노드가 존재한다.

## 비교연산

- 두 숫자 중 무엇이 더 크고 작은지 판별하는 노드가 존재한다.
- 노드 검색에 ‘<’ ‘>’ ‘≤’ ‘≥’ ‘==’ ‘!=’ 를 검색해 얻을 수 있다.
- 그 결괏값에 따라 출력으로 True 혹은 False를 리턴한다.
- 결괏값을 어떤 Boolean 변수에 할당할 수 있다.
    - 직접 변수를 새로 만들어서 Set 노드를 만들고, 할당할 수 있다.
    - 그러나 일일이 그렇게 하지 않고, 출력 선을 끌고 온 뒤 ‘변수로 승격’을 누르면 새 변수가 만들어진다.

### 포맷 텍스트

- Format Text(포맷 텍스트)는 어떤 문자열에 변수 값을 대입해야 할 때 사용하는 노드이다.
- 원하는 문장을 입력하고, 변수값을 넣고싶은 부분에 {0}를 입력하고 엔터를 누르면 핀이 나온다.
    - 0은 그저 파라메터 값을 의미하고, {Count}처럼 이름을 지정해줘도 좋다.

## 디버깅

- 값을 테스트할 때 print text를 마구 뿌려서 디버깅을 할 수도 있지만 옳은 방법이 아님
- 그럴때 사용하는 것이 바로 디버깅 기능
- 원하는 노드에 F9를 찍으면 빨간 동그라미가 생성되며 브레이크 포인트가 찍힘
    - 실행해나가다가 브레이크 포인트에서 실행이 멈춤
    - 메모리에 적재된 변수들의 값도 바로바로 확인이 가능
- F10을 누르면 다음 노드로 넘어가게 됨
- 반드시 에러가 떴을 때 디버깅을 해야 변수값을 추적하며 손쉽게 수정이 가능함

## 논리연산

- AND Boolean / OR Boolean / NOT Boolean 등등 여러 논리 연산자가 존재한다.
- 꼭 뒤에 Boolean을 붙여야 검색이 가능하다.
- Add Pin을 통해 3개 이상의 조건을 동시에 측정할 수도 있다.

# 흐름 제어

- 어떤 조건이나 상황에 따라 코드가 특정 방향으로 흐르게 하는 것
- 크게 **분기문**과 **반복문** 두 가지로 구분이 가능하다.

## Branch, Sequence, Flip Flop

### 브랜치

- 앞에 불리언이 들어갔을 때 참과 거짓에 따라 분기가 일어나는 것
- 값이 True냐, False냐에 따라 분기를 만들어주는 노드
- 굉장히 중요한 노드라서 단축키 ‘B’를 누르고 좌클릭을 하면 바로 생성된다.
- if - else문 대신 존재하는 분기문이다.

### 시퀀스

- 노드가 진행됨에 따라 Then 0을 모두 실행하고, 실행이 끝나면 Then 1을 모두 실행하는 방식으로 반복이 일어나는 노드이다.
- 단축키 ‘S’를 누르고 좌클릭을 하면 바로 생성된다.
- 코드 정리 차원에서 매우 유용하게 사용할 수 있다.

### 플립 플랍

- A → B → A → B → … 하는 방식으로 길이 바뀌는 노드이다.
- 로직 회로가 여러 번 실행될 때, 처음엔 A가 실행되었다가 다음엔 B가 실행되었다가 하는 방식으로 기찻길이 바뀌는 것과 유사하다. (혹은 전등 스위치)
- Is A는 현재 실행하고 있는게 A인지 B인지를 나타내주는 불리언 출력이다.

## Min, Max, Clamp

- Min, Max 둘 다 파이썬과 유니티에도 존재하는 함수
- 두 인자로 넣은 값 중 더 크거나 작은 것을 리턴한다.
- Clamp는 Min과  Max 두 함수를 합쳐놓은 개념
    - 정해진 값을 Min보다 작아지지 않게, Max보다 커지지 않게 막아주는 함수
    - Clamp는 경계를 포함해서 리턴한다.

## For Loop, While Loop

- For Loop, While Loop 둘 다 노드로서 존재하는 반복문
- While Loop
    - 컨디션이 참이라면 반복하다가 거짓이 되면 빠져나오는 노드
    - 무한 루프가 실행되면 에러가 터짐
- For Loop, For Loop with Break
    - First Index에서 Last Index까지 인덱스에 변화를 주며 반복
    - First Index에서 1씩 더해가는데, 인덱스를 모두 포함하기 때문에 0부터 5까지 했다면 0과 5를 포함하여 (마지막 값을 포함) 반복 후 벗어나게 된다
    - 도중 빠져나오고 싶을 때 break가 포함된 노드를 사용
    - 앞 진행 사항 도중 break로 진행 선을 뒤로 연결해주면 됨
        - 선 정리할 때 더블클릭으로 포인트 생성 후 컨트롤 클릭으로 정리

## Gate, MultiGate, Do Once, Do N

### Gate

- 마치 성문같은 노드
- Start Closed가 체크되어 있다면 더 이상 진행되지 않고, 체크가  해제되어 있다면 진행된다.
- Enter로 흐름이 왔을 때 현재 컨디션에 따라 Exit로 보낼지 말지 결정
- Open으로 흐름이 들어오면 Closed가 열린다
- Close로 흐름이 들어오면 Closed가 닫힌다
- Toggle로 흐름이 들어오면 현재 Closed의 상태가 반대로 변한다

### MultiGate

- 출구를 여러 개 둘 수 있는 게이트 노드이다
- 한번 Enter될 때마다 매번 출구가 하나씩 바뀌게 된다
- 최종적으로 다 실행했다면 더 이상 출구가 없어 실행 흐름이 막힌다
- Start Index를 설정해 시작하는 출구를 정할 수 있다
- Loop를 켜면 끝까지 다 진행된 뒤 다시 처음으로 돌아가게 된다
- is Random을 켜면 출구 순서가 랜덤으로 변한다
- Reset 흐름을 켜버리면 닫힌 모든 문들이 열리며 초기화된다
- NPC가 매번마다 랜덤한 대화를 출력할 때 매우 효과적이다

### Do Once

- 한 번만 실행을 시켜주는 노드이다.
- 한 번 엔터가 되면 컴플리티드로 실행이 되는데, 그 이후론 막혀버린다.
- Reset으로 흐름을 작동하면 다시 열리게 된다.
- 게이트보다 좀 더 기능이 축소된 노드이다.

### Do N

- N번만 실행을 통과시켜 주는 노드이다.
- 첫 실행 시 1로 시작하는 것부터 N까지 실행되는 카운터 변수를 사용할 수 있다.
- Reset으로 흐름을 작동하면 다시 열리게 된다.
- For Loop와 유사하다.

## Enum

- 플레이어의 상태에 따라 그에 맞는 애니메이션을 틀어주어야 함
- 즉, 상태라는 것을 관리해야 함
- 변수 하나를 만들어 0이면 Idle, 1이면 공격… 이런식으로 하드코딩은 좋지 않음
- 이럴 때 열거형을 사용해야 하며, Enum이 존재함.
- 열거형 블루프린트 파일을 만들 때 이름 앞에 E를 붙이는 것이 일반적
- 들어가서 이너머레이터 추가 (혹은 Add Enumerator) 로 여러 상태를 생성 가능
- 디스플레이 이름에 원하는 상태인 Idle, Moving 등을 넣어주면 그것이 하나의 타입이 됨
- 이후 변수를 생성해서 아까 만들어두었던 Enum 파일의 이름을 검색
- 변수를 만든다음 디테일을 보면, 기본값에서 정수형이 아닌 원하는 타입들이 선택 가능하게 됨
- 기존 변수에선 비교연산자로 ==를 사용했으나, Enum에선 Equal(Enum)을 사용해야 함
- 그러나 색상을 보면 byte와 색상이 같은데, 엔진 내부적으로는 구조가 다를 바가 없기 때문
- 바이트를 열거형으로 바꾸는 노드가 존재
- 열거형을 이용하면 상황에 따라 분기를 하고 싶을 때, branch를 써도 되지만 switch라는 좋은 분기문이 있다.
    - 한글로는 E~ 켜기
    - switch를 사용하면 정말 단순하게 현재 상태에 따라 어떤 분기를 가게 될지 간단하게 설정 가능
- 무언가 원하는 이벤트를 작동시키고 싶을 때, 커스텀 이벤트를 생성 가능

# 함수

## 함수 기초

- 항상 사용하던 get, set, print text들이 모두 언리얼에 있는 기본 내장함수
- 블루프린트 왼쪽 메뉴에서 Functions의 +를 클릭해 직접 함수를 만들 수 있다.
    - 그러나 이 기능은 엄밀히 말하면 C++의 멤버 함수
    - 일단 일반 함수로 진행한 뒤 객체지향을 공부할 때 쓸 것
- 블루프린트에선 우클릭 - 블루프린트에서 블루프린트 함수 라이브러리
- 이것이 C++에서 말하는 정적 함수 (스태틱 함수)
- 여기서 만들어진 함수는 다른 블루프린트에서 노드로 만들어 정의된 내용의 함수를 언제든 호출 가능
- 함수에서 오른쪽 디테일을 보면 입력과 출력을 확인할 수 있고, 추가할 수 있다.
    - 입력을 추가하면 다른 블루프린트에서 함수를 호출할 때 입력값을 넣을 수 있다.
    - 출력을 추가하면 출력 반환 노드가 생기고, 원하는 값을 함수 안에서 넣어줄 수 있다.
    - 우리가 항상 쓰던 노드들과 마찬가지로, 왼쪽의 구멍과 오른쪽의 구멍이 생긴 것을 알 수 있다.
- 추후 프로젝트의 규모가 커지면 함수 단위로 코드를 짜야 코드의 양이 많아지지 않는다.
- 만약 프로젝트 내에서 한 번밖에 쓰지 않을 명령어 집합이 있다면 굳이 함수로 만들지 않는 것이 성능은 더 좋지만, 두 번 이상 쓰게 될 것이라면 함수로 만들어 코드의 가독성을 높이는 것이 훨씬 좋다.
  
## 로컬 변수

- 함수 블루프린트 라이브러리 내에서 왼쪽 목록에서 함수들을 고를 수 있다.
- 또한, 그 아래에서 로컬 변수 (Local Variables)를 관리할 수 있다.
- 이 변수는 지역 변수로, 기존 레벨 블루프린트에서 만든 변수들은 멤버 변수에 해당한다.
- 이 지역 변수는 해당 함수 안에서만 사용하는 변수로, 함수 밖에서는 효력이 없는 함수이다.
    - 즉, 그 함수 라이브러리 안에서라도 다른 함수라면 지역 변수가 사라진다.
    - 해당 변수 안에서만 임시로 쓰는 변수이다.
    - 또한 이 변수는 함수에 종속적이어서, 변수를 만들었다고 바로 메모리를 차지하는 것이 아닌, 함수가 호출될 때 메모리에 적재된다.
- 예전에 만든 멤버 변수는 동적 할당을 통해 객체지향적으로 객체가 스폰이 될 때마다 사용하게 된다.
- 지역 변수는 멤버 변수처럼 메모리에 중첩적으로 사용되는 변수는 아니다.
- 메모리는 힙 영역과 스택 영역으로 나뉜다.
    - 스택 영역은 불안정하고 임시적으로 사용하는 영역이다.
    - 힙 영역은 안정적이고 프로그래머가 직접 할당하고 해제하는 영역이다.
- 멤버 변수를 만들고, 객체가 생성이 될 때마다 힙 영역에 변수가 써지고, 지역 변수나 매개 변수를 사용하면 스택 영역에 변수가 써진다.
    - 매개 변수라는 것은 함수의 파라미터로서 받는 변수이다.
- 함수 호출이 종료되면 그 변수가 사라져 더이상 유효하지 않게 된다.
    - 즉, 지역 변수는 어차피 함수가 종료되면 반환하니까 메모리를 엄청 아끼겠다고 효율적으로 변수를 만들 필요가 비교적 없다.

## 복사와 참조

- 복사와 참조는 매우 중요한 개념이다.
- 악명높은 C언어의 포인터와 굉장히 밀접한 관련이 있다.
- 두 변수의 값을 변경할 때, 서로를 set해주면 먼저 실행된 쪽의 값이 사라진다.
    - 즉, 이 문제에선 제 3의 변수인 Temp를 생성해 임시 저장을 해주어야 한다.
- 이 로직을 별도의 함수로 만들어보자.
    - 기존의 멤버 변수에 Set이나 Get을 하고싶지만, 함수 안에선 찾을 수 없다.
    - 일단 레퍼런스 변수 설정 (Set by Ref var) 를 사용해 기존의 변수에 다른 값을 넣어준다.
- 함수 내부에서 로직이 완성되어서 출력해보니 분명 값이 잘 바뀌었는데, 함수 바깥으로 다시 돌아와 결국 코드를 전체 실행을 하면 결과가 제대로 반영되지 않는다.
- 플레이어의 HP를 깎는 함수를 만들어서, 실행시켰더니, 함수 내부에선 분명 깎았는데 결론적으론 전혀 값이 변하지 않는 상황들이 일어나게 된다.
- 기본적으로 우리가 알고있는 INT 등의 기본적인 변수 타입은 모두 **복사 타입**으로 동작한다.
- 이러한 변수들을 함수의 파라미터로 주게 되면, **진짜 그 변수가 들어가는 것이 아닌, 그 변수의 값만 복사**되어서 들어가게 된다.
    - 즉, 그 함수 안에서 파라미터 안에 값을 어떻게 조작을 하고 바꾸건 뭘 하건 원본 변수엔 아무런 영향을 주지 않는다.
- 만약 이런 결과를 원치 않고, 진짜로 원본 값에 영향을 주길 원한다면 **참조 타입**으로 전달을 해야 한다.
- 언리얼 함수 블루프린트의 디테일에서 입력 파라미터를 눌러보면 참조전달 (Pass-by-Reference)가 존재한다.
- 이걸 체크할 경우, 변수의 복사값이 아닌, 그 변수의 **메모리 주소값**을 참조해 보내주기 때문에 원본에도 영향을 주게 된다.
- 또한, 비주얼적으로도 노드의 변수 구멍이 동그라미에서 다이아몬드 모양으로 바뀐다.
- 추후에 블루프린트 클래스 등을 만들어 사용하게 될텐데, 얘네들은 **기본적으로 패시브가 참조 타입**이기 때문에, 똑같은 변수인데도 INT 등과는 다르게 동작하게 될 것이다.

## 고급 디버깅

- 단순 디버깅보다 좀 더 기능이 깊다.
- 함수가 다른 함수를 타고, 또 그 함수가 다른 함수를 타고 들어가는 스택이 깊은 구조일 때 유용하다.
- 특정 함수가 버그가 난다고 해서, 해당 함수에서 F9로 브레이크 포인트를 찝어봤자 해당 함수를 호출하는 경우의 수가 매우 많으면 별로 의미가 없을 수 있다.
- 이럴 때 **콜스택(어떻게 해당 함수까지 도달했는지의 현재 스택 구조)** 을 살펴보아야 한다.
- Debug - Blueprint Debugger 에서 블루프린트 디버거를 볼 수 있다.
- 그러면 브레이크 포인트(F9)를 찝어 멈춘 시점에서 현재까지 도달한 콜스택을 볼 수 있다.
- 여기서 다음 포인트로 넘어가는 두 가지 차이 (F10, F11)을 알 수 있다.
    - F10으로 넘어가는 경우엔 현재 블루프린트 페이지에서 함수를 무시하고 다음 노드로 진행.
    - F11로 넘어가는 경우엔 함수를 지나간다면 해당 함수로 이동해 다음 노드로 세부 진행.
- F9, F10, F11과 블루프린트 디버거만을 가지고 웬만한 디버깅이 가능하다.
- 반드시 버그가 있을 때 눈대중으로 찾지 말고 꼭 디버깅을 해서 세부 분석을 하는 것이 좋다.

# 자료구조

## 동적 배열 이론

- 선형 자료구조 : 배열, 연결 리스트, 스택, 큐
- 비선형 자료구조 : 트리, 그래프
- 동적 배열
    - 일반 배열은 용량을 미리 고정해서 정하는 것. 그 크기를 절대 변경할 수 없음.
    - 주소가 연속되어있다는 장점이 있으나, 크기를 확장, 축소하는 것이 불가능.
    - 이 단점이 극복된 것이 동적 배열이며, 크기를 유동적으로 지정할 수 있음.
    - 연속된 주소로 배정받을 수 있고, 유동적이다. 그러나 중간 삽입/삭제가 어렵다.
    - 단, 기존 데이터들도 모두 함께 확장된 곳으로 넘어가기 때문에 데이터를 옮기는 비용이 발생한다.
- 동적 배열 할당 정책 : 실제 사용할 크기보다 많이, 여유분을 두고 할당하고, 이사를 최소화.
- 언리얼에서 사용하는 배열은 동적 배열이기 때문에, 크기를 어렵게 처음에 정할 필요가 없음.

## Array

- 언리얼에서 변수를 추가하고, 타입을 인티저로 둔 뒤, 디테일에서 타입 옆 아이콘 클릭.
- 기본(Single)이 아닌, 배열(Array) 타입으로 변경하면 동적 배열로 변환된다.
- 이 변수의 디테일 밸류를 보면, 원하는 요소만큼 +를 눌러 값을 할당할 수 있다.
- 블루프린트 노드에 유틸리티 - Array 탭에서 배열과 관련된 노드들을 많이 볼 수 있다.

### 배열 Get

- 배열의 Get에는 복사 타입과 참조 타입 두 가지 방식이 존재한다.
    - 일반적으로는 원본을 건드리는 참조 타입이 아닌 복사 타입으로 Get한다.
- 배열 Get에는 int의 인자가 하나 들어가는데, 이것은 인덱스를 의미한다.
- 모든 데이터를 순차적으로 출력하고 싶다면 for loop로 인덱스를 돌리면 된다.
- 여기서 for loop에 들어가는 마지막 인덱스는 하드코딩이 아닌, 배열의 크기를 참조하는 것이 훨씬 좋으며, 이는 Length 노드를 배열에 연결함으로서 꺼내올 수 있다.
    - 이 때, Length 노드를 곧바로 연결하는 것이 아닌 **1을 뺀 후**에 연결해야 한다.
- 두 번째 방법으로 for loop가 아닌, Array 전용 반복문인 For Each Loop를 사용하면 더욱 편리하다.
    - 인덱스를 직접 적어줄 필요 없이, 연결된 배열을 알아서 끝까지 순환해준다.
    - Element가 값, Index가 주소 번지를 의미하는 노드이다.

### 배열 Set

- ADD 노드를 써서 원하는 값을 추가할 수 있으며, 이 경우 가장 뒤에 새로운 값이 추가된다.
- ADD Unique 노드를 쓰면 원하는 값을 추가하되, 중복이 있다면 추가하지 않는다.
    - 단, 이 경우 이어붙일 Array가 Set이 아닌 Get으로 해주어야 한다.
- Clear 노드를 써서 배열 내부의 모든 값을 지울 수 있다.
- Contains Item 노드와 Find Item 노드를 써서 배열 내부에서 값을 검색할 수 있다.
    - Contains Item 노드를 사용하면 내가 원하는 값이 있는지 확인, Boolean으로 리턴한다.
    - Find Item 노드를 사용하면 내가 원하는 값이 몇 번지에 있는지 주소값을 리턴한다.
- Resize 노드를 사용하여 연결된 배열의 길이를 지정할 수 있다.
    - 배열을 애초에 사용하기 전에 Resize하는 것이 데이터를 옮길 비용이 없어 좋다.
    - 배열에 아무런 멤버도 추가하지 않고 Resize로 크기를 키울 경우, 빈 칸에는 0이 들어간다.
- 배열의 Set 노드를 사용하면 원하는 인덱스의 값을 원하는 값으로 수정할 수 있다.
    - Size to Fit을 체크하면, 내가 원하는 인덱스의 배열이 없더라도 강제로 배열의 영역을 늘려 새로 할당하게 된다.
- 그 외에도 셔플, 리무브 등 다양한 기능의 노드들이 존재한다.

## 버블 정렬

- 가장 뒤에 큰 것부터 정렬되는, 하나씩 비교하며 옮기는 정렬법.
- 두 개의 for문으로 1차원 배열을 정렬할 수 있음.

## 해시 테이블 이론

- 배열 다음으로 중요한 자료구조는 맵이며, 이를 위해선 해시 테이블에 대해 이해해야 함.
- 배열은 용량이 커질 수록 (천, 만이 넘으면) 탐색이나 수정이 매우매우 어려워짐.
- 맵은 배열과는 다르게 검색이 매우 빠르다.
- 단, 배열보다는 조금 더 메모리를 많이 사용한다.
- 내가 검색하고자 하는 값을 특정 값으로 바꾸어주는, **해시 함수**가 필수적이다.
    - 데이터를 훨씬 단순하게 표현하게 해주는 것이 해시 함수.
    - 데이터를 삽입할 때도, 찾을 때도 해당 데이터를 해싱해서 저장.
- 맵은 해시 테이블 구조이며, 저장하는 값은 **키와 값**으로 이루어져 있다.
- 키와 값을 모두 저장한 테이블을 **해시 테이블**이라고 한다.
    - 무언가 값을 찾을 땐 키를 이용해서 빨리 찾는 것이다.
    - 키를 빠르게 검색하는 것이 보장되기 때문에, 그 값 또한 빠르게 찾을 수 있다.

## Map

- Map 역시 Array처럼 변수를 만들고, 디테일에서 Map 자료구조를 지정할 수 있다.
- 키로 쓸 자료형과 값으로 쓸 자료형을 각각 고를 수 있다.
- 데이터를 추가하는 것은 Array와 같이 ADD 노드로 사용한다.
    - 데이터를 추가할 때 키와 값을 모두 넣어주어야 한다.
    - 여기서, **키값은 반드시 중복 없이 고유**해야 한다.
    - 만약 중복해서 동일한 키 값으로 ADD를 하면, 기존 데이터에 덮어씌워진다.
- 데이터를 삭제하는 것은 REMOVE 노드로, 키 값만 넣어주면 해당 키의 데이터를 삭제한다.
- FIND 노드로 원하는 키 값의 데이터를 빠르게 검색할 수 있다.
    - 리턴값으로 Value와 Boolean 둘 다 존재한다.
    - 예측하듯 찾은 값과 있는지 없는지 유무를 판단하는 리턴값이다.
- CONTAINS 노드를 사용해 해당 맵에 원하는 키가 존재하는지 확인할 수 있다.
    - 여기서 Find와 차이점은, Find는 만약 그 키 데이터를 찾고 없다면 그 데이터를 추가해주기까지 한다. 만약 값이 Int라면 기본값으로 0을 추가해준다.
- isEmpty를 이용해 값이 하나라도 있는지를 확인할 수 있다.
- LENGTH도 있으나, 배열보다는 해시의 길이가 중요한 일은 많이 없다.
- Map에 있는 모든 값을 출력하거나 하고 싶다면, 모든 키나 값을 꺼내야 한다.
    - 이것이 **KEYS, VALUES 노드**이다.
    - 이 두 노드는 특이하게 **리턴값으로 배열을 리턴**한다.

# 객체지향

## 블루프린트 클래스

- 지금까지의 모든 작업은 레벨 블루프린트에서 진행했음.
- 레벨 블루프린트에서 각 플레이어나 몬스터에 기능을 만들면, 정말 맵 상에 있는 모든 오브젝트에 대해 기능을 만들어야 함.
- 여기서 반드시 알아야 할 개념이 ‘클래스’.
- 게임 속 모든 사물들을 객체 단위로 생각하는 것.
- C나 C++이었다면 ‘클래스’라는 설계도를 먼저 만들게 됨.
- 그러나 언리얼의 블루프린트에선, 콘텐츠 브라우저에서 우클릭 - **블루프린트 클래스**를 생성해 만듦.
- 블루프린트 클래스를 처음 만들면 상속에 대한 창이 나온다. 우선 플레이어는 액터이다.
    - 그럼 액터를 상속받는 블루프린트 클래스가 생성된다.
- 블루프린트 클래스에선 뷰포트라는 창이 하나 더 추가되어있음.
    - 해당 블루프린트 클래스의 객체가 어떻게 생겼는지 미리보기를 할 수 있다.
- 블루프린트 클래스는 일종의 오브젝트 설계도.
    - 블루프린트 클래스로 만들어진 객체는, 게임 내에서 똑같은 것을 몇개든 찍어낼 수 있음.
- 블루프린트 클래스에서 Add를 누르고, 원하는 컴포넌트를 삽입할 수 있음.
- 컴포넌트에서 입체 도형을 불러와 해당 클래스의 생김새도 표현할 수 있음.
- 콘텐츠 브라우저에서 만들어진 블루프린트 클래스를 게임 뷰로 이동시키면, 즉석에서 **프리팹**과 같이 오브젝트가 생성됨.
- 이는 프리팹과 동일한 개념이라, 맵에 배치된 수많은 오브젝트들이 블루프린트 클래스 하나만 수정하면 일괄적으로 모두 수정됨.
- 블루프린트 클래스 내부에 있는 **이벤트 그래프**에서 블루프린트를 제작할 수 있다.

## 멤버 변수와 멤버 함수

- 플레이어 클래스에 들어갈 멤버들을 생각한다.
    - 이름, HP, 최대 HP, 공격력, 방어력, 이동속도, 위치좌표 등등… (변수)
    - 이동하기, 멈추기, 공격하기, 방어하기, 회복하기, 대화하기, 사망하기 등등… (함수)
- 클래스의 멤버 변수는 블루프린트 클래스트의 변수 (Variables)에서 만들면 된다.
- SpawnActor로 원하는 액터를 생성하는 노드가 있음.
- 멤버 변수는 함부로 마구 만들면 안되고, 필요한 자료구조만큼 최소한 만들어야 함.
    - 함수 안에서 쓰는 변수는 함수가 실행될 때만 할당됐다가 다시 취소된다.
    - 그러나 해당 클래스를 지닌 객체를 몇 천 마리를 소환하면, 해당 멤버 변수가 몇 천개 할당된다.
    - 단, 멤버 함수는 메모리 차지를 전혀 신경쓰지 않아도 된다.
    - 멤버 함수는 코드 영역에 등록되고, 몇 백 개의 객체가 있더라도 똑같은 함수 하나가 만들어지고 그 함수를 공유해 사용하게 된다.
- 멤버 함수는 함수 (Functions) 에서 생성하면 된다.
    - 이전 함수와 같이 인풋과 아웃풋을 만들 수 있다.
- 멤버 함수가 일반 함수와의 가장 큰 차이점은, **멤버 변수에 접근**해 사용할 수 있다는 것.
    - 기존 일반 함수는 그 어떤 무언가와 연관되어있지 않다.
    - 그러나 멤버 함수는 멤버 변수를 언제든 쓸 수 있다.
    - 클래스로 객체를 만들고, 그 객체에게 해당 행동을 시킨다는 것과 동일하다.
- 타겟을 **Self**로 지정하는 경우가 있다.
    - 보통 일반적으로 어떤 메서드를 실행할 때, **‘어떤 객체한테’** 이 메서드를 명령할까요? 라는 의미로 타겟을 잡게 된다.
    - 이 타겟을 Self로 두면, 자기 자신 스스로의 객체가 그 메서드를 행동하게 된다.

## Is Valid

- 레벨 블루프린트에서 Spawn Actor From Class를 통해 만들어둔 블루프린트 클래스의 객체를 생성하는 노드를 작업할 수 있다.
- Spawn Transform은 필수 인자로, Make Transform 노드를 만들어 연결시켜주면 된다.
- SpawnActor로 스폰한 객체를, 노드에서 선을 끌고와 변수로 승격하면 그 객체를 변수로서 조작할 수 있게 된다.
    - 여기서 만약 변수에 객체를 할당하고, 또 그 선을 그대로 연장해 다른 변수에 할당하게 되면, 이는 **참조의 개념**으로 두 변수가 각각 **동일한 객체**를 가리키게 된다.
- 이는 자바에서 Charactor player = **new** Charactor() 과 같은 개념
- 만약 변수만 만들고 객체를 할당하지 않으면, 내부는 Unknown이 된다 (Null과 같은 의미)
- 이렇게 객체를 할당하지 않은 변수를 조작하면, 당연히 크래시가 난다.
- 그러나, 가끔 게임 로직 상 이렇게 **할당하지 않은 변수를 건드릴 일**이 있을 때가 있다.
    - 아주 좋은 예시로, 주변에 가장 가까이 있는 몬스터를 리턴하는 함수가 있다.
    - 만약 주변에 아무런 몬스터도 없다면? 객체가 할당되지 않은 빈 변수를 리턴하게 되는 것이다.
- 이 때 사용하는, 변수가 객체를 할당하고 있나? 를 체크하는 것이 **Is Valid**
- 우리가 넘겨받은 주소가 유효한지, 유효하지 않은지를 Boolean으로 리턴해준다.
    - 즉, Is Valid 다음에 Branch 넣어주면 이런 상황을 모두 해결할 수 있다.
    - 혹은 Is Valid? 노드를 쓰면 Branch가 내장된 노드로 사용할 수 있다.
- C#이나 C++에서도 이것을 Null 체크라고 한다.

## Player vs Monster

- 규모가 작은 게임이라면 위처럼 레벨 블루프린트에서 해당 객체의 변수를 가져와서 서로에게 데미지를 주는 로직을 만들어도 괜찮음.
- 단, 이건 규모가 작은 게임에서에 한함.
- 플레이어가 공격할 수 있는 대상이 몬스터 1, 몬스터 2, 몬스터 3… 거기에 다양한 오브젝트들까지 많다면, 이런 방식으로는 절대 게임을 만들어나갈 수 없음.
- 각 객체에 해당해는 로직들은, 해당 블루프린트 클래스 내부에 코딩하는 것이 가장 좋다.
- 몬스터 클래스에 함수를 On Damaged라는 함수를 만들고, 인풋 파라미터로 어태커를 만들어준다. 여기서 인풋 파라미터의 자료형은 Player로 우선 해두었다.
- 이후 Is Valid로 꼭 안전하게 체킹을 해주고, 객체가 할당되었다면 로직을 실행하게끔 한다.
- 여기서, **피해자 입장에서 On Damaged**라는 함수를 만드는 것이 아닌, **공격자 입장**에서 **데미지를 주는 함수**를 만드는 것도 당연히 방법이다.
- 그러나 대부분 규모가 큰 게임에서는 이렇게 피해자 쪽에서 처리하는 함수를 만드는게 표준이다.
    - 왜냐하면, 몬스터가 자신에게 입은 누적 데미지에 대해서 로직을 처리하거나, 자신을 가장 많이 공격한 플레이어에 대해 어그로 수치를 조작하는 로직을 만들 때 이 아키텍처가 훨씬 로직의 간단함이 상승한다.
    - 또한, 몬스터가 가지고 있는 방어력이나, 버프 혹은 디버프에 의해 입는 데미지에 변화가 일어나는 것에 대해서도 이 방식이 처리가 수월하다.

## 상속성

- 전사, 궁수, 도적 클래스를 만들었을 때, 변수를 만들어서 자료형을 각각 전사, 궁수, 도적인 변수를 만들어도 각 변수에는 다른 직업이 들어갈 수 없다.
- 전사, 궁수, 도적끼리 아무런 상관관계도 없기 때문이다.
    - 어떤 함수를 만들어도, 전사버전, 궁수버전, 도적버전을 다 따로 만들어야 한다.
    - 이것들을 모두 하나로 뭉쳐 만들 때 훨씬 편리할 때가 많다.
- **객체 지향**을 지탱하는 3요소
    - **상속성, 은닉성, 다형성**
- 상속성을 판단할 때는, **Is-A**를 생각한다.
    - 이것은 무엇인가?
    - 고양이는 동물인가? - OK
    - 즉, 고양이는 동물(상위 클래스)을 상속받을 수 있다.
- 즉, 전사, 궁수, 도적도 이 공통점인 플레이어 클래스를 상속받아 만들 수 있다.
- 상속을 받는 방법
    - 이미 만들어진 클래스의 경우, 클래스 세팅 - 부모 클래스를 상속받고자 하는 부모 클래스로 설정
    - 지금 만들 경우, 클래스를 생성할 때 모든 클래스 선택해서 연 후 원하는 부모 클래스 설정
- 부모 클래스에 원하는 변수를 만들고, 자식 클래스에 가면 변수가 생성되어있지는 않지만, Set이나 Get 노드로 원하는 변수를 불러올 수 있다.
    - 이는 내 블루프린트의 톱니바퀴 - 상속된 변수 표시 설정 시 보이게 된다.
    - 액터를 상속받은 클래스일 경우, 이미 상속받은 변수가 굉장히 많다.
- 변수 뿐만 아니라 함수도 상속된다.
- 기존엔 전사, 궁수, 도적 자료형의 변수를 하나하나 다 만들었지만, 이젠 플레이어 라는 이름의 변수를 하나 만들 수 있다.
    - 이 변수에는 전사도, 궁수도, 도적도 모두 들어간다.
    - 이 경우, OnDamaged 함수의 인풋에 기존에는 몬스터 하나만 넣을 수 있었지만, 이제는 Creature(크리쳐) 같은 생명체의 상위 클래스를 만들어 넣을 수 있다는 것이다.
- 인풋은 플레이어만 받을 수 있는데 전사 자료형의 클래스도 들어가는 이유는, 전사는 플레이어의 모든 요소를 다 포함하고 있기 때문이다.

## 캐스팅

- 중복을 피하기 위해 상위 클래스로 함수를 작성할 수 있다.
- 그러나 때에 따라서, 오히려 하위 클래스를 받는게 편한 경우도 있다.
- 더 나아가서, 사용해야 하는 클래스가 상위와 하위를 왔다갔다 해야하는 경우도 존재한다.
- 이런것을 **캐스팅(형변환)** 이라고 한다.
    - 물론 int-float 이런 것도 캐스팅이지만, 이번에 다룰 것은 객체지향적인, 참조 타입에서의, 부모 자식 클래스 간의 캐스팅이다.
- 스폰 액터를 통해 기사 클래스를 스폰하고, 이를 SET으로 변수에 담을 때 기사 클래스의 상위 클래스인 플레이어 변수에 할당을 해도, 당연히 할당된다.
    - 이 과정에서 하위 클래스 개념이 상위 클래스 객체에 담겼다. 즉, 캐스팅이 일어났다.
- 기사를 스폰해도, 궁수를 스폰해도, 아무튼 인풋이 플레이어인 함수에 모두 들어갈 수 있어야 하고, 따라서 하위 클래스 → 상위 클래스로 캐스팅이 가능하다.
    - 단, 상위 클래스 → 하위 클래스로의 캐스팅은 불가능하다!
- 하위 클래스 → 상위 클래스로 형변환된 객체는 어디까지나 원본은 하위 클래스 객체이기 때문에, 자신의 원본으로 돌아가는 선에 한해서는 상위 클래스 → 하위 클래스로 캐스팅될 수 있다.
- 형변환 노드에 살펴보면, Cast Failed라는 플로우가 있는게 보인다.
- 즉, 만약 어떤 함수에서 Player를 Knight로 형변환했을 때, 잘 형변환된다면 그 함수에서 흐르던 객체의 원본이 Knight라는게 판별이 된 것이고, Cast Failed로 흐른다면 Knight가 아닌 다른 객체라는 의미가 된다.
- 나이트 객체가 플레이어 객체로 (상위 클래스) 로 형변환 되면, 일부 데이터가 소실되는가?
    - 절대 아니다. 애초에 그런 개념이 아니다.
    - 나이트 객체는 자신이 상속받은 클래스의 개념들 + 자신만의 개념을 보유하고 있을 것이다.
    - 그 상태로 해당 객체가 힙 영역의 임의의 주소에 저장되어있을 것이다.
    - 나이트 타입의 변수를 만들어서 해당 객체를 가리키면 해당 주소를 가리킨다.
    - 또, 플레이어 타입의 변수를 만들어서 해당 객체를 가리켜도, 똑같은 주소를 가리킨다.
    - 즉, 데이터가 절대 손실되지 않는다.
- 만약 상위 클래스 → 하위 클래스로 형변환을 하려고 하면, 애당초 되지 않는다.
    - 동물은 고양이인가? → 틀린 질문이 되는 것이다.
    - 플레이어 클래스로 객체를 만들었는데, 이걸 하위 클래스 객체로 형변환 시켜버리면, 하위 클래스 객체만이 가지는 고유의 변수나 함수도 쓸 수 있게 되어야 할텐데, 그런건 존재하지 않다.
- 캐스팅이 가능할 경우 할 수 있는 짓거리
    - OnDamaged 함수를 만드는데, 게임의 룰상 ‘기사’ 에게는 데미지를 2배 입는다.
    - 기사 전용 OnDamaged를 만들고 일반 OnDamaged를 만들 필요 없다.
    - 그냥 OnDamaged를 만들고, 기사 클래스로 형변환을 한다.
    - 다른 직업들은 Cast Failed 플로우에 넣어주고, 데미지 2배를 입는 코드는 형변환 성공 플로우에 넣어주면 되는 것이다.

## 은닉성

- 프로그래밍상 은닉성은 안전성을 강화하는 좋은 요소
- 자동차엔 엄청나게 많은 부품이 많고 기능이 매우 많으나, 사람이 쓰는 기능은 문열고 핸들 돌리기, 뭐 이 정도이다.
- 즉, 노출된 일부분의 기능만 사용할 수 있다.
- 다르게 표현하면 **캡슐화**라고도 한다. 잘 만든 뒤 고객에겐 딱 안전하고 필요한 기능만 노출하는 것이다.
- 블루프린트 클래스에서 변수를 하나 만들면, 오른쪽에 눈 모양의 아이콘이 있다.
    - 이는 변수 디테일에서의 **인스턴스 편집 기능 ON/OFF**이다.
    - 눈을 뜨고 있다면 언리얼 엔진의 레벨 툴 상에서 해당 변수를 조작할 수 있다.
    - 내가 만든 변수가 아트 직군, 사운드 직군은 필요 없고 프로그래머만 알아야 하는 변수라면 눈을 감게 하면 된다.
- 해당 변수를 누른 상태로 변수의 디테일을 보면, **프라이빗 체크박스**가 있다.
    - 만약 HP 변수를 프라이빗을 체크해두면, 레벨 블루프린트에서 해당 클래스를 spawn해도, set HP나 get HP가 불가능하다.
    - 프라이빗을 체크한다는 것은, 해당 변수를 사용은 커녕 존재 자체도 모른다는 것이다.
- 변수뿐만 아니라 함수들에도 모두 은닉성을 부여할 수 있다.
- 함수의 접근 지정자는 Public, Protected, Private 세 가지가 존재한다.

| Public | 누구나 사용 가능. 레벨 블루프린트에서도 해당 함수 호출 가능. 안전한 공개 가능 기능. |
| --- | --- |
| Protected | 자신을 상속받은 클래스만 사용 가능. 외부에는 알려지지 않고 레벨 블루프린트에서도 호출 불가능. 단, 자신을 상속받은 클래스 안에서는 자유롭게 호출 가능. |
| Private | 자기 자신만 사용 가능. 해당 함수가 존재하는 그 클래스 내부 이벤트그래프와 해당 클래스의 함수 안에서만 사용 가능. |
- 혼자 개인 프로젝트를 조그맣게 만들 때는 모든 변수와 함수를 죄다 Public으로 열어도 괜찮음.
- 그러나 규모가 커지고, 협업이 되는 순간 이 접근 지정자를 엄밀하게 조정해야 한다.
- 다른 사람의 코드를 꺼내 사용할 일이 많은데, 다른 사람의 코드에 원하는 기능 말고도 너무 많은 함수가 많이 있으면 이해도 어려울 뿐더러 위험한 함수를 건드려 에러가 터질 수도 있다.

## 다형성

- 같은 코드가 여러 갈래로 실행되는, 여러 형태를 지니는 성질
- 모든 몬스터가 ‘외침’ 이 있고, 몬스터를 상속받는 보스 몬스터는 ‘외침’ 시에 좀 더 특수한 외침이 나온다는 기획이 있다고 하자.
    - 이 때 굳이 보스 몬스터 클래스에 또 다른 이름의 ‘외침’ 을 만드는 것은 좋지 않다.
    - 이러면 모든 외침이 나오는 경우마다 보스 몬스터 전용 코드를 또 만들어줘야 하기 때문이다.
- 이 때 부모 클래스의 함수를 덮어써서 같은 이름이되 다른 기능을 하게끔 만드는 것이 함수 덮어쓰기, 즉 **오버라이딩**이다.
- 언리얼의 함수 생성 탭에 오버라이드를 누르면, 오버라이드가 가능한 함수들이 쭉 뜬다.
- 원하는 함수를 오버라이딩하면 해당 클래스만의 함수가 만들어지고, 기본적으로 오버라이딩한 부모 함수를 실행한다는 노드가 포함되어있다.
    - 함수 출발 노드에 우클릭을 해 부모 함수에 대한 호출 추가로 노드를 생성할 수 있다.
- 해당 함수가 부모 함수와 완전 다른 기능을 하고 싶다면, 부모 함수 호출 노드의 연결을 끊고 원하는 동작을 프로그래밍하면 된다.
- 이것이 다형성이다. 물려받은 개념을 다른 형태로 변환하는 것이다.
    - 모든 몬스터가 이동이라는 기능이 있을 때, 비행 타입 몬스터는 이동이 비행 이동이고, 지하 타입 몬스터는 이동이 땅굴 이동이라면 오버라이딩으로 만들 수 있다.
- 만약, 보스 몬스터 객체를 만들고, 몬스터로 캐스팅한 뒤에 ‘외침’을 사용하면?
    - 이 경우, 아무리 몬스터로 캐스팅되었어도 보스 몬스터의 ‘외침’을 사용한다.
    - 오버라이딩한 함수를 사용할 땐 원본을 더 중요시한다.

### 인터페이스

- 인터페이스는 일종의 설계도, 모형틀이라고 보면 된다.
- 이 인터페이스를 가진 클래스는 이러이러한 기능을 가질 것이다! 라고 약속하는 것이다.
- 인터페이스는 부모 클래스와 다르게 여러 개를 구현받을 수 있다.
- 언리얼에서 콘텐츠에 우클릭 - 블루프린트 - 블루프린트 인터페이스로 생성할 수 있다.
    - 모든 인터페이스는 대문자 I로 시작하는 것이 일반적이다.
    - 날 수 있는 오크가 있다고 하고 싶으니, IFlyable 등으로 이름을 지을 수 있다.
- 인터페이스를 새로 만들어 열어보면, 아무것도 없는 빈 함수가 하나 만들어져있다.
- 이걸 변경해서, 비행 함수인 Fly()와 착지 함수인 Land()를 만들 수 있다.
- 인터페이스는 어디까지나 이런 기능을 만들 수 있다는 가이드라인이기 때문에, 함수를 생성할 순 있지만 그 함수 안에 노드를 추가로 넣을 수는 없다.
- 구현부는 만들 수 없지만, 함수의 인풋과 아웃풋은 결정해줄 수 있다.
- 이후, 오크 클래스로 들어가서 클래스 세팅을 보면, 밑에 인터페이스 란이 존재한다.
- 여기서 구현된 인터페이스 - 원하는 인터페이스를 설정할 수 있다.
    - 그 즉시 왼쪽에 인터페이스란에 약속된 기능들이 추가된다.
- **리턴값이 없는 인터페이스 함수는 이벤트로 생성된다.**
- **리턴값이 있는 인터페이스 함수는 함수로 생성된다.**
    - 함수는 지역 변수를 사용할 수 있으며, 호출된 순간 그 기능을 한번에 일괄적으로 실행한다. 함수는 리턴이 있기 때문에 실행한 순간 리턴을 받아야만 해서, 중간에 기다릴 수 없다.
    - 이벤트는 실행 계기 (트리거 포인트) 를 통해 실행되고, 언젠가 끝나며 중간에 대기할 수 있다. 즉, Delay 노드가 삽입될 수 있다. 이벤트는 이 이벤트가 실행된 결과를 기다릴 필요가 없기 때문이다.
- 이렇게 인터페이스를 받은 클래스는 객체가 생성되었을 때, 부모 클래스의 변수에 할당할 수 있던 것처럼 **인터페이스 변수**를 하나 만들어서 (자료형은 인터페이스) 할당받을 수 있다.
    - 상속과 마찬가지로 하위 클래스 → 상위 인터페이스 형태이다.
- 인터페이스로 받았다면, 그 인터페이스에서 제공하기로 약속한 기능 (함수나 이벤트) 를 호출할 수 있게 된다.
- 물론 인터페이스 변수도 원하는 클래스 객체 타입으로 형변환할 수 있다.
- 만약 NPC든 아이템이든, 플레이어와 상호작용이 가능한 클래스가 있다고 한다면, Interactable이라는 이름의 인터페이스를 만들어 넣어주는 방식으로 응용 가능하다.