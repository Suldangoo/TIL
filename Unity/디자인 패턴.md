## 1. 싱글턴 패턴 : 게임 매니저

- 싱글턴 패턴의 주요 목적은 유일성을 보장하는 것이다.
- 싱글턴 패턴으로 구현된 클래스는 어떻게 몇 번 호출되더라도 메모리에 오직 하나의 인스턴스만 존재해야 한다. 그 어떤 경쟁도 용납하지 않는다.
- 주로 보드게임 마스터와 같은 게임 매니저나, 백엔드 서비스와 통신, 전역 설정 초기화 등에 사용된다.
- 게임 매니저는 게임의 전체 수명 동안 단 하나의 인스턴스로서 살아있어야 한다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 전역 접근 가능 | 리소스나 서비스의 전역 접근점 지원 |
| 동시성 제어 | 공유 자원에 동시 접근을 제한할 수 있음 |

| 단점 | 단점 설명 |
| --- | --- |
| 유닛 테스트 | 과도한 싱글턴은 싱글턴 종속성을 만들어 단독으로 테스트하는 것이 불가능해짐 |
| 잘못된 습관 | 너무 쉬운 사용법에 전역 접근이 정교한 접근법 설계를 귀찮게 만들 수 있음 |

### 코드 논점

- 제네릭을 활용한 싱글턴 클래스를 만들고 이를 상속받는 것으로 쉽게 확장성을 확보할 수 있다.
- 정적(static) 변수나 함수 사용으로 전역적 접근점을 만들어서 사용한다.
- Awake() 함수의 경우 virtual로 지정하여 상속받은 파생 클래스에서 재정의할 수 있도록 한다.
    - Awake() 함수 내부에서 싱글턴 인스턴스가 있는지 확인하고, 없다면 자신이 싱글턴 인스턴스가 되며, 있다면 스스로를 제거한다.
    - DontDestroyOnLoad 메서드를 사용하여 씬 전환 시에도 오브젝트가 유지되도록 한다.

## 2. 상태 패턴 : 캐릭터 상태 관리

- 상태 패턴은 객체가 여러 상태를 가질 수 있을 때, 상태마다 클래스를 만들어 그 상태에 따라 행동하도록 구조화하는 디자인 패턴이다.
    - 만약 상태 패턴을 사용하지 않으면 if-else 문이나 switch 문으로 현재 상태를 필터링하고 행동하도록 해야 해서 복잡하고 유지보수가 힘들어진다.
- 객체의 유한 상태를 관리하고, 객체가 내부 상태를 기반으로 동작할 수 있도록 하는 것이다.
- 상태 패턴은 클래스를 간소화하고 유지관리가 쉽도록 만들어준다.
- 상태 패턴 구조에는 세 가지 핵심 요소가 있다.
    - Context 클래스 : 객체 내부 상태를 보유하고, 변경하도록 요청하는 인터페이스를 정의
    - IState 인터페이스 : 모든 상태 클래스의 인터페이스로, handle() 메서드 원형
    - 각 ConcreteState 클래스 : 여러 종류의 상태 클래스들로, public으로 IState의 handle 정의
- 객체의 상태를 업데이트할 땐 반드시 상태 패턴의 감독인 Context 클래스를 거쳐야 한다.
- 각 상태마다 Enter(), Update() 등이 존재해서, 현재 상태에 맞는 코드가 캡슐적으로 실행된다.
- 상태 전환은 Context의 Transition()으로만 가능해서 무질서하게 상태가 바뀌지 않는다.

### 코드 논점

- 정의한 유한 상태에서 예상할 수 있는 동작을 캡슐화한다는 목표로 상태 패턴을 구현해야 한다.
- Context 클래스에서 현재 상태를 카리키는 CurrentState를 public 프로퍼티로 만들어 모든 상태 변경을 인식하고, Transition() 함수를 호출해 상태를 전환하도록 구현할 수 있다.
- Transition() 함수는 오버로딩을 통해 파라미터가 없다면 단순히 Handle을, 파라미터로 IState의 상태를 삽입한다면 해당 상태로 현재 상태를 변환한 후 Handle을 할 수 있다.

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 캡슐화 | 상태가 변할 때 개체에 동적으로 할당할 수 있는 컴포넌트 집합이므로, 상태별 행동 구현 |
| 동시성 제어 | 긴 조건문이나 방대해진 클래스 수정 없이 새로운 상태를 얼마든 추가할 수 있음 |

| 단점 | 단점 설명 |
| --- | --- |
| 블렌딩 | 기본 형태의 상태 패턴은 애니메이션 블렌드를 제공하지 않음 |
| 전환 | 패턴 구현에서 상태 간 관계를 정의하지 않아 이를 구현하려면 더 많은 코드가 필요 |
- 두 단점은 유니티의 애니메이터를 통해 극복할 수 있다. 애니메이션 상태를 쉽게 정의하고 파라미터를 통해 쉽게 트리거를 작동하며 애니메이션 블렌딩을 지원한다.

### 대안

- 블랙 보드, 행동 트리(BT) : NPC 캐릭터의 복잡한 AI 동작을 구현하고자 할 때.
- 유한 상태 머신 : 상태 패턴은 객체의 상태 종속적인 동작 캡슐화, 유한 상태 머신은 트리거 기반으로 상태간 전환에 더 깊이 관여
- 메멘토 : 상태 패턴과 유사하나 이전 상태로 돌아가는 기능을 제공

## 3. 이벤트 버스 패턴 : 게임 이벤트

- 이벤트 버스는 객체가 구독하거나 게시할 수 있는 특정한 전역 이벤트의 목록을 관리하는 중앙 허브이다.
- 이벤트 관리와 관련된 가장 간단한 패턴으로, 한 줄의 코드로 객체에 구독자 혹은 게시자의 역할을 할당한다.
- 객체(게시자)가 이벤트를 발생하게 되면 다른 객체(구독자)가 받을 수 있는 신호를 보내는 것이다.
- 오브젝트는 이벤트 시스템에서 이벤트를 브로드캐스트한다. 구독자만이 알림을 받는 것이다.
- 발행/구독 시스템이라고 부르는 것이 더 명확할 수 있으며, 키워드가 버스이다.
- 즉, 옵저버 패턴은 구독자와 게시자가 서로를 인식하며 의존성이 생기는 반면, 이벤트 버스 패턴은 누가 뭘 하든 관심은 없고 어떤 객체에 무슨 일이 생겼을 때 그걸 구독하고 있는 모든 객체들에게 브로드캐스트하는 것이다. 가운데에 이벤트 허브인 이벤트 버스 중재자가 있고 없고가 가장 큰 차이이다.
    - 예를 들어 옵저버 패턴은 특정 버튼과 특정 메서드가 완전히 결합되어있을 때 사용한다.
    - 그러나 이벤트 버스 패턴은 플레이어가 죽었을 때, 게임 전체에 그걸 알리며, 이 플레이어 사망이 필요한 모든 객체들이 익명적으로 구독하고 모두가 그걸 받는다.
- 전역적이고 빠르게 구현할 땐 이벤트 버스 패턴, 지역적인 이벤트 통신은 옵저버 패턴이다.
- 이벤트 버스 패턴에는 세 가지 주요 구성이 있다.
    - 게시자(Publisher) : 이벤트 버스에서 선언한 특정 종류 이벤트를 구독자에게 게시
    - 이벤트 버스 : 구독자와 게시자 사이의 이벤트 전송 조정
    - 구독자(Subscriber) : 이벤트 버스를 통해 특정 이벤트의 구독자로 자신을 등록

### 장단점

| 장점 | 장점 설명 |
| --- | --- |
| 분리 | 오브젝트들이 직접 서로를 참조하는게 아닌, 이벤트로 통신 |
| 단순성 | 이벤트의 구독과 게시 매커니즘을 추상화하여 단순성 제공 |

| 단점 | 단점 설명 |
| --- | --- |
| 성능 | 이벤트 시스템 내부엔 오브젝트 간 메시지를 관리하는 저수준 메커니즘이 있어 비용 발생 |
| 전역 | static을 사용해 이벤트 버스를 구현하면 전역성이 넓어져 편하지만, 관리 테스트 어려움 |

### 코드 논점

- 구현에 따라 다르지만, 지원하는 특정 이벤트 종류를 Enum 열거형으로 처리한다.
- Events 딕셔너리를 만들어 이벤트 종류와 구독자 간 관계 목록을 구현한다.
    - private 접근 지정자 및 readonly로 유지하여 다른 오브젝트가 덮어쓰지 못하게 한다.
- 구독, 구독 취소, 게시 메서드를 구현한다.
    - 구독 메서드의 파라미터는 2개로, 하나는 이벤트 종류이며 하나는 콜백 함수이다.
    - UnityAction이 델리게이트 타입이므로 인자로 메서드를 전달할 수 있다.
    - 구독 취소 메서드는 특정 이벤트를 구독하는 오브젝트를 삭제한다.
- 예를 들어 타이머의 경우, 타이머 코루틴을 만들고 그걸 시작하는 StartTimer() 메서드를 private로 만든다. 이후 이걸 이벤트 버스에서 시작 이벤트 Enum에 이 메서드를 구독하면, 이 이벤트가 발생했을 때 콜백으로 해당 코루틴이 실행될 것이다.

### 대안

- 옵저버 패턴 : 오브젝트(서브젝트)가 오브젝트(옵저버) 목록을 유지 및 관리하고, 내부 상태 변경을 알리는 패턴으로, 엔티티 그룹 간의 일대다 관계 설정에 좋다.
- 이벤트 큐 : 게시자가 생성한 이벤트를 큐에 저장하고, 편한 시간에 구독자에게 전달한다.
- Scriptable Object : 유니티에서는 스크립터블 오브젝트로 이벤트 시스템을 만들 수 있다.

## 4. 커맨드 패턴 : 리플레이

- 플레이어 요청을 객체로 캡슐화해서, 요청에 대한 처리를 나중에 하거나 기록, 취소, 재실행할 수 있게 하는 패턴이다.
- 입력을 올바른 순서와 타이밍에 맞게 재생할 수 있게 된다.
- 원래의 방식엔 특정 키를 입력하면 컨트롤러의 특정 행동을 하게끔 하면 되지만, 커맨드 패턴은 플레이어가 특정 키를 누를 때 어떤 작업을 해야 하는지 인풋 핸들러가 알지 못해도 된다.
    - 올바른 명령이 실행되도록 커맨드 패턴 메커니즘이 처리할 것이다.
- 커맨드 패턴에 사용되는 기본 클래스는 아래와 같다.
    - 호출자(Invoker) : 명령을 실행하는 방법을 알고, 실행한 명령을 즐겨찾기할 수도 있는 객체
    - 수신자(Receiver) : 명령을 받아서 수행할 수 있는 종류의 객체
    - 커맨드베이스 : 개별 ConcreteCommand가 무조건 상속해야 하는 추상 클래스로, Execute() 메서드 노출
- 실행 취소, 매크로, AI의 자동화 등이 필요할 때 커맨드 패턴을 사용한다.