## **1. Unreal Engine 5의 기본 구조 및 라이프사이클**

<aside>
🎮

- **언리얼 객체 모델**: `UObject`, `AActor`, `UComponent` 등 계층 구조 이해
- **라이프사이클**: `BeginPlay()`, `Tick()`, `EndPlay()` 등의 호출 순서
- **가비지 컬렉션**: `UProperty`, `UPROPERTY()` 매크로 및 스마트 포인터 (`TSharedPtr`, `TWeakPtr`, `TUniquePtr`)
</aside>

### UObject (언리얼 오브젝트)

- 기본적으로 C++로 프로그래밍할 때, 게임플레이 클래스를 생성해서 VS 등으로 컴파일 후 언리얼 에디터에 반영하여 사용한다. 당연히 표준 C++ 구문을 사용한다.
- 언리얼 엔진 오브젝트의 베이스 클래스가 UObject.
- UClass 매크로는 UObject에서 파생된 클래스에 태그를 지정하여 UObject 처리 시스템이 인식하도록 할 수 있다.
- 가비지컬렉션의 대상이 되는 객체이며, 반사(reflection) 시스템을 지원한다.
- 그러나 트랜스폼(위치, 회전, 스케일)이 없다. 3D 공간에 배치되려면 AActor를 상속받아야 한다.

### AActor

- UObject를 상속받은, 게임 월드 내에서 배치할 수 있는 오브젝트.
- 트랜스폼이 있으며, Tick()을 사용하여 매 프레임 업데이트할 수 있다.
- UComponent들을 포함할 수 있다.
    - 이는 UActorComponent를 상속받아 AActor에 부착할 수 있는 부품형 객체이다.
    - 독립적으로 동작 가능하지만 반드시 액터에 부착해야 한다.

### 객체 라이프사이클

- Unreal에서의 모든 객체는 라이프사이클을 지니고 있다.
    - 객체가 생성되고, 동작하고, 제거되는 과정을 말한다.
    - AActor 기준으로 서술한다.
- 객체 생성
    - 생성자는 AActor::AActor()에서 호출되며, UObject는 절대로 new 연산자를 사용해선 안된다. 모든 UObject는 언리얼 엔진으로 관리되는 메모리이며, 가비지 컬렉션된다. new 또는 delete를 사용하여 메모리를 수동으로 관리하면 메모리가 손상될 수 있다.
    - BeginPlay()은 월드에 액터가 스폰된 직후 한 번만 호출된다.
- 게임 인스턴스
    - Init() : 게임 인스턴스가 생성될 때 호출된다. 초기화 작업에 사용된다.
    - OnStart() : 첫 번째 월드가 로드된 후 호출된다. 게임 시작 전 필요한 추가 설정 수행에 사용한다.
    - Shutdown() : 게임이 종료될 때 호출된다. 전체 리소스 정리에 사용된다.
- 실행 중
    - Tick(float DeltaTime)은 매 프레임마다 호출된다.
    - 이는 bCanEverTick = true인 경우에만 실행되며, SetActorTickEnabled(false);로 비활성화 가능하다.
- 제거
    - EndPlay()는 액터가 삭제될 때 호출된다.
    - Destroyed()는 액터가 완전히 삭제될 때 호출된다.

### 가비지 컬렉션 (Garbage Collection)

- 언리얼 엔진은 UObject 기반의 객체를 자동으로 관리하는 GC 시스템을 사용한다.
- UPROPERTY() 매크로를 통해 UObject 기반 객체를 GC 대상에 포함시킬 수 있고, 하지 않으면 GC가 객체를 인식하지 못하고 삭제될 수 있다.
    - 이를 통해 UE가 새 클래스, 함수, 변수를 인식하게 한다.

### 스마트 포인터

- 언리얼은 가비지 컬렉터 뿐만이아니라 스마트 포인터로도 메모리를 관리한다. 두 개념 모두 C++로 자체 제작한 코드를 이용하며, 순수 C++ 이용 상황에선 스마트 포인터를 사용하고, UObject와 관련된 부분에서는 GC를 사용한다.
    - 즉 new를 사용한 객체는 GC가 관리할 수 없어서, 스마트 포인터를 쓴다.
- TSharedPtr이 일반적인 C++ 스마트 포인터이며, UObject의 안전한 약한 포인터는 TWeakObjectPtr로 사용하기도 한다.

---

## **2. C++ 및 블루프린트 연동**

<aside>
🎮

- **블루프린트와 C++의 관계**: `UCLASS()`, `UFUNCTION()`, `UPROPERTY()` 매크로의 역할
- **블루프린트 함수 라이브러리**: C++에서 블루프린트 전용 함수 제공하기
- **인터페이스와 이벤트 시스템**: `BlueprintImplementableEvent`, `BlueprintNativeEvent`
- **Gameplay Framework 주요 클래스**: `ACharacter`, `AController`, `AGameModeBase`, `UUserWidget` 등
</aside>

- Unreal Engine의 모든 기능은 C++과 블루프린트를 함께 사용해 구현한다.
    - 게임 개발자가 C++로 성능이 중요한 핵심 기능을 만들고, 블루프린트로 게임 디자이너들이 쉽게 조작할 수 있도록 구현하는 편이다.

### 블루프린트와 C++

- 언리얼에서 C++ 클래스를 만들면 블루프린트로 확장해서 사용할 수 있다.
- UCLASS()를 통해 언리얼이 이 클래스를 인식하고, 블루프린트에서 상속할 수 있게 한다.
- 변수에 UPROPERTY()를 붙여 블루프린트에서 볼 수 있고, 수정 가능하게 한다.
    - 결과적으로 C++ 변수를 블루프린트에서 조작 가능하게 한다.
- UFUNCTION()을 통해 블루프린트에서 함수 호출이 가능하다.

| 부모 클래스 | 역할 | 언제 사용? | 예제 |
| --- | --- | --- | --- |
| **AActor** | 기본적인 게임 오브젝트 | 게임 내 오브젝트(아이템, 문, 상호작용 오브젝트 등) | `AWeapon`, `AChest` |
| **ACharacter** | 이동, 점프, 애니메이션 포함된 캐릭터 | 플레이어, NPC, 적 캐릭터를 만들 때 | `APlayerCharacter`, `AEnemyCharacter` |
| **APawn** | 직접 제어 가능한 오브젝트 (Character보다 기능 적음) | 캐릭터 이외의 조종 가능한 것 (예: 탱크, 비행기) | `AVehiclePawn`, `AJetPawn` |
| **APlayerController** | 플레이어의 입력을 처리 | 키보드/마우스 입력, UI 클릭 처리 | `AMyPlayerController` |
| **AAIController** | AI가 캐릭터를 조종하도록 함 | NPC나 몬스터의 AI 동작 | `AEnemyAIController` |
| **AGameModeBase** | 게임의 규칙을 정함 | 게임 시작 조건, 승리 조건, 스폰 관리 | `AMyGameMode` |
| **AGameStateBase** | 현재 게임의 상태 저장 | 점수, 진행 상황 관리 | `AMyGameState` |
| **APlayerState** | 플레이어별 정보 저장 | 플레이어 이름, 점수, 핑 | `AMyPlayerState` |
| **UUserWidget** | UI 요소 | 화면에 표시할 HUD, 메뉴 | `UMyHUDWidget` |

---

## **3. 게임 시스템 및 메커니즘 구현**

<aside>
🎮

- **컴포넌트 기반 시스템**: `UActorComponent`, `USceneComponent` 활용
- **데이터 관리 및 저장**: `SaveGame` 시스템 활용
- **애니메이션 시스템**: 애니메이션 블루프린트, `UAnimInstance` 사용법
- **입력 시스템**: `Enhanced Input` 플러그인 활용
- **멀티스레딩 및 성능 최적화**: `AsyncTask`, `FRunnable`, `TaskGraph` 등
</aside>

---

## **4. AI, 물리, 렌더링, 네트워킹**

<aside>
🎮

- **AI**: `Behavior Tree`, `Blackboard`, `NavMesh` 활용법
- **물리**: `Chaos Physics` 기본 개념, `UPhysicsConstraintComponent` 활용
- **렌더링**: LOD, Virtual Shadow Map, Nanite, Lumen 개념
- **네트워킹**: `Replication`, `RPC`, `Server-Client` 구조
</aside>

---

## **5. 게임 성능 분석 및 최적화**

<aside>
🎮

- **Unreal Insights 활용법**
- **프로파일링 및 최적화**: `STAT`, `r.ProfileGPU`, `MemReport` 등의 명령어
- **렌더링 최적화**: `Instanced Static Mesh`, `Occlusion Culling`
- **CPU 최적화**: `Object Pooling`, `Async Loading`
</aside>

---

## **6. 프로젝트 관리 및 협업 도구**

<aside>
🎮

- **Perforce 개념 및 워크플로우**: Git과의 차이점 이해, `p4 sync`, `p4 submit`
- **코드 리뷰 및 협업**: Clean Code 원칙, `Coding Standard` 확인
- **노션 및 슬랙 활용법**: 팀 내 문서화 및 커뮤니케이션 최적화
</aside>

- 언리얼 엔진에서의 협업은 Perforce를 쓴다. 이는 줄여서 P4라고도 부른다.
- 이는 대용량 파일 (에셋, 맵, 애니메이션 등) 을 효과적으로 관리할 수 있다.

### Perforce

- Perforce(정식 명칭: **Helix Core**)는 **중앙 집중형 버전 관리 시스템(CVCS)이다.**
- Git처럼 분산형(DVCS)이 아니라 **모든 데이터가 중앙 서버(P4 서버)에 저장된다.**
- 팀원들이 같은 파일을 동시에 수정하는 경우에 충돌을 막고 관리하기 편하다.
    - Locking이 가능하기 때문에 충돌을 미리 방지할 수 있다.
- 서버 기반이라 매우 빠르다.

| 명령어 | Git에서의 유사 명령어 | 기능 |
| --- | --- | --- |
| p4 sync | git pull | 서버에서 최신 파일을 로컬로 가져온다. |
| p4 sync //... |  | //…는 모든 파일을 동기화한다는 뜻이다. |
| p4 edit 파일명 | git은 그냥 수정하면 되지만, 퍼포스는 명시적으로 체크아웃해야 한다. | 수정하려는 파일을 서버에 ‘내가 수정중’이라고 알리는 것이다.
다른 사람이 파일을 수정하지 못하도록 Lock도 걸 수 있다. |
| p4 submit | git commit + git push | 변경한 파일을 서버에 업로드 (커밋) 하는 것이다. |
| p4 add | git add | 새로운 파일을 버전 관리에 추가. |
| p4 delete | git rm | 파일을 삭제하는 명령어이다. |
| p4 submit |  | 서버에 반영 및 동기화하는 명령어이다. add나 delete 뒤에 붙는다. |
| p4 revert | git checkout — 파일명 | 변경한 내용을 되돌림. 즉, 서버에서 받은 원본 상태로 복구 |
| p4 changes | git log | 최근 변경된 사항들을 확인 |
| p4 opened |  | -a 옵션을 붙이면 현재 팀원들이 어떤 파일을 체크아웃했는지 확인 |

- Perforce의 기본적인 워크플로우
    1. p4 sync //… 를 통해 최신 파일 가져오기
    2. p4 edit 파일명을 통해 수정할 파일 체크아웃
        - p4 lock 파일명으로 잠금 설정 가능
    3. 파일 수정
    4. p4 submit -d “설명” 을 통해 변경사항 저장
 
 ---

## **7. UE5 최신 기술 지식**

### 나나이트

나나이트는 언리얼 엔진 5의 가상화 마이크로폴리곤 지오메트리 시스템이다. 수십억 개의 폴리곤을 가진 고해상도 모델도 실시간으로 렌더링할 수 있도록 한다. 또한 자동 LOD 처리를 해주는데, 기존에는 LOD를 통해서 거리간 텍스쳐 품질을 아티스트가 제작했지만 이젠 그럴 필요가 없어졌다. 자동으로 최적화 수준의 디테일을 유지하기 때문에 퍼포먼스를 유지하며 초고해상도 환경을 구현할 수 있는 기술이다.

### 루멘

루멘은 언리얼 엔진 5의 실시간 글로벌 일루미네이션 및 반사 시스템이다. 원래는 라이팅 처리가 매우 많은 연산량을 요구했기 때문에 움직이지 않는 오브젝트들의 경우 모두 라이팅을 베이크했었는데, 시간이 지날 수록 실시간으로 조명이 변해야 하는 AAA게임이 많아짐에 따라 각광받는 기술이 되었다. 루멘은 반사 및 간접 조명을 자동으로 실시간 계산해주며 레이트레이싱 없이도 높은 퀄리티의 GI(글로벌 일루미네이션)을 구현할 수 있다.

### 월드 파티션

최근 오픈월드 게임이 많아짐에 따라 맵을 처리하는 기술이 매우 중요해졌는데, 월드 파티션은 UE5의 대규모 오픈월드 관리 시스템으로, 맵을 자동으로 셀 단위로 나누고 필요한 부분만 스트리밍하여 로딩 성능을 최적화하는 기능이다. 기존에는 서브레벨 방식으로 오픈월드를 처리했는데, 이보다 더 직관적이고 효율적으로 레벨 스트리밍이 가능해졌다. 특정 지역에 들어갈 때 해당 부분만 로딩하여 메모리 사용량을 최소화하고 심리스한 월드 표현이 가능해진다.

### 카오스 물리

UE5의 새로운 고급 물리 엔진인 카오스 물리는 기존의 PhysX를 대체하는 기술이다. 파괴, 유체, 차량 시뮬레이션 등을 더욱 사실적으로 표현할 수 있게 되어 건물이나 사물이 물리 법칙에 따라 자연스럽게 붕괴될 수 있다. 건물이 파괴되거나 차량이 충돌하는 등의 액션을 더욱 사실적으로 만들 수 있다.

### 모션 매칭

모션 매칭은 UE5의 애니메이션 시스템으로, 쿼리 기반 애니메이션 포즈 선택 시스템이다. 이는 사전에 녹화된 모션 캡처 데이터에서 가장 적절한 애니메이션을 실시간으로 선택하여 적용하는 방식이다. 전통적인 블렌드 트리보다 더 애니메이션 전환이 자연스럽다는 특장점이 있고, 애니메이터가 일일이 트랜지션을 설정할 필요가 없어졌다. 기존엔 스테이트 머신을 사용하여 모든 플로우를 애니메이터가 정해줬으나, 스테이트 머신을 사용하지 않고 캐릭터의 현재 상태를 기반으로 다량의 애니메이션이 저장되어있는 DB에서 현재 상태에 맞는 애니메이션을 선택하는 것이다.

### 퀵셀

퀵셀은 초고해상도의 3D 스캔 기반 모델 텍스처 라이브러리 제공 서비스이다. 고품질 3D 자산을 무료로 제공하고, 큐브 그리드로 만든 프로토타입 맵에도 깔끔한 텍스처를 바로 입히거나 풀, 나무 같은 3D 에셋을 즉석에서 생성할 수 있어 매우 편리하다. 나나이트와 완벽하게 호환되기 때문에, 메가스캔 자산을 활용해 숲, 폐허 등을 빠르게 생성할 수 있다. 작년에 메가스캔 자산이 유료화되고 FAB으로 언리얼 마켓플레이스 서비스가 변경되고있다.