# Chapter 11 : 알고리즘 성능 분석

## 알고리즘 성능 측정 기준

- 정확성 : 얼마나 정확히 동작하는가
- 작업량 : 얼마나 적은 비용으로 연산을 수행하는가
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지가 없을 만큼 최적화되어 있는가
  
### 알고리즘 수행 시간 분석

- 보통의 알고리즘은 최악의 경우를 항상 상정하고 수행 시간을 세운다.
- 평균 시간대와 최선의 경우도 존재한다.
- 일반적으로는 점근 표기법을 사용한다.

## 점근 표기법

### O 표기법

- 최악의 경우 알고리즘 수행 시간
- 상수항과 계수는 제거하고, 가장 핵심적인 시간을 내부에 적는다.
- 퀵 정렬은 예외인데, 최악은 O(n^2)이지만 이론적인 수치이지 거의 나오지 않기 때문에 평균 시간복잡도인 O(n log n)으로 표현한다.

| O(1) | 해시 테이블 |
| --- | --- |
| O(log2n) | 이진 탐색 |
| O(n) | 순차 탐색 |
| O(n log n) | 병합 정렬, 퀵 정렬 |
| O(n^2) | 버블 정렬, 삽입 정렬 |
| O(n^3) | 행렬 곱셈 |
| O(2^n) |  |

### Ω 표기법

- 최선의 경우 알고리즘 수행 시간
- 아무리 좋은 조건을 만나도, 꼭 수행해야만 하는 최소한의 수행 시간 표현

### Θ 표기법

- 점근적 상한과 점근적 하한을 모두 만족시키는 증가 함수
- 즉 점근적으로 자신의 증가율과 같은 증가 함수
  
# Chapter 12 : 분할 정복

## 분할 정복 기법 개요

- 아우스터리츠 전투에서 탄생한 배경을 가지고 있다.
- 문제를 잘게 나누어 모두 해결하고, 그것을 합치는 기법이다.
    - 즉 분할 - 정복 - 결합이 하나의 묶음으로 되어있는 기법이다.
- 분할 정복을 통해 제곱 계산 및 피보나치 함수 계산도 쉽게 가능하다.

## 병합 정렬

- 병합 정렬의 프로세스는 아래와 같다.
    1. 데이터를 반으로 나눈다.
    2. 나눈 하위 데이터의 크기가 2 이상이라면 1의 단계를 반복한다.
    3. 동일 데이터에서 나뉜 하위 데이터 둘을 병합하며 정렬한다.
    4. 모든 데이터가 하나로 될 때까지 3을 반복한다.
- 여기서 정렬하며 합치는 부분이 가장 중요하다.
    - 두 데이터를 합한 것만큼 비어있는 데이터 공간을 마련한다.
    - 두 데이터의 첫 번째 요소들을 비교하며 더 작은 요소를 새 데이터에 추가한다.
    - 양쪽 데이터가 빌 때까지 2번을 반복한다.

# Chapter 13 : 동적 계획법

## 동적 계획법 개요

- 동적 계획법은 어떤 문제가 여러 단계의 반복되는 부분 문제로 이루어졌을 때, 각 단계에 있는 부분 문제의 답을 기반으로 전체 문제의 답을 구하는 방법이다.
- 즉, 예전에 구했던 답이 다음 문제에도 도움이 되도록 답을 재활용함을 뜻한다.
- 또, 동적 계획법은 한 번 푼 적 있는 부분 문제를 다시 푸는 일이 없도록 테이블 등에 저장한다.
- 즉, 아래와 같이 정리된다.
    1. 문제를 부분 문제로 나눈다.
    2. 가장 작은 부분 문제부터 해를 구한 뒤, 테이블에 저장한다.
    3. 테이블에 저장된 부분 문제의 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구한다.
- 단, DP로 풀 수 있는 문제는 정해져있다. 그 유형은 ‘최적 부분 구조’를 갖춰야 한다는 조건이다.
    - 이는 전체 문제의 최적해가 부분 문제의 최적해로부터 만들어지는 구조를 뜻한다.

### DP로 피보나치 수 구하기

- 그냥 단순히 재귀함수로 그 수를 구하면, 부분 피보나치 수를 얻기 위해 중복 계산이 수없이 이루어진다.
- DP를 활용하면 모든 테이블에 피보나치에 필요한 저장된 값이 저장되고, 거기서 필요한 값만 꺼내오는 방식이다.

## 최장 공통 부분 수열 (LCS)

- 부분 수열은, 어떤 수열에서 일부 요소를 제거한 수열이다.
- 즉 두 수열에서 공통된 부분 수열인데, 그 중 최장인 수열을 찾아내는 것이다.
- LCS는 두 데이터를 비교할 때 아주 유용하다. DNA 염기 서열을 비교할 때도 응용할 수 있다.
- 단순 재귀로 풀게 되면 수행 시간이 지수적으로 증가하기 때문에, DP 기반으로 만들어 개선할 수 있다.
- 가장 오른쪽 아래 모서리 요소를 시작 셀로 지정하여 백트래킹하는 방식으로, 배낭 문제와 유사하게 길이를 잡아가며 해결하게 된다.

# Chapter 14 : 탐욕 알고리즘

## 탐욕 알고리즘 개요

- 이 역시 DP처럼 최적화 문제의 답을 얻기 위해 사용한다.
- DP보다는 효율적이로 가볍고 빠르지만, DP처럼 반드시 최적해를 구해준다는 보장은 하지 못한다.
    - 기대하는 최적해는 구할 수 있다.
- 그리디 알고리즘은 다음과 같은 과정으로 동작한다.
    1. 현재 상태에서 부분 문제의 최적 해를 구한 후 이를 부분해 집합에 추가한다.
    2. 새로운 부분해 집합이 실행 가능한 것인지 확인한다.
    3. 새로운 부분해 집합이 문제의 해가 되는지 확인한다. 해가 완성되지 않았다면 1단계부터 다시 시작한다.
- 표현은 굉장히 어렵지만 아주 단순한 풀이 방법이다.
- 가장 대표적인 그리디 알고리즘의 문제는 거스름돈 줄이기 문제이다. 위 단계에 맞게 해석하면 아래와 같이 프로세스가 이루어진다.
    1. 가장 좋은 해를 고른다. 단위가 가장 큰 동전으로만 거스름돈을 만들면 개수가 줄어드니, 현재 고를 수 있는 가장 큰 단위의 동전을 고른다.
    2. 거스름돈이 손님에게 드려야 할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전은 빼고, 1단계로 돌아간다.
    3. 거스름돈이 딱 맞아야하는데, 액수가 모자라면 다시 단계 1로 돌아가 추가할 동전을 고른다.
- 그러나 그리디 알고리즘에서 거스름돈 문제는 모든 동전이 공약수로 이루어져있기 때문에 가능하다. 만약 200원, 400원짜리 동전이 있다면, 최적해를 내놓지 못한다. 즉, 그리디의 해는 항상 최적이 아니다.

# Chapter 15 : 백트래킹

## 백트래킹 개요

- 여러 후보해 중 특정 조건을 충족시키는 모든 해를 찾는 알고리즘이다.
- 백트래킹이 다루는 문제들은 해가 하나 이상 존재한다.
    - 이 모든 해를 위해 필요한 것이 후보 해인데, 후보 해란 해가 될 수 있는 가능성을 가진 부분해의 조합이다.
    - 즉 수많은 후보해 중에서 해가 될 조건을 만족시키는 진짜 해를 효율적으로 찾는 것이다.
- 미로의 시작부터 골 지점까지의 갈림길마다 트리를 만들고, 트리 안쪽으로 가면 다음 갈림길이 나온다고 해보자. 그럼 DFS처럼 모든 길을 확인하며 해를 검증해보고, 그게 맞지 않는다면 뒤로 돌아가서 다른 자식 트리로 가는 식이다.
- 여기서 백트래킹은 해를 찾는 비용을 줄이기 위해 방문할 노드의 수를 최소화하는 것이 중요하다.

### 미로 탈출로 찾기

- 재귀 호출 기반으로 백트래킹 하는 방법이 있다.
    1. 노드를 이동한다.
    2. 자식 노드 목록을 확인한다.
    3. 자식 노드로 이동한다. (1단계 재귀)
    4. 조건 미충족 혹은 잎 노드라면 부모 노드로 이동한다.

### 8개의 퀸 문제

- 체스판에 8개의 퀸을 모두가 한 칸도 움직일 수 없도록 놓는 퀸 문제가 존재한다.
- 경우의 수는 44억개 이상인데, 답은 92개다. 즉, 44억개 이상의 후보해 속에서 실제 해 92개를 모두 찾아보라고 요구하는 것이다.
- 이 역시 백트래킹으로 쉽게 찾을 수 있다.
    1. 첫 번째 퀸을 가능한 모든 위치에 둔다. 이것이 부모 노드이다.
    2. 모든 부모 노드들에서 두 번째 퀸을 가능한 모든 위치에 둔다. 성립이 불가능한 경우라면 그 노드는 제거하고, 다른 자식 노드들을 체크해간다.
    3. 이런 식으로 8개의 퀸을 모두 놓았을 때 평형이 이루어지는 노드들 92개를 찾아낸다.
- 4*4에서 4개의 퀸 문제의 후보 해 수는 16C4 = 1820이다. 해 공간의 절반을 탐색했으니, 원래는 910개의 후보 해를 시도했어야 하지만 백트래킹을 통해 불필요한 후보해 검사량을 크게 줄였다.