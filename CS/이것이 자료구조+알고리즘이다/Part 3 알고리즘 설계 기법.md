# Chapter 11 : 알고리즘 성능 분석

## 알고리즘 성능 측정 기준

- 정확성 : 얼마나 정확히 동작하는가
- 작업량 : 얼마나 적은 비용으로 연산을 수행하는가
- 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
- 단순성 : 얼마나 단순한가
- 최적성 : 더 이상 개선할 여지가 없을 만큼 최적화되어 있는가
  
### 알고리즘 수행 시간 분석

- 보통의 알고리즘은 최악의 경우를 항상 상정하고 수행 시간을 세운다.
- 평균 시간대와 최선의 경우도 존재한다.
- 일반적으로는 점근 표기법을 사용한다.

## 점근 표기법

### O 표기법

- 최악의 경우 알고리즘 수행 시간
- 상수항과 계수는 제거하고, 가장 핵심적인 시간을 내부에 적는다.
- 퀵 정렬은 예외인데, 최악은 O(n^2)이지만 이론적인 수치이지 거의 나오지 않기 때문에 평균 시간복잡도인 O(n log n)으로 표현한다.

| O(1) | 해시 테이블 |
| --- | --- |
| O(log2n) | 이진 탐색 |
| O(n) | 순차 탐색 |
| O(n log n) | 병합 정렬, 퀵 정렬 |
| O(n^2) | 버블 정렬, 삽입 정렬 |
| O(n^3) | 행렬 곱셈 |
| O(2^n) |  |

### Ω 표기법

- 최선의 경우 알고리즘 수행 시간
- 아무리 좋은 조건을 만나도, 꼭 수행해야만 하는 최소한의 수행 시간 표현

### Θ 표기법

- 점근적 상한과 점근적 하한을 모두 만족시키는 증가 함수
- 즉 점근적으로 자신의 증가율과 같은 증가 함수
  
# Chapter 12 : 분할 정복

## 분할 정복 기법 개요

- 아우스터리츠 전투에서 탄생한 배경을 가지고 있다.
- 문제를 잘게 나누어 모두 해결하고, 그것을 합치는 기법이다.
    - 즉 분할 - 정복 - 결합이 하나의 묶음으로 되어있는 기법이다.
- 분할 정복을 통해 제곱 계산 및 피보나치 함수 계산도 쉽게 가능하다.

## 병합 정렬

- 병합 정렬의 프로세스는 아래와 같다.
    1. 데이터를 반으로 나눈다.
    2. 나눈 하위 데이터의 크기가 2 이상이라면 1의 단계를 반복한다.
    3. 동일 데이터에서 나뉜 하위 데이터 둘을 병합하며 정렬한다.
    4. 모든 데이터가 하나로 될 때까지 3을 반복한다.
- 여기서 정렬하며 합치는 부분이 가장 중요하다.
    - 두 데이터를 합한 것만큼 비어있는 데이터 공간을 마련한다.
    - 두 데이터의 첫 번째 요소들을 비교하며 더 작은 요소를 새 데이터에 추가한다.
    - 양쪽 데이터가 빌 때까지 2번을 반복한다.

# Chapter 13 : 동적 계획법

## 동적 계획법 개요

- 동적 계획법은 어떤 문제가 여러 단계의 반복되는 부분 문제로 이루어졌을 때, 각 단계에 있는 부분 문제의 답을 기반으로 전체 문제의 답을 구하는 방법이다.
- 즉, 예전에 구했던 답이 다음 문제에도 도움이 되도록 답을 재활용함을 뜻한다.
- 또, 동적 계획법은 한 번 푼 적 있는 부분 문제를 다시 푸는 일이 없도록 테이블 등에 저장한다.
- 즉, 아래와 같이 정리된다.
    1. 문제를 부분 문제로 나눈다.
    2. 가장 작은 부분 문제부터 해를 구한 뒤, 테이블에 저장한다.
    3. 테이블에 저장된 부분 문제의 해를 이용하여 점차적으로 상위 부분 문제의 최적해를 구한다.
- 단, DP로 풀 수 있는 문제는 정해져있다. 그 유형은 ‘최적 부분 구조’를 갖춰야 한다는 조건이다.
    - 이는 전체 문제의 최적해가 부분 문제의 최적해로부터 만들어지는 구조를 뜻한다.

### DP로 피보나치 수 구하기

- 그냥 단순히 재귀함수로 그 수를 구하면, 부분 피보나치 수를 얻기 위해 중복 계산이 수없이 이루어진다.
- DP를 활용하면 모든 테이블에 피보나치에 필요한 저장된 값이 저장되고, 거기서 필요한 값만 꺼내오는 방식이다.

## 최장 공통 부분 수열 (LCS)

- 부분 수열은, 어떤 수열에서 일부 요소를 제거한 수열이다.
- 즉 두 수열에서 공통된 부분 수열인데, 그 중 최장인 수열을 찾아내는 것이다.
- LCS는 두 데이터를 비교할 때 아주 유용하다. DNA 염기 서열을 비교할 때도 응용할 수 있다.
- 단순 재귀로 풀게 되면 수행 시간이 지수적으로 증가하기 때문에, DP 기반으로 만들어 개선할 수 있다.
- 가장 오른쪽 아래 모서리 요소를 시작 셀로 지정하여 백트래킹하는 방식으로, 배낭 문제와 유사하게 길이를 잡아가며 해결하게 된다.

# Chapter 14 : 탐욕 알고리즘

## 탐욕 알고리즘 개요

- 이 역시 DP처럼 최적화 문제의 답을 얻기 위해 사용한다.
- DP보다는 효율적이로 가볍고 빠르지만, DP처럼 반드시 최적해를 구해준다는 보장은 하지 못한다.
    - 기대하는 최적해는 구할 수 있다.
- 그리디 알고리즘은 다음과 같은 과정으로 동작한다.
    1. 현재 상태에서 부분 문제의 최적 해를 구한 후 이를 부분해 집합에 추가한다.
    2. 새로운 부분해 집합이 실행 가능한 것인지 확인한다.
    3. 새로운 부분해 집합이 문제의 해가 되는지 확인한다. 해가 완성되지 않았다면 1단계부터 다시 시작한다.
- 표현은 굉장히 어렵지만 아주 단순한 풀이 방법이다.
- 가장 대표적인 그리디 알고리즘의 문제는 거스름돈 줄이기 문제이다. 위 단계에 맞게 해석하면 아래와 같이 프로세스가 이루어진다.
    1. 가장 좋은 해를 고른다. 단위가 가장 큰 동전으로만 거스름돈을 만들면 개수가 줄어드니, 현재 고를 수 있는 가장 큰 단위의 동전을 고른다.
    2. 거스름돈이 손님에게 드려야 할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전은 빼고, 1단계로 돌아간다.
    3. 거스름돈이 딱 맞아야하는데, 액수가 모자라면 다시 단계 1로 돌아가 추가할 동전을 고른다.
- 그러나 그리디 알고리즘에서 거스름돈 문제는 모든 동전이 공약수로 이루어져있기 때문에 가능하다. 만약 200원, 400원짜리 동전이 있다면, 최적해를 내놓지 못한다. 즉, 그리디의 해는 항상 최적이 아니다.