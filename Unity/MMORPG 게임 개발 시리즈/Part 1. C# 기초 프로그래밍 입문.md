# **2. 개론**

- Visual Studio로 C# 기본 문법에 대해 실습
    - C#은 Microsoft에서 개발한 .NET과 함께 발표된 객체지향 프로그래밍 언어
- VS를 켠 후 C#, Windows 템플릿의 콘솔 앱에서 실습
- .NET 장기 지원 버전을 골라주고, 최상위 문 사용 안 함을 체크해주어야 함
    - 최상위 문 사용 안 함을 체크해야 기본 클래스가 생성된 상태에서 시작함
- 코드를 F5를 눌러 실행하고 나면, 프로젝트 폴더의 bin/Debug/net 폴더에 실행 파일이 생김
    - 디렉토리 주소창에 cmd.enter을 눌러 cmd를 켠 후 dir을 입력해 파일 목록 출력
    - 실행 파일 이름.exe를 입력하고 엔터를 누르면 그 코드가 실행됨

## **컴퓨터 구조**

- 메인보드의 구조를 보면, 대부분의 프로그램이 CPU가 연산하며, RAM이 메모리를 담당한다.
- 즉, 게임 역시 로직은 CPU가 처리하며, 데이터는 RAM이 담당한다.
- 단 RAM은 주기억장치로서 매우 높은 성능을 가지고 있지만, 휘발성 메모리라 컴퓨터를 종료하면 모든 메모리가 삭제되는 단점이 있다.
- 따라서, 데이터를 영구적으로 저장할 수 있는 저장장치인 보조저장장치가 존재한다.
- CPU는 굉장히 고급 인력으로, 중요한 연산을 수행하는데 바쁘다. 그러나 고성능 그래픽 연산 등의 하나하나 난이도는 낮지만 매우 많은 연산을 수행해야 하는 작업이 존재하는데, 이걸 모두 CPU가 담당하게 되면 큰 부하가 오게 된다.
- 따라서 이러한 난이도가 낮지만 많은 양을 처리하는, GPU가 별도로 존재할 수 있다.
- 원하는 게임을 실행한다면, 보조기억장치에 존재하던 게임의 데이터들 중 당장 연산이 필요한 일부가 RAM으로 올라가며, CPU의 연산과 함께 게임이 실행된다.

# **1. 데이터 갖고 놀기**

- C#의 주석 기호는 '//'과 '/* */' 이다.

```csharp
// 주석

/*  여러 줄
    주석    */
```

- 주석을 통해 TODO, 즉 언젠가 해야 할 작업에 대해 대략적인 메모를 남겨둘 수 있다.

### **데이터의 형식**

| int | 정수형 | -1, 0, 1, 2, 3 |
| --- | --- | --- |
| float | 실수형 | 3.14 |
| string | 문자열형 | “Hello” |
| bool | 불리언형 | true / false |
- 이 외에도 다양한 데이터 형식이 존재한다.
- 자신이 어떤 기능을 개발하게 되었을 때, 그 기능에 필요한 데이터들을 설계하고 적합한 형식을 미리 정해두는 것이 좋다.
    - 원하는 데이터에 최적화된 데이터를 사용할 수록, 예외적인 값이 대입되는 잘못된 상황에서 에러를 일으켜 잘못된 로직으로 번지는 일을 막을 수 있다.
- 정수형에는 변수에 넣을 수 있는 숫자의 크기에 따라 여러 타입이 존재한다.

| sbyte | -128 to 127 | 8비트 |
| --- | --- | --- |
| short | -32,768 to 32,767 | 16비트 |
| int | -2,147,483,648 to 2,147,483,647 | 32비트 |
| long | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 64비트 |

### **변수**

- 프로그램에서 데이터를 사용하려면, RAM의 메모리 공간 중 일부를 대여해서 써야 한다.
- 메모리의 모든 공간엔 주소가 할당되어 있다.
- 매 번 데이터 하나를 생성할 때마다 주소를 기입하려면 너무 번거롭기에, 이런 부분은 대부분 프로그래밍 언어와 하드웨어들이 알아서 정해준다.
- 변수는 일종의 바구니이며, 정해진 데이터 형식의 데이터를 메모리에 저장할 수 있다.
- 변수엔 데이터를 read, write / get, set할 수 있다.
- 변수의 이름엔 그 변수를 왜 쓰는지에 대한 이유를 간단하게 명시한다.
    - 예를 들어 플레이어의 체력이라면, 변수의 이름은 hp가 될 수 있다.
    - 이름을 짓는 규칙인 '컨벤션'이 존재하는데, 이는 프로젝트마다 상이하다.
- 데이터 형식과 이름을 통해 변수를 생성하고, 변수 이름에 대입 연산자를 써 원하는 데이터를 입력할 수 있다.

```csharp
int hp; // 한 줄 명령어의 끝엔 세미콜론이 붙는다.
hp = 100; // 대입 연산자(=)를 통해 원하는 변수에 값을 넣을 수 있다.
Console.WriteLine(hp); // 메모리에 저장되어있는 hp 변수의 값을 읽어와 출력한다.
```

- 변수 생성과 초기값 할당을 동시에 할 수 있다.
- hp와 maxHp같은 연관이 있는 변수의 경우, 각각 상수로 선언하기보다 기존 변수를 활용해 초기화를 하면 더 좋다.

```csharp
int maxHp = 100;

int hp = 100; // 좋지 않은 모델
int hp = maxHp; // 더 나은 모델
```

### **진법**

| 2진법 | 0b0000, 0b1010 |
| --- | --- |
| 8진법 | 0144, 012 |
| 10진법 | 0, 1, 2 |
| 16진법 | 0xA2, 0x12FFB2 |
- 10진법의 경우 0, 1, 2...
- 2진법의 경우 0b00, 0b01, 0b10...
    - 컴퓨터는 손가락 10개의 우리와 다르게 전기신호로 논리를 처리하기에, 2진법이 자연스럽다.
- 16진법의 경우 0x0, 0x1, 0xa...
- 비트 연산등을 할 때 다른 진법들이 도움이 된다.
- 16진법은 2진법을 4개 모으면 변환이 가능하다.

### **정수 범위**

- sbyte는 8비트, short는 16비트, int는 32비트, long은 64비트이다.
- sbyte는 2진수를 8개 쓰는 것이므로, 2^8 = 256개의 숫자를 표현 가능하다.
- 컴퓨터에선 최상위 비트를 부호 비트로 사용하며, 2의 보수법으로 표현한다.
    - 0111 1111의 경우엔 127이다.
    - 1111 1111의 경우엔 -1이다.
    - 1000 0000의 경우엔 -128이다.
- 이 원리때문에 sbyte의 크기가 -128부터 127이다.
- 1의 보수 방식으로 음수를 표현하게 되면 +0과 -0이 중복되어 메모리를 낭비하게 되며, 자주 쓰이게 되는 0이 전부 1비트로 표현되기 때문에 전력효율이 좋지 않다.
- 부호가 없는 (unsigned) 자료형으로 결정 시 0부터 시작하여 부호비트까지 전부 수 표현으로 쓴다.
    - 음수가 절대로 쓰일 수 없는 자료형에서 사용하면 좋다.
- 가장 중요한 것은, 데이터 크기를 아끼겠다고 작은 용량의 데이터를 사용했다가, 그것보다 더 큰 데이터가 담기게 될 일이 없도록 하는 것이다.

### float

```csharp
float f = 3.5f;
```

- 정수가 아닌 실수를 표현하는 자료형으로, 정수 그 이상으로 많이 사용된다.
- float형의 숫자를 적을 땐 반드시 숫자 뒤에 f를 붙여주어야 한다.
- float형 역시 정해진 메모리 크기가 있어서, 소수점 뒤에 아무리 많은 숫자를 적더라도 정밀도에 한계가 있어서, 소숫점 뒤의 숫자가 많아질수록 정확한 값이 저장이 안될 수 있으며, 근삿값이 저장된다.
- float와 유사한 부동소수형 데이터 타입인 double이 존재하며, double 데이터 타입엔 숫자를 대입할 때 f를 적지 않아도 된다.
    - 메모리를 더 많이 차지하는 대신, 더 정밀하게 저장할 수 있는 장점이 있다.
    - 그러나 특별한 상황이 아닌 이상 float가 대부분 사용된다.

### string

```csharp
char ch = 'S';
string name = "Suldangoo";
```

- 여러 개의 문자를 나열하여 저장할 수 있는 자료형이다.
- int나 float와 다르게, 역사가 좀 더 최근에 개발된 자료형이기 때문에 다양한 기능이 내장되어있다.
- 문자를 하나만 담는 자료형으로는 char형이 있다.
    - char형은 C++에선 1바이트지만, C#에선 2바이트이다.
- 컴퓨터가 한글, 영어, 중국어 등을 이해하고 저장할 수 있는 것은, 해당 글자와 매칭되는 정수를 저장하고 인코딩을 하는 원리이기 때문이다.
    - 인코딩 방식엔 ASCII, Unicode, UTF-8, 16 등등 다양한 포맷이 존재한다.

### boolean

```csharp
bool isAdmin = true;
bool isAutoPlay = false;
```

- 오로지 true와 false만을 저장하게 되는 아주 작은 데이터 타입.
- 컴퓨터 로직 내에서 true와 false만을 사용하는 경우가 매우 잦기 때문에 존재하는 근간이 되는 자료형이다.
- true와 false는 앞 글자를 소문자로 표기한다.

### 캐스팅

```csharp
int a = 100;
short b = a; // 에러 및 경고가 발생한다.
short b = (short)a;

float c = 3.14;
int d = (int)c;
```

- 데이터의 타입, 형식을 변환하는 것을 캐스팅이라고 한다.
- int → short 처럼 큰 타입에서 작은 타입으로 하는 변환은 너무나 위험하기 때문에 하지 않는 것이 좋다.
- 캐스팅을 하는 방법으로는, 바꾸고싶은 데이터 앞에 소괄호를 씌워 원하는 데이터 타입을 작성하면 된다.
- 그러나 short → int, int → float같은 크기가 비교적 작은 데이터에서 큰 데이터로 옮기거나, 옮겼을 때 호환성에 문제가 없다면 캐스팅 없이도 옮겨질 수 있다.
- C, C++에선 이런 캐스팅 위반에서도 에러가 뜨진 않고 경고만 뜨지만, C#은 이런 상황을 에러라고 인지하고 컴파일시켜주지 않는다.

### 스트링 포맷

```csharp
int a = 100;
string b = (string)a; // 에러가 난다.

string input = Console.ReadLine();
int number = int.Parse(input);

// 아래는 캐스팅은 아니지만, 스트링 포맷
string message = string.Format("당신의 HP는 {0} 입니다.", a);
string message = $"당신의 HP는 {a} 입니다.";
```

- 그러나 int → string은 얘기가 조금 다른데, string은 원시 자료형이 아닌 클래스이기 때문에 간단하게 형변환이 되지 않는다.
- 이렇게 원시 자료형과 클래스간, 혹은 클래스와 클래스간 형변환을 위해선 해당 데이터 타입만을 위한 캐스팅 메서드를 따로 사용해주어야 한다. 메서드나 방법은 여러가지이다.

| string → int | int.Parse(스트링 변수); |
| --- | --- |
| int → string | 인트 변수.ToString(); |

### 산술 연산 (데이터 가공)

```csharp
int hp = 100;
int damage = 10;

hp = hp - damage;
```

- 기본적인 사칙연산, 나머지, 괄호 연산 등은 여타 프로그래밍 언어와 동일하다.
    - 나누기, 나머지를 0으로 하게 되면 당연히 에러가 터진다.
- int 대상으로 나누기 연산을 하게 되면, 소수점 아래 부분은 모두 버려진다.
- float 나누기 int를 하게 되면, 결과로는 float가 나온다.
```jsx
// 축약대입연산자
a += 5;
a *= 2;

a++; // 후위 대입
a--;
++a; // 전위 대입
--a;
```

- 후위 대입은 해당 명령을 실행한 후 연산이 실행된다.
- 전위 대입은 해당 명령을 실행하기 전 연산이 실행된다.

### 비교 연산

```jsx
int a; = 10;
int b; = 5;

a >= b; // true
a == b; // false
a != b; // true
```

- 분기점을 만들기 위한 첫 번째 단계
- CPU가 두 변수를 가져와 연산한다.

### 논리 연산

- 여러가지 조건을 한 번에 파악하거나, 혼합하여 논리적으로 결과를 추론하는 것.
- AND, OR, NOT, XOR 등이 존재한다.

```csharp
&& // AND
|| // OR
! // NOT
```

- 논리연산자를 통해 연산한 결괏값은, 반드시 boolean 형태의 true / false로 나타나게 된다.
- OR 연산자는 C#, C++에서 단축 평가를 사용하고 있기 때문에, 앞 조건이 true가 나온다면 뒤 연산을 절대로 실행하지 않는다.
    - 때문에 오른쪽 조건에 함수 호출이나 사이드 이펙트가 있다면 이 함수가 실행되지 않을 수도 있음을 반드시 염두에 두어야 한다.
### 데이터 마무리

```csharp
var a = 10;
var b = 3.14f;
var c = "Rookiss";
```

- var 타입을 사용하게 되면, 컴파일하는 단계에서 뒤에 담긴 데이터 타입을 보고 자료형을 즉석에서 정해준다.
- 매우 좋아보이지만, 그럼에도 불구하고 직접적으로 타입을 지정해주는게 더 좋다. 그래야 코드의 가독성과 직관성이 매우 좋아지기 때문이다.

# **3. 코드의 흐름 제어**

### if와 else, 분기문

```csharp
if (isDead) { // 첫 번째 중괄호의 위치 (컨벤션)은 팀마다 다르다.
	Console.WriteLine("");
}
else if (isAlive) {
	Console.WriteLine("");
}
else {
	Console.WriteLine("");
}
```

- else if 와 else문을 사용하지 않고, 모두 if문을 사용할 수도 있지만, 그럴 경우 논리적으로 실행되지 않아도 되는 조건문마저 크로스체크를 하여 조금씩 성능을 갉아먹을 수 있다.
- 물론 논리적으로 if문 여러개를 쓰는 것이 정답인 코드가 있을 수 있으니, 코드의 논리를 잘 따져야 한다.

### switch

```csharp
int choice = 0; // 0:가위 1:바위 2:보

switch (choice) {
	case 0 : // case에 대해서는 중괄호를 쓰지 않고, 콜론을 사용한다.
		break; // break를 수행하지 않으면, 아래의 모든 명령어들을 전부 수행한다.
	case 1 :
		break;
	case 2 :
		break;
	default :
		break;
}
```

- switch-case문에서 내부엔 문자열이나 정수를 넣을 수 있다.
    - 최신 C#에서 객체를 넣을 수도 있게 되었다.
- switch-case문으로 적을 수 있는 논리는 모두 if-else로 표현할 수 있다.
- 그러나 if-else로 표현할 수 있는 모든 논리를 switch-case로 표현하지는 못한다.
    - 명제의 역은 참이 아니다.
- 가독성이 참 좋으므로 switch문을 쓰는게 적합한 상황에선 if-else보다 우선적으로 사용한다.

```csharp
// 삼항연산자
int number = 25;

bool isPair = (number % 2) == 0 ? true : false;
```

- 삼항연산자는 취향에 따라 가독성을 나쁘다고 생각하는 개발자도 있다.
- 그러나 잘 숙지하여 다른 개발자가 적은 삼항연산자는 반드시 읽을 줄 알아야 한다.

### 가위바위보

```csharp
Random rand = new Random();
int aiChoice = rand.Next(0, 3); // 0 ~ 2 사이의 랜덤 값

int choice = Convert.ToInt32(Console.ReadLine());

switch (choice) {
	case 0 :
		Console.WriteLine("당신의 선택은 가위입니다.");
		break;
	case 1 :
		Console.WriteLine("당신의 선택은 바위입니다.");
		break;
	case 2 :
		Console.WriteLine("당신의 선택은 보입니다.");
		break;
}

switch (aiChoice) {
	case 0 :
		Console.WriteLine("컴퓨터의 선택은 가위입니다.");
		break;
	case 1 :
		Console.WriteLine("컴퓨터의 선택은 바위입니다.");
		break;
	case 2 :
		Console.WriteLine("컴퓨터의 선택은 보입니다.");
		break;
}

int result; // 승패를 가리는 변수, 0은 무승부, 1은 승리, 2는 패배

// 승패판정
if (choice == aiChoice) {
	result = 0;
}
else if ((choice == 0 && aiChoice == 2) ||
				 (choice == 1 && aiChoice == 0) ||
				 (choice == 2 && aiChoice == 1)) {
	result = 1;
}
else {
	result = 2;
}

switch (result) {
	case 0 :
		Console.WriteLine("비겼습니다.");
		break;
	case 1 :
		Console.WriteLine("승리하였습니다.");
		break;
	case 2 :
		Console.WriteLine("패배하였습니다.");
		break;
}
```

### 상수와 열거형

- 위 가위바위보 코드에서, 우리는 가위, 바위, 보를 숫자 0, 1, 2로 정의했다.
- 이렇게 int 변수의 수에 원하는 정의를 내리니, 코딩도 복잡하며, 추후에 유지관리가 매우 힘들다.
- 이렇게 강제로, 임의적으로 숫자에 의미를 박아넣는 것은 하드코딩이며, 절대로 해선 안될 일이다.

```csharp
const int ROCK = 1; // 전부 대문자를 씀으로서 절대 변하면 안되는 변수라는것을 표시
const int PAPER = 2;
const int SCISSORS = 0;

switch (choice) {
	case SCISSORS :
		Console.WriteLine("당신의 선택은 가위입니다.");
		break;
	case ROCK :
		Console.WriteLine("당신의 선택은 바위입니다.");
		break;
	case PAPER :
		Console.WriteLine("당신의 선택은 보입니다.");
		break;
}
```

- switch-case 문에서 case 뒤에, 값이 유동적으로 변하는 변수는 절대 들어갈 수 없다.
    - 반드시 값이 절대 변하지 않는, 상수가 들어가야 한다.
- 따라서 변수 설정 앞에 const를 넣음으로서 해당 변수를 상수화하고, switch-case문으로도 사용 가능하게 한다.
- 상수를 사용하는 것도 좋지만, 이름이 겹치지 않게 조심해야 하며, 각 변수가 서로 연관이 있는 개념임에도 서로 하나의 그룹으로서 사용할 수 없다.
    - 이 때 사용하는 것이 Enum, 열거형이다.

```csharp
class Program {
	enum Choice { // 열거형 생성
		Rock = 1, // 뒤에 값을 정의하지 않으면 알아서 위에부터 0이 된다.
		Paper = 2,
		Scissors = 0
	}
	
	static void Main(string[] args) {
		// ...
		
		switch (choice) {
			case (int)Choice.Scissors :
				Console.WriteLine("당신의 선택은 가위입니다.");
				break;
			case (int)Choice.Rock :
				Console.WriteLine("당신의 선택은 바위입니다.");
				break;
			case (int)Choice.Paper :
				Console.WriteLine("당신의 선택은 보입니다.");
				break;
		}
	}
}
```

- Enum으로 만들어 하나의 그룹으로서 묶어 자료형처럼 사용할 수 있다.
- Enum으로 선언한 값이 숫자처럼 보여도, Enum 타입이기 때문에 (int)로 한 번 캐스팅을 거쳐주어야 한다.
- 상수든 Enum이든 코드에 따라 맞는, 좋은 타입을 설정하면 되고, 중요한 것은 코드 로직 내부에 숫자를 박아 하드코딩을 하는 일이 없도록 하는 것이다.