# Chapter 05 : 정렬

## 정렬의 개요

- 정렬은 정해진 데이터를 기준에 따라 순서대로, 체계적으로 정리하는 알고리즘이다.
- 정렬을 하는 이유는 ‘탐색’ 때문이다. 정렬된 데이터들은 이진 탐색 등의 아주 효율적인 탐색이 가능해지며, 상위나 하위의 데이터들을 빠르고 쉽게 탐색할 수 있기 때문이다.
- 정렬의 고전 알고리즘엔 버블 정렬, 삽입 정렬, 선택 정렬, 퀵 정렬 등이 존재한다.

## 버블 정렬

- 자료구조를 순회하여 이웃한 요소들끼리 데이터를 교환하며 정렬을 수행하는 방식이다.
- 이동하는 배열 요소의 길이가 반드시 이웃되어있다.
- 오름차순 정렬을 기준으로 가장 뒤에서부터 큰 값이 순차적으로 들어온다.
- 단, 버블 정렬은 다른 정렬 알고리즘들보다도 성능이 좋지 않다.
    - O(n^2)에 상수 계수도 높지만, 안정 정렬이라는 특성이 있다.

## 삽입 정렬

- 책장에 꽂힌 책을 제자리에 꽂는 과정과 유사하다.
- 순차적으로 자료구조를 순회하며 순서에 어긋나는 요소를 올바른 위치에 삽입하는 알고리즘이다.
- 순서에 맞는 곳에 끼워넣을 때, 기존에 있는 요소와 자리를 바꾼다.
- 버블 정렬과 같게 O(n^2)이지만 상수계수가 낮고 버블 정렬보다는 효율적이다.

## 퀵 정렬

- 퀵 정렬은 분할정복에 바탕을 둔 알고리즘이다.
- 기준 요소 (Pivot)을 정하고, 그보다 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 나누는 반복이다.
    - 기준 선정 → 분할과 정복 → 반복이다.
- 이걸 코드로 구현할 때 약간의 문제가 있다.
    - 배열을 사용한다면 퀵 정렬의 분할과정은 어떻게 해야 할까?
        - 피벗을 기준으로 노드를 이동시킬 때 링크드 리스트는 삽입과 삭제가 편하지만, 배열은 오버헤드가 심하다. 따라서 배열의 경우엔 기준 요소를 찾았다면 그보다 작은 값, 큰 값을 각각 찾아 순서를 교체하는 방식으로 구현한다.
    - 반복되는 분할 과정을 어떻게 구현할까?
        - 이는 재귀함수로 쉽게 구현할 수 있다. 퀵 소트 함수를 만들고, 가장 왼쪽부터 기준까지와 기준부터 가장 오른쪽까지의 범위를 재귀함수로 구현할 수 있다.
- 퀵 정렬은 위 두 정려보다 훨씬 시간복잡도가 빠르고 효율적이다.
    - 분할정복인 점에서 O(n log n)의 시간복잡도를 가진다.
    - 단 퀵정렬은 이론상 최악의 경우 O(n^2)이 나올 수도 있지만, 이론상으로의 수치이지 흔한 수치가 아니여서 이걸 시간복잡도로 치지 않는다.
- C언어에서는 기본적으로 표준 라이브러리의 퀵 정렬 함수 qsort()가 존재한다.
  <aside>
🎮

RPG 게임에서 인벤토리에 희귀도순이나 획득 순 정렬은 많이 보았을 것이다.
그 외에도 리더보드에서 점수를 정렬할 때도 정렬을 많이 쓰는데, 이 경우엔 정렬 알고리즘보다는 실시간 갱신을 위해 우선순위 큐를 사용하는 것이 효율적이다.

보통 게임 내에서 정렬을 직접 구현할 일은 없지만, 사용한다면 퀵 정렬, 병합 정렬을 많이 사용한다.

</aside>

# Chapter 06 : 탐색

## 탐색의 개요

- 데이터를 찾는 알고리즘이다.
- 가장 원시적이면서도 확실하지만 비효율적인 탐색은 처음부터 끝까지 하나씩 열람해보기이다.
- 그러나 정렬된 배열에선 이진 탐색 등이 가능해진다.

## 순차 탐색

- 우직하게 처음부터 끝까지 모든 요소를 비교하여 데이터를 찾는 탐색 알고리즘이다.
- 성능은 좋지 않지만 정렬되지 않은 배열에서 가장 신뢰도가 높다.
- 데이터 크기가 작고 버그를 만들 가능성이 적을 때 유용하다.
- 보통 데이터를 탐색할 땐 자주 사용되는 항목이 데이터 앞쪽에 배치되는것이 좋다.

### 전진 이동법

- 탐색된 항목을 데이터의 가장 앞으로 옮기는 방법이다.
- MS 워드의 최근 문서 목록과 같은 기능이다.
- 한 번 탐색된 항목이 다음에 또 다시 검색될 가능성이 높은 데이터에 한해 사용한다.

### 전위법

- 전위는 위치를 바꾼다는 뜻으로, 탐색된 항목을 이전 항목과 교환하는 전략을 취하는 알고리즘이다.
- 포인트는 한 칸만 앞으로 옮기는 것이다. 크게 점프를 뛰어 앞에있는게 뒤로 가지는 않는다.
- 자주 탐색된 항목을 조금씩 앞으로 옮기는 방식이다.

### 계수법

- 데이터 내 각 요소가 탐색된 횟수를 별도의 공간에 저장, 횟수가 높은 순으로 데이터를 재구성하는 전략의 알고리즘이다.
- 전위법을 사용하면 처음부터 앞에 있던 데이터는 계속해서 선두를 유지할 가능성이 높다. 그러나 계수법을 사용하면 확실히 데이터의 사용 빈도에 따라 정렬이 된다.
- 그러나 이도 단점이 있는데, 별도의 공간을 유지해야 하고 계수 결과에 따라 재배치하는 데에 비용이 많이 든다.

## 이진 탐색

- 정렬된 데이터에서 사용할 수 있는 고속 탐색 알고리즘이다. 탐색 범위가 절반씩 줄어들기에 O(log n)의 시간 복잡도가 소요된다.
    - 중앙에 있는 요소를 고르고, 목표값과 비교하여 작다면 왼쪽, 크다면 오른쪽으로 포인터를 이동한다.
    - 포인터와 탐색값이 일치하면 리턴한다.
- 처음엔 1/2, 다음엔 1/4, 그 다음엔 1/8… 탐색 범위가 절반씩 줄어들기 때문에 O(log n)이 걸리게 된다.
- 이진 탐색 구현의 경우엔 Left와 Right 변수를 사용하여 if문으로 절반씩 줄여가도록 하면 된다.
- C언어에서의 표준 라이브러리의 이진 탐색 함수는 bsearch()이다.
    - 첫 번째 매개변수로 찾고자 하는 목표값 데이터 주소, 두 번째 매개변수로 데이터 배열의 주소를 가리키는 포인터, 세 번째 매개변수로 데이터 요소의 개수, 즉 크기를 입력한다.

## 이진 탐색 트리

- 이진 탐색을 위한 트리이자, 탐색을 위한 이진 트리
- 이진 탐색 자체는 정렬된 배열에만 사용할 수 있는 알고리즘이기 떄문에, 링크드 리스트로는 위와 같은 작업이 불가능하다. 링크드 리스트는 헤드와 테일 사이 중앙 요소를 알 수 없기 때문이다.
- 즉 링크드 리스트에서도 이진 탐색을 하기 위해 이진 탐색 트리를 활용할 수 있는 것이다.
- 이진 트리는 왼쪽 자식 노드가 나보다 작고, 오른쪽 자식 노드가 나보다 크다.
- 탐색은 노드의 크기를 보고 왼쪽, 혹은 오른쪽으로 이동하며, 삽입 역시 같다.
- 그러나 이진 탐색 트리에서의 삭제는 좀 까다롭다. 특유의 뒤처리가 굉장히 어렵기 때문이다.
    - 삭제하는 노드가 잎 노드라면 문제될 것이 없다.
    - 그러나 자식이 있는 경우엔, 자식이 한 개이거나 두 개인 경우가 각각 다르다.
    - 자식이 하나라면 자식이 자신의 자리를 대체하여 부모 선이 새로 그어진다.
    - 자식이 두 개라면, 삭제된 노드의 우측 하위 트리에서 최솟값 노드를 찾아 삭제된 노드로 위치를 옮겨야 한다.
- 그러나 이진 트리도 문제점이 있다. 편향 트리가 되어버리면 배열과 다를게 없어 효율이 극단적으로 떨어진다.
- 따라서 스스로 균형을 잡는 알고리즘을 지닌 트리가 나타난다.

## 레드 블랙 트리

- 스스로 균형있게 높이가 유지되고, 회전연산을 통해 왼쪽 서브 트리와 오른쪽 서브 트리가 높이 차이가 크게 나지 않는 트리 중 가장 많이 쓰이는 트리가 레드 블랙 트리이다.
- 레드 블랙 트리는 enum을 통해 RED 혹은 BLACK의 컬러를 가지게 된다.
- 레드 블랙 트리의 규칙은 다음과 같다.
    - 모든 노드는 빨간색이거나 검은색이다.
    - 뿌리 노드는 검은색이며, 잎 노드도 검은색이다.
    - 빨간 노드의 자식은 모두 검은색이다.
        - 검은색 노드는 검은색 노드나 빨간색 노드 모두 자식으로 가질 수 있다.
    - 뿌리 노드와 모든 잎 노드 사이에 있는 검은색 노드의 수는 모두 동일하다.
- 잎 노드는 NIL로 표시되어, 아무 데이터도 갖고 있지 않지만 색만 검은 색인 더미 노드이다. 이걸 센티넬 노드라고 한다.
- 굳이 더미 노드인 센티넬 노드를 쓰는 이유는, 레드 블랙 트리의 구현을 용이하게 만들기 위해서이다.
    - NIL 노드를 양쪽 자식으로 연결하면, 모든 잎 노드는 검은색이다라는 규칙이 항상 지켜질 수 있기 때문이다.
- 회전 연산을 통해서 부모와 자식 노드의 위치를 바꾸고, 균형을 조정할 수 있다.

<aside>
🎮

게임에서 탐색은 큰 의미를 가진다.

게임은 그 어떤 소프트웨어들보다 탐색을 정말 많이 쓰는 종류 중 하나이다. 플레이어를 검색하거나, 몬스터를 검색하거나, 아이템을 검색하는 일이 비일비재하게 많이 일어나는데, 몬스터도 객체지향에선 수많은 종류가 있기 때문에 ID를 통해 몬스터를 검색하거나, 이름을 통해 검색하는 등 프로그래머가 특정 오브젝트를 검색해야하는 일이 많이 일어난다.

하지만 맵 속에 존재하는 모든 오브젝트에서 원하는 오브젝트를 찾기 위해선, 정렬되어있지 않은 맵에서 불규칙적인 오브젝트를 찾는 것이기에 반드시 순차 탐색을 해야 한다. 이는 그렇게 좋지 않은 성능을 보여준다.

따라서 보통은 게임 엔진 내에서 최적화된, 내장 탐색 메서드를 쓴다. 이를 통해 ID로 검색을 하거나 이미 지정된 오브젝트를 바로 불러올 수 있다.

게임 컨텐츠 내에서 직접 탐색을 구현할 땐, 이진 탐색이 도움될 수 있다. 특히나 이진 트리는 게임 내에서 많이 사용되는 편이므로, 탐색 알고리즘을 만들어 유저에게 편의적인 기능을 제공하는 것 또한 가능하다.

</aside>

# Chapter 07 : 우선순위 큐와 힙

## 우선순위 큐 개요

- 일반적으로 선입 선출의 자료구조를 큐라고 했었다. 그러나 우선순위 큐는 나오는 순서가 들어왔던 순서대로가 아닌, 요소들의 우선순위가 높은 것이 먼저 나오는 특수한 형태의 큐이다.
- 우선순위 큐는 우선순위 속성을 갖는 데이터의 삽입과 제거 연산을 지원하는 ADT이다.
- 한 마디로 큐의 내부 속성이 우선순위대로 정렬되며, 먼저 들어온 것이 크게 의미가 없는 큐이다.

## 힙

- 이 힙은 프로그래밍 언어에서 사용하는 자유 저장소 (Free Store) 의 힙이 아니다.
- 힙은 순서 속성을 만족하는 완전 이진 트리이다.
- 힙 순서 속성상 트리 내의 모든 노드가 부모 노드보다 커야 한다는 규칙이 있다.
    - 이것이 최소 힙이다.
- 이진 탐색은 불가능하지만, 힙에서 가장 작은 데이터를 갖는 노드는 뿌리 노드라는 것은 확실하다.

### 힙의 삽입 연산

- 새로운 노드가 추가되면, 완전 이진 트리를 유지하는 가장 끝에 노드를 추가한다.
- 이후 부모 노드와 크기를 비교하여, 자신이 더 작다면 부모와 순서를 교환한다.
    - 이것이 그만 교환될 때까지 계속해서 부모와 비교해 반복한다.

### 힙의 삭제 연산

- 최솟값 삭제는 부모 노드를 삭제하면 된다.
- 이후 완전 이진 트리의 가장 끝 요소를 부모로 대신 임명한다.
- 이후 자신의 두 자식 중 더 작은 값과 위치를 바꾸며 반복해 내려간다.

### 힙의 구현

- 힌은 배열로 구현할 수 있다. 깊이 0의 뿌리 노드가 배열의 0번 인덱스인 것이다.
- 0번 인덱스가 뿌리, 1번, 2번 인덱스가 깊이 1, 3, 4, 5, 6번 인덱스가 깊이 2… 같은 식이다.
- 즉 왼쪽 자식 노드는 2k + 1, 오른쪽 자식 노드는 2k + 2이다.
- 힙을 구현할 수 있다면 우선순위 큐 역시 구현할 수 있는 것이나 마찬가지이다.

# Chapter 08 : 해시 테이블

## 해시 테이블 개요

- 해시(Hash)는 데이터를 다른 모습으로 변환하는 것이다.
    - 여기서 핵심은, 똑같은 데이터라면 몇번을 반복하던 항상 같은 모양으로 변환되는 것이다.
    - 또한 변한 모양을 가지고 원래의 데이터를 추측할 수 없는 보안성도 지니고 있다.
- 해시 테이블은 이 해시 함수를 활용해서, 데이터 그 자체가 배열의 인덱스처럼 주소의 역할을 하여 자료를 찾을 때 해당 자료를 해싱하여 데이터를 빠르게 탐색하는 방법이다.
- 특정 데이터를 해싱한 값이 주소, 해당 주소의 공간에 데이터를 저장하는 방식이다.
- 단, 해시 테이블은 말 그대로 공간을 팔아 성능을 얻은 것이기 때문에 메모리를 많이 잡아먹는다.

## 해시 함수

### 나눗셈법

- 가장 간단한 알고리즘의 해시 함수이다.
- 주소 = 입력값 % 테이블의 크기 이다.
- 해시 테이블의 특성상 테이블의 크기 n을 소수로 정하는 것이 좋다. 특히 2의 제곱수와 거리가 먼 소수를 사용하는 해시 함수가 좋은 성능을 낸다.

### 자릿수 접기

- 나눗셈법은 단순해서 좋으나, 성능적으로 어딘가 조금 아쉬운 알고리즘이다.
    - 서로 다른 입력값에 동일한 해시값을 반환하는, 해시 충돌 가능성이 높기 때문이다.
    - 또한 똑같은 값이 아니더라도, 한 곳에 집중적으로 데이터가 모이는 클러스터 문제가 발생할 가능성이 높다.
- 물론 충돌과 클러스터링을 완벽히 해결하는 해시 함수는 아직까지 존재하지 않는다.
    - 그러나 이 문제가 나올 가능성을 줄인 알고리즘은 당연히 존재한다.
- 자연수의 나열이 있다면, 모든 자릿수의 수를 더하여 새로운 수를 만드는 방식이다.
    - 혹은 두자리씩 묶어 더하거나, 방법은 다양하다.
- 자릿수 접기는 문자열을 키로 쓸때 굉장히 좋다. 각 문자를 아스키코드로 바꾸고, 이 값들을 더해 접으면 깔끔하게 주소로 변환시킬 수 있기 때문이다.
- 그러나 단순히 이렇게만 하면 최소한 앞의 데이터 배열 중 일부 공간을 아예 쓸 수가 없다. 따라서 공간을 아끼기 위해 해시 함수를 고쳐, 왼쪽으로 3비트씩 밀어 낭비하는 공간이 없게끔 할 수도 있다.

## 충돌 해결 기법

- 해시 테이블 외부에 새로운 데이터를 두어 해결하는 것이 개방 해싱이다.
- 해시 테이블 내부에서 문제를 해결하는 것이 폐쇄 해싱이다.

### 체이닝

- 해시 함수에서 같은 값이 나온걸 수용하는 방식이다.
- 해시 테이블의 각 요소에 링크드 리스트의 헤드 주소를 담는다. 이후 해당 해시 테이블에 새로운 데이터가 들어가면 해당 링크드 리스트에 데이터를 담는 방식이다.
- 이렇게 해시 테이블 외부에 데이터를 저장하는 방식인 체이닝은 개방 해싱 알고리즘이다.
- 이 경우, 해시 함수를 수정할 필욘 없지만 삽입과 삭제는 수정해야 한다.
    - 삽입은 앞으로 일어날 충돌을 고려해서, 삭제는 이미 발생한 충돌을 고려해 설계해야 한다.
- 물론 굳이 해시테이블까지 와서 링크드 리스트를 쓰는건 조금 억울할 수 있지만, 링크드 리스트를 이진 탐색 트리로 둔다면 굉장히 좋은 선택이 된다. 해시 충돌 자체가 자주 일어나는 일이 아니기 때문이다.

### 개방 주소법

- 충돌이 일어날 때 해시 함수에 의해 만들어진 주소가 아니더라도, 추가 변형을 해 다른 주소를 사용하도록 하는 충돌 해결 알고리즘이다.
- 선형 탐사는 가장 간단한 개방 주소법이다. 만약 충돌이 나면 다음 주소를 선형적으로 탐색해 빈 공간에 데이터를 적재하는 방법이다.
- 제곱 탐사는 선형 탐사와 크게 다르지 않다. 이동의 폭이 고정이 아닌, 제곱수로 늘어나는 것이다. 이 방법을 통해 한 공간에 데이터가 몰리는 클러스터링 문제를 방지할 수 있다.
    - 1의 제곱인 1, 2의 제곱인 4, 3의 제곱인 9로 이동하게 된다.
- 탐사 주소의 규칙성을 없앤다면 클러스터를 방지할 수 있다. 이 때 쓰는 좋은 방법은 이중 해싱이다.
    - 데이터를 적재할 때 데이터를 해싱하여 주소로 한 번, 이동폭을 제 2의 해시 함수로 계산하는 것이다.
    - 즉 데이터를 아예 다른 두 개의 해시 함수로 전부 적용해 주소와 이동폭을 모두 정하는 것이다.

### 재해싱

- 해시 충돌이 일어나는 이유 중 하나는 해시 테이블의 공간이 부족한 것 때문이다.
- 즉 데이터가 많이 찬 배열을 다시 늘이는 방안이 필요하고, 이것이 재해싱이다.
- 통계적으로 해시 테이블의 공간 사용률이 70~80%면 성능 저하가 일어난다.

# Chapter 09 : 그래프

## 그래프 개요

- 구글 맵 등에서 최단경로를 찾아주는 기능이 그래프에서의 최단 경로 알고리즘 바탕이다.
- 이는 러시아의 발트해 연안 도시인 칼리닌그라드에서 시작했다.
    - 이 도시를 가로지르는 강이 하나 있는데, 이 강의 이름은 프레겔이다.
    - 콰니히스베르크를 네조각으로 가르며 흐르는데, 시민들은 프레겔 강이 조각낸 도시를 연결하기 위해 7개의 다리를 건설했다.
    - 그러다 사람들 사이에서 7개의 다리를 한 번씩만 건너서 도시 전체를 모두 밟는 방법을 찾아보기 시작했다.
    - 이 문제를 푼 것이 바로 위대한 수학자, 레온하르트 오일러이다.
    - 땅과 다리를 활용해 정점과 간선을 만들고, 한붓그리기가 되는지 확인해보았으나, 모든 점에서의 경로가 홀수개이기 때문에 한붓그리기가 불가능함을 밝혀냈다.

## 그래프의 정의

- 정점의 모음과 이 정점을 잇는 간선의 모음이라고 표현할 수 있다.
- 정확히는, 정점의 집합을 V, 간선의 집합을 E, 그래프가 G일 때, G = (V, E)이다.
- 간선으로 연결된 두 정점을 가리켜 서로 인접, 또는 이웃 관계에 있다고 한다.
- 또한 한 정점에서 다른 정점까지 경로가 만들어진다. 경로는 길이를 가지고 있고, 정점과 정점 사이의 간선 수가 길이가 된다.
- 또한 그래프는 방향성이 있는 그래프와 무방향성 그래프가 별도로 존재한다.

### 그래프의 표현

- 그래프는 우선 인접 행렬로 표현할 수 있다. 정점의 수만큼 행과 열이 있고, 그 행렬 안에 간선이 있다면 1, 없다면 0으로 표현하는 것이다.
    - 만약 방향성 그래프라서 간선이 여러 개 있다면 그 간선의 수만큼 행렬 내 수를 채우면 되는 것이다.
    - 무방향성 그래프는 대각선을 기준으로 대칭하지만, 방향성 그래프는 대칭하지 않을 수 있다.
- 또한 인접 리스트로도 표현할 수 있다. 정점 번호가 Key라면, 그 정점에 연결된 정점들을 Value 안에 연결 리스트 형태로 만드는 것이다.
    - 즉, 인접 리스트는 자료구조 상 연결 리스트로 표현할 수 있다.
- 인접 행렬을 이용하면 정점 간 인접 여부를 빠르게 알 수 있지만, 행렬 형태로 저장하기 위해 메모리 양이 정점의 크기 x N^2만큼 커진다는 단점이 있다.
- 인접 리스트는 정점 간의 인접 여부를 알려면 인접 리스트를 타고 순차 탐색을 해야한다는 단점이 있지만, 정점과 간선 삽입이 빠르고 관계를 표시하는 리스트에 사용되는 메모리의 양이 적다는 장점이 있다.

## 그래프 순회 기법

- 여러가지 그래프 탐색 기법이 있지만, 가장 유명한것은 역시 깊이 우선 탐색과 너비 우선 탐색이다.
- 너비 우선 탐색은 그래프에서 최단 경로를 찾는 알고리즘의 기반이 되고, 깊이 우선 탐색은 그래프 정렬 알고리즘의 기반이 된다.