# **2. 개론**

- Visual Studio로 C# 기본 문법에 대해 실습
    - C#은 Microsoft에서 개발한 .NET과 함께 발표된 객체지향 프로그래밍 언어
- VS를 켠 후 C#, Windows 템플릿의 콘솔 앱에서 실습
- .NET 장기 지원 버전을 골라주고, 최상위 문 사용 안 함을 체크해주어야 함
    - 최상위 문 사용 안 함을 체크해야 기본 클래스가 생성된 상태에서 시작함
- 코드를 F5를 눌러 실행하고 나면, 프로젝트 폴더의 bin/Debug/net 폴더에 실행 파일이 생김
    - 디렉토리 주소창에 cmd.enter을 눌러 cmd를 켠 후 dir을 입력해 파일 목록 출력
    - 실행 파일 이름.exe를 입력하고 엔터를 누르면 그 코드가 실행됨

## **컴퓨터 구조**

- 메인보드의 구조를 보면, 대부분의 프로그램이 CPU가 연산하며, RAM이 메모리를 담당한다.
- 즉, 게임 역시 로직은 CPU가 처리하며, 데이터는 RAM이 담당한다.
- 단 RAM은 주기억장치로서 매우 높은 성능을 가지고 있지만, 휘발성 메모리라 컴퓨터를 종료하면 모든 메모리가 삭제되는 단점이 있다.
- 따라서, 데이터를 영구적으로 저장할 수 있는 저장장치인 보조저장장치가 존재한다.
- CPU는 굉장히 고급 인력으로, 중요한 연산을 수행하는데 바쁘다. 그러나 고성능 그래픽 연산 등의 하나하나 난이도는 낮지만 매우 많은 연산을 수행해야 하는 작업이 존재하는데, 이걸 모두 CPU가 담당하게 되면 큰 부하가 오게 된다.
- 따라서 이러한 난이도가 낮지만 많은 양을 처리하는, GPU가 별도로 존재할 수 있다.
- 원하는 게임을 실행한다면, 보조기억장치에 존재하던 게임의 데이터들 중 당장 연산이 필요한 일부가 RAM으로 올라가며, CPU의 연산과 함께 게임이 실행된다.

# **1. 데이터 갖고 놀기**

- C#의 주석 기호는 '//'과 '/* */' 이다.

```csharp
// 주석

/*  여러 줄
    주석    */
```

- 주석을 통해 TODO, 즉 언젠가 해야 할 작업에 대해 대략적인 메모를 남겨둘 수 있다.

### **데이터의 형식**

| int | 정수형 | -1, 0, 1, 2, 3 |
| --- | --- | --- |
| float | 실수형 | 3.14 |
| string | 문자열형 | “Hello” |
| bool | 불리언형 | true / false |
- 이 외에도 다양한 데이터 형식이 존재한다.
- 자신이 어떤 기능을 개발하게 되었을 때, 그 기능에 필요한 데이터들을 설계하고 적합한 형식을 미리 정해두는 것이 좋다.
    - 원하는 데이터에 최적화된 데이터를 사용할 수록, 예외적인 값이 대입되는 잘못된 상황에서 에러를 일으켜 잘못된 로직으로 번지는 일을 막을 수 있다.
- 정수형에는 변수에 넣을 수 있는 숫자의 크기에 따라 여러 타입이 존재한다.

| sbyte | -128 to 127 | 8비트 |
| --- | --- | --- |
| short | -32,768 to 32,767 | 16비트 |
| int | -2,147,483,648 to 2,147,483,647 | 32비트 |
| long | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | 64비트 |

### **변수**

- 프로그램에서 데이터를 사용하려면, RAM의 메모리 공간 중 일부를 대여해서 써야 한다.
- 메모리의 모든 공간엔 주소가 할당되어 있다.
- 매 번 데이터 하나를 생성할 때마다 주소를 기입하려면 너무 번거롭기에, 이런 부분은 대부분 프로그래밍 언어와 하드웨어들이 알아서 정해준다.
- 변수는 일종의 바구니이며, 정해진 데이터 형식의 데이터를 메모리에 저장할 수 있다.
- 변수엔 데이터를 read, write / get, set할 수 있다.
- 변수의 이름엔 그 변수를 왜 쓰는지에 대한 이유를 간단하게 명시한다.
    - 예를 들어 플레이어의 체력이라면, 변수의 이름은 hp가 될 수 있다.
    - 이름을 짓는 규칙인 '컨벤션'이 존재하는데, 이는 프로젝트마다 상이하다.
- 데이터 형식과 이름을 통해 변수를 생성하고, 변수 이름에 대입 연산자를 써 원하는 데이터를 입력할 수 있다.

```csharp
int hp; // 한 줄 명령어의 끝엔 세미콜론이 붙는다.
hp = 100; // 대입 연산자(=)를 통해 원하는 변수에 값을 넣을 수 있다.
Console.WriteLine(hp); // 메모리에 저장되어있는 hp 변수의 값을 읽어와 출력한다.
```

- 변수 생성과 초기값 할당을 동시에 할 수 있다.
- hp와 maxHp같은 연관이 있는 변수의 경우, 각각 상수로 선언하기보다 기존 변수를 활용해 초기화를 하면 더 좋다.

```csharp
int maxHp = 100;

int hp = 100; // 좋지 않은 모델
int hp = maxHp; // 더 나은 모델
```

### **진법**

| 2진법 | 0b0000, 0b1010 |
| --- | --- |
| 8진법 | 0144, 012 |
| 10진법 | 0, 1, 2 |
| 16진법 | 0xA2, 0x12FFB2 |
- 10진법의 경우 0, 1, 2...
- 2진법의 경우 0b00, 0b01, 0b10...
    - 컴퓨터는 손가락 10개의 우리와 다르게 전기신호로 논리를 처리하기에, 2진법이 자연스럽다.
- 16진법의 경우 0x0, 0x1, 0xa...
- 비트 연산등을 할 때 다른 진법들이 도움이 된다.
- 16진법은 2진법을 4개 모으면 변환이 가능하다.

### **정수 범위**

- sbyte는 8비트, short는 16비트, int는 32비트, long은 64비트이다.
- sbyte는 2진수를 8개 쓰는 것이므로, 2^8 = 256개의 숫자를 표현 가능하다.
- 컴퓨터에선 최상위 비트를 부호 비트로 사용하며, 2의 보수법으로 표현한다.
    - 0111 1111의 경우엔 127이다.
    - 1111 1111의 경우엔 -1이다.
    - 1000 0000의 경우엔 -128이다.
- 이 원리때문에 sbyte의 크기가 -128부터 127이다.
- 1의 보수 방식으로 음수를 표현하게 되면 +0과 -0이 중복되어 메모리를 낭비하게 되며, 자주 쓰이게 되는 0이 전부 1비트로 표현되기 때문에 전력효율이 좋지 않다.
- 부호가 없는 (unsigned) 자료형으로 결정 시 0부터 시작하여 부호비트까지 전부 수 표현으로 쓴다.
    - 음수가 절대로 쓰일 수 없는 자료형에서 사용하면 좋다.
- 가장 중요한 것은, 데이터 크기를 아끼겠다고 작은 용량의 데이터를 사용했다가, 그것보다 더 큰 데이터가 담기게 될 일이 없도록 하는 것이다.

### float

```csharp
float f = 3.5f;
```

- 정수가 아닌 실수를 표현하는 자료형으로, 정수 그 이상으로 많이 사용된다.
- float형의 숫자를 적을 땐 반드시 숫자 뒤에 f를 붙여주어야 한다.
- float형 역시 정해진 메모리 크기가 있어서, 소수점 뒤에 아무리 많은 숫자를 적더라도 정밀도에 한계가 있어서, 소숫점 뒤의 숫자가 많아질수록 정확한 값이 저장이 안될 수 있으며, 근삿값이 저장된다.
- float와 유사한 부동소수형 데이터 타입인 double이 존재하며, double 데이터 타입엔 숫자를 대입할 때 f를 적지 않아도 된다.
    - 메모리를 더 많이 차지하는 대신, 더 정밀하게 저장할 수 있는 장점이 있다.
    - 그러나 특별한 상황이 아닌 이상 float가 대부분 사용된다.

### string

```csharp
char ch = 'S';
string name = "Suldangoo";
```

- 여러 개의 문자를 나열하여 저장할 수 있는 자료형이다.
- int나 float와 다르게, 역사가 좀 더 최근에 개발된 자료형이기 때문에 다양한 기능이 내장되어있다.
- 문자를 하나만 담는 자료형으로는 char형이 있다.
    - char형은 C++에선 1바이트지만, C#에선 2바이트이다.
- 컴퓨터가 한글, 영어, 중국어 등을 이해하고 저장할 수 있는 것은, 해당 글자와 매칭되는 정수를 저장하고 인코딩을 하는 원리이기 때문이다.
    - 인코딩 방식엔 ASCII, Unicode, UTF-8, 16 등등 다양한 포맷이 존재한다.

### boolean

```csharp
bool isAdmin = true;
bool isAutoPlay = false;
```

- 오로지 true와 false만을 저장하게 되는 아주 작은 데이터 타입.
- 컴퓨터 로직 내에서 true와 false만을 사용하는 경우가 매우 잦기 때문에 존재하는 근간이 되는 자료형이다.
- true와 false는 앞 글자를 소문자로 표기한다.

### 캐스팅

```csharp
int a = 100;
short b = a; // 에러 및 경고가 발생한다.
short b = (short)a;

float c = 3.14;
int d = (int)c;
```

- 데이터의 타입, 형식을 변환하는 것을 캐스팅이라고 한다.
- int → short 처럼 큰 타입에서 작은 타입으로 하는 변환은 너무나 위험하기 때문에 하지 않는 것이 좋다.
- 캐스팅을 하는 방법으로는, 바꾸고싶은 데이터 앞에 소괄호를 씌워 원하는 데이터 타입을 작성하면 된다.
- 그러나 short → int, int → float같은 크기가 비교적 작은 데이터에서 큰 데이터로 옮기거나, 옮겼을 때 호환성에 문제가 없다면 캐스팅 없이도 옮겨질 수 있다.
- C, C++에선 이런 캐스팅 위반에서도 에러가 뜨진 않고 경고만 뜨지만, C#은 이런 상황을 에러라고 인지하고 컴파일시켜주지 않는다.

### 스트링 포맷

```csharp
int a = 100;
string b = (string)a; // 에러가 난다.

string input = Console.ReadLine();
int number = int.Parse(input);

// 아래는 캐스팅은 아니지만, 스트링 포맷
string message = string.Format("당신의 HP는 {0} 입니다.", a);
string message = $"당신의 HP는 {a} 입니다.";
```

- 그러나 int → string은 얘기가 조금 다른데, string은 원시 자료형이 아닌 클래스이기 때문에 간단하게 형변환이 되지 않는다.
- 이렇게 원시 자료형과 클래스간, 혹은 클래스와 클래스간 형변환을 위해선 해당 데이터 타입만을 위한 캐스팅 메서드를 따로 사용해주어야 한다. 메서드나 방법은 여러가지이다.

| string → int | int.Parse(스트링 변수); |
| --- | --- |
| int → string | 인트 변수.ToString(); |

### 산술 연산 (데이터 가공)

```csharp
int hp = 100;
int damage = 10;

hp = hp - damage;
```

- 기본적인 사칙연산, 나머지, 괄호 연산 등은 여타 프로그래밍 언어와 동일하다.
    - 나누기, 나머지를 0으로 하게 되면 당연히 에러가 터진다.
- int 대상으로 나누기 연산을 하게 되면, 소수점 아래 부분은 모두 버려진다.
- float 나누기 int를 하게 되면, 결과로는 float가 나온다.
```jsx
// 축약대입연산자
a += 5;
a *= 2;

a++; // 후위 대입
a--;
++a; // 전위 대입
--a;
```

- 후위 대입은 해당 명령을 실행한 후 연산이 실행된다.
- 전위 대입은 해당 명령을 실행하기 전 연산이 실행된다.

### 비교 연산

```jsx
int a; = 10;
int b; = 5;

a >= b; // true
a == b; // false
a != b; // true
```

- 분기점을 만들기 위한 첫 번째 단계
- CPU가 두 변수를 가져와 연산한다.

### 논리 연산

- 여러가지 조건을 한 번에 파악하거나, 혼합하여 논리적으로 결과를 추론하는 것.
- AND, OR, NOT, XOR 등이 존재한다.

```csharp
&& // AND
|| // OR
! // NOT
```

- 논리연산자를 통해 연산한 결괏값은, 반드시 boolean 형태의 true / false로 나타나게 된다.
- OR 연산자는 C#, C++에서 단축 평가를 사용하고 있기 때문에, 앞 조건이 true가 나온다면 뒤 연산을 절대로 실행하지 않는다.
    - 때문에 오른쪽 조건에 함수 호출이나 사이드 이펙트가 있다면 이 함수가 실행되지 않을 수도 있음을 반드시 염두에 두어야 한다.
### 데이터 마무리

```csharp
var a = 10;
var b = 3.14f;
var c = "Rookiss";
```

- var 타입을 사용하게 되면, 컴파일하는 단계에서 뒤에 담긴 데이터 타입을 보고 자료형을 즉석에서 정해준다.
- 매우 좋아보이지만, 그럼에도 불구하고 직접적으로 타입을 지정해주는게 더 좋다. 그래야 코드의 가독성과 직관성이 매우 좋아지기 때문이다.

# **3. 코드의 흐름 제어**

### if와 else, 분기문

```csharp
if (isDead) { // 첫 번째 중괄호의 위치 (컨벤션)은 팀마다 다르다.
	Console.WriteLine("");
}
else if (isAlive) {
	Console.WriteLine("");
}
else {
	Console.WriteLine("");
}
```

- else if 와 else문을 사용하지 않고, 모두 if문을 사용할 수도 있지만, 그럴 경우 논리적으로 실행되지 않아도 되는 조건문마저 크로스체크를 하여 조금씩 성능을 갉아먹을 수 있다.
- 물론 논리적으로 if문 여러개를 쓰는 것이 정답인 코드가 있을 수 있으니, 코드의 논리를 잘 따져야 한다.

### switch

```csharp
int choice = 0; // 0:가위 1:바위 2:보

switch (choice) {
	case 0 : // case에 대해서는 중괄호를 쓰지 않고, 콜론을 사용한다.
		break; // break를 수행하지 않으면, 아래의 모든 명령어들을 전부 수행한다.
	case 1 :
		break;
	case 2 :
		break;
	default :
		break;
}
```

- switch-case문에서 내부엔 문자열이나 정수를 넣을 수 있다.
    - 최신 C#에서 객체를 넣을 수도 있게 되었다.
- switch-case문으로 적을 수 있는 논리는 모두 if-else로 표현할 수 있다.
- 그러나 if-else로 표현할 수 있는 모든 논리를 switch-case로 표현하지는 못한다.
    - 명제의 역은 참이 아니다.
- 가독성이 참 좋으므로 switch문을 쓰는게 적합한 상황에선 if-else보다 우선적으로 사용한다.

```csharp
// 삼항연산자
int number = 25;

bool isPair = (number % 2) == 0 ? true : false;
```

- 삼항연산자는 취향에 따라 가독성을 나쁘다고 생각하는 개발자도 있다.
- 그러나 잘 숙지하여 다른 개발자가 적은 삼항연산자는 반드시 읽을 줄 알아야 한다.

### 가위바위보

```csharp
Random rand = new Random();
int aiChoice = rand.Next(0, 3); // 0 ~ 2 사이의 랜덤 값

int choice = Convert.ToInt32(Console.ReadLine());

switch (choice) {
	case 0 :
		Console.WriteLine("당신의 선택은 가위입니다.");
		break;
	case 1 :
		Console.WriteLine("당신의 선택은 바위입니다.");
		break;
	case 2 :
		Console.WriteLine("당신의 선택은 보입니다.");
		break;
}

switch (aiChoice) {
	case 0 :
		Console.WriteLine("컴퓨터의 선택은 가위입니다.");
		break;
	case 1 :
		Console.WriteLine("컴퓨터의 선택은 바위입니다.");
		break;
	case 2 :
		Console.WriteLine("컴퓨터의 선택은 보입니다.");
		break;
}

int result; // 승패를 가리는 변수, 0은 무승부, 1은 승리, 2는 패배

// 승패판정
if (choice == aiChoice) {
	result = 0;
}
else if ((choice == 0 && aiChoice == 2) ||
				 (choice == 1 && aiChoice == 0) ||
				 (choice == 2 && aiChoice == 1)) {
	result = 1;
}
else {
	result = 2;
}

switch (result) {
	case 0 :
		Console.WriteLine("비겼습니다.");
		break;
	case 1 :
		Console.WriteLine("승리하였습니다.");
		break;
	case 2 :
		Console.WriteLine("패배하였습니다.");
		break;
}
```

### 상수와 열거형

- 위 가위바위보 코드에서, 우리는 가위, 바위, 보를 숫자 0, 1, 2로 정의했다.
- 이렇게 int 변수의 수에 원하는 정의를 내리니, 코딩도 복잡하며, 추후에 유지관리가 매우 힘들다.
- 이렇게 강제로, 임의적으로 숫자에 의미를 박아넣는 것은 하드코딩이며, 절대로 해선 안될 일이다.

```csharp
const int ROCK = 1; // 전부 대문자를 씀으로서 절대 변하면 안되는 변수라는것을 표시
const int PAPER = 2;
const int SCISSORS = 0;

switch (choice) {
	case SCISSORS :
		Console.WriteLine("당신의 선택은 가위입니다.");
		break;
	case ROCK :
		Console.WriteLine("당신의 선택은 바위입니다.");
		break;
	case PAPER :
		Console.WriteLine("당신의 선택은 보입니다.");
		break;
}
```

- switch-case 문에서 case 뒤에, 값이 유동적으로 변하는 변수는 절대 들어갈 수 없다.
    - 반드시 값이 절대 변하지 않는, 상수가 들어가야 한다.
- 따라서 변수 설정 앞에 const를 넣음으로서 해당 변수를 상수화하고, switch-case문으로도 사용 가능하게 한다.
- 상수를 사용하는 것도 좋지만, 이름이 겹치지 않게 조심해야 하며, 각 변수가 서로 연관이 있는 개념임에도 서로 하나의 그룹으로서 사용할 수 없다.
    - 이 때 사용하는 것이 Enum, 열거형이다.

```csharp
class Program {
	enum Choice { // 열거형 생성
		Rock = 1, // 뒤에 값을 정의하지 않으면 알아서 위에부터 0이 된다.
		Paper = 2,
		Scissors = 0
	}
	
	static void Main(string[] args) {
		// ...
		
		switch (choice) {
			case (int)Choice.Scissors :
				Console.WriteLine("당신의 선택은 가위입니다.");
				break;
			case (int)Choice.Rock :
				Console.WriteLine("당신의 선택은 바위입니다.");
				break;
			case (int)Choice.Paper :
				Console.WriteLine("당신의 선택은 보입니다.");
				break;
		}
	}
}
```

- Enum으로 만들어 하나의 그룹으로서 묶어 자료형처럼 사용할 수 있다.
- Enum으로 선언한 값이 숫자처럼 보여도, Enum 타입이기 때문에 (int)로 한 번 캐스팅을 거쳐주어야 한다.
- 상수든 Enum이든 코드에 따라 맞는, 좋은 타입을 설정하면 되고, 중요한 것은 코드 로직 내부에 숫자를 박아 하드코딩을 하는 일이 없도록 하는 것이다.

### while (반복문)

```csharp
while (조건) {
	...
	
	조건의 변화
}
```

- 조건이 참이라면 아래의 행동을 수행하고, 다시 조건을 체크한다.
- 조건이 바뀌지 않고 계속 참이라면, 무한한 루프를 돌게 된다.
- 반복문을 짤 때 가장 중요한 것은 조건을 제대로 논리적이게 설정하는 것이다.

```csharp
do {
	...
	
	조건의 변화
} while ();
```

- do-while문은 일단은 한 번 실행한 다음, 그 후에 조건을 체크해 빠져나갈지를 결정한다.
- 대부분 그냥 while문을 사용하지만, 꼭 한번 실행해야 하는 상황에선 do-while문을 가끔 사용한다.
    - 예를 들어 로그인 같은 경우이다.
- while, do-while 모두 조건 변수를 그 내부에 정의해서는 안된다.
    - 이는 해당 로컬 변수의 유효 범위를 벗어나는 곳에서 참조를 하려는 행위이기 때문이다.
    - 이런 유효 범위를 스코프라고 한다.

### for

```csharp
for (초기화 식; 조건식; 반복식) {
	...
}
```

- for문이 맨 처음 돌아가기 전, 초기화를 한 번 한다.
- 반복문의 조건을 작성한다.
- 매 번 반복할 때마다 계속해서 호출되어야 할 반복식을 작성한다.
- 이렇게 초기설정을 해두면, 반복문에서 논리적으로 필요한 내용을 미리 작성해두고 시작할 수 있다.
    - 그러나 이 초기값들은 필수 작성이 아니고, 필요한 경우 작성할 수 있다.
- while문은 조건에 담은 객체가 작동 도중 계속 유기적으로 변하여서 언제 끝날 지 모를 때 사용하면 매우 좋다.
    - 예를 들어 스택이나 큐를 넣어두고 DFS, BFS를 구현할 수 있다.
- for문은 특정 횟수만큼 반복해야 할 때 매우 좋다.
- while문도, for문도 조건 안 비교 연산자를 <로 할지, ≤로 할지도 잘 고민해야 한다.

### break, continue

```csharp
for (~) {
	// 특정 조건에서 빠져나가고 싶은 경우
	break;
	
	// 특정 조건에서 아래 명령들을 스킵하고 다음 반복으로 가고싶은 경우
	continue
}
```

- break문은 해당 중괄호만 나가는게 아니라, for문 등 큰 반복문의 키워드가 범위이다.
- continue로 해당 페이지를 빠져나갔다면, 당연히 조건 변수에 증감을 주는 반복식은 실행이 된다.

### 함수 (메소드)

- 지금까지의 코딩은 main 안에 모든걸 욱여넣는 방식
- 이제부터 재사용될 코드들은 하나로 묶어서 하나의 기능으로 캡슐화해야한다.
- 해당 명령어의 묶음을 사용하는 걸 메소드를 사용한다고 한다.
    - C#에서는 메소드지만, 다른 언어에선 펑션, 함수, 프로시저 등등 많은 용어가 있다.

```csharp
한정자 반환형식 이름(매개변수) {

}

static void HelloWorld() {
	...
}

static int Add(int a, int b) {
	return a + b;
}

static void Main(string[] args) {
	HelloWorld();
}
```

- class 안에 Main 함수를 포함하여, 원하는 메서드를 작성한다.
- return 값에  따라 반환 형식을 결정해야 한다.

```csharp
static void AddOne(int n) {
	n++;
}

static void Main(string[] args) {
	int a = 0;
	AddOne(a); // 이거 해도, 값은 1이 아닌, 0 그대로 유지된다.
}
```

- 상식적으로 위 함수에 a를 넣어 변수 값이 1 늘어날 것 같지만, 절대 아니다.
- 변수를 넘기는 방법엔 복사와 참조가 있는데, 여기선 복사로 주기 때문에 완전히 다른 변수가 된다.

```csharp
static void AddOne(ref int n) {
	n++;
}

static void Main(string[] args) {
	int a = 0;
	AddOne(ref a); // 이거 해도, 값은 1이 아닌, 0 그대로 유지된다.
}
```

- 단, 파라미터와 호출 변수에 ref를 넣으면, 그때부턴 복사가 아닌 참조로 파라메터를 가져온다.
- 이렇게 되면 실제로 넣는 원본 변수에 영향을 끼치게 된다.

### ref, out

- ref로 원본을 변화하는 모델과, 그냥 원래 메소드 방식으로 return받는 모델 중 후자가 훨씬 더 범용적이고 코드 디자인적으로 좋다.
- 그럼에도 swap() 함수 등 실제로 ref를 쓰는 편이 좋은 부분도 분명 있다.
- 반대로, 파라메터에 out을 넣어서 원하는 변수만 리턴시키는 기능도 존재한다.

```csharp
static void Divide(int a, int b, out int result1, out int result2) {
	result1 = a / b;
	result2 = a % b;
}

static void Main(string[] args) {
	int result1;
	int result2;
	
	Divide(10, 3, out result1, out result2);
}
```

- out 키워드를 넣음으로서, 해당 함수에서 그 변수에 일어난 결괏값을 그대로 적용해줄수도 있다.
    - 값을 여러개 반환할 경우엔 out을 사용한다.
- ref는 그 파라메터를 넣지 않아도 되지만, out은 반드시 리턴할 변수를 넣어주어야 해서 오류를 잡아준다.
- 또한 반환형이 int인 함수에서 float를 반환할 수 있는 등, 복수의 리턴이 필요할 때 굉장히 좋다.

### 오버로딩

- 메소드 오버로딩, 함수 오버로딩은 과적하다라는 뜻을 가진다.
- 프로그래밍에선, 함수 이름의 재사용을 뜻한다.

```csharp
static int Add(int a, int b) {
	return a + b;
}

static int Add2() {}
static int Add3() {} // 이름을 이렇게 계속 새로 지으며 비슷한 역할을 하는 것은 좋지 않다.

static int Add(float a, float b) { // 파라미터가 다르다면 함수 이름이 같아도 된다.
	return a + b;
}
```

- 파라미터가 반드시 다르다는 가정하에, 같은 함수의 이름을 재사용할 수 있다.
- 그 경우, 함수를 호출하고 호출한 파라미터에 넣는 값에 맞는 함수가 알아서 골라 사용된다.
- 중요한 것은, 파라미터와 이름은 같은데 반환형식이 다른것은 절대 오버로딩이 되지 않는다.

```csharp
static int Add(int a, int b, int c = 1) { // 선택적 매개변수
	return a + b + c;
}
```

- 파라미터, 매개변수에 미리 값을 하나 초기화시킨것을 함수 정의에 작성하면, 해당 인자에 아무런 값을 넣지 않을 경우 알아서 default값을 사용하게 된다.
    - 즉, 필수 파라미터와 옵션 파라미터를 정할 수 있다.
- 만약 넣을 것이라면, 파라미터의 순서를 굉장히 잘 신경써야 한다.
- 호출할 때 파라미터의 순서에서, C++은 그 호출 순서도 신경써야 하지만, C#은 다르다.

```csharp
Add(1, 2, d:2.0f); // 원하는 파라미터에 원하는 값을 넣도록 명시할 수 있다.
```

- 순서와 관계없이 원하는 파라미터에 원하는 값을 넣도록 명시할 수 있다.

### 연습문제

- 구구단

```csharp
namespace CSharp
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 2; i < 10; i++)
            {
                for (int j = 1; j < 10; j++)
                {
                    Console.WriteLine($"{i} * {j} = {i * j}");
                }
            }
        }
    }
}
```

- 별찍기

```csharp
namespace CSharp
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 1; i <= 5; i++)
            {
                for (int j = 1; j <= i; j++)
                {
                    Console.Write("*");
                }
                Console.WriteLine();
            }
        }
    }
}
```

- 팩토리얼

```csharp
using System;

namespace CSharp
{
    class Program
    {
        static int Factorial(int n)
        {
            int result = 1;

            while(n > 1)
            {
                result *= n;
                n--;
            } 

            return result;
        }

        static void Main(string[] args)
        {
            int ret = Factorial(5);
            Console.WriteLine(ret);
        }
    }
}
```

```csharp
using System;

namespace CSharp
{
    class Program
    {
        static int Factorial(int n)
        {
            if (n <= 0)
                return 1;

            return n * Factorial(n - 1);
        }

        static void Main(string[] args)
        {
            int ret = Factorial(5);
            Console.WriteLine(ret);
        }
    }
}
```

# 4. TextRPG

### 디버깅 기초

- 모든 프로그래머는, 프로그래밍보다 디버깅을 훨씬 더 많이 한다.
- 디버깅이란 의사가 환자를 진료하는 것과 같은 의미로, 프로그래머가 한 줄씩 코드를 실행시켜보고, 변수를 바꿔가며 코드에 문제가 있는지, 있다면 어디에 있는지 찾아내는 행위이다.
- VS에서 코드 한 줄의 맨 왼쪽 영역을 클릭하거나, F9를 누르면 브레이크 포인트를 찍는다.
    - 프로그램을 실행하다가 해당 브레이크 포인트에서 일시정지하는 의미이다.
- 해당 장면에서 멈춘 다음, 여러가지 정보를 열람할 수 있는데, 호출 스택이나 변수들의 값을 확인할 수 있다.
- F10을 눌러 프로시저 단위로 실행할 수 있다.
    - 프로시저 단위로 실행하면, 메서드나 함수 단위를 한 번에 실행하고 바로 다음으로 간다.
- F11을 눌러 한 줄씩 실행할 수 있다.
    - 한 줄씩 가면, 호출하는 메서드나 함수로 들어가서 또 한 줄씩 실행하게 된다.
    - 그 때 조사식이라는 것을 보면, 메서드에 들어간 값을 조회할 수 있고, 심지어 변경도 할 수 있다.
- 메소드 안에서 메소드를 호출하면, 콜스택에 함수들이 쌓이며, 함수안에서 실행된 함수가 종료되면, 그 전에 있던 함수로 복귀하게 된다. 이 과정에서 호출 스택을 다루게 되고, 디버깅 과정에서 호출 스택을 볼 수 있다.
- 즉, 몇천줄의 코드 안에서 어떤 메소드 안에 브레이크 포인트를 찍고 실행하게 되면, 호출 스택을 보고 어떤 메서드를 통해 여기까지 도달했는지 알 수 있다.
- VS에선, 종단점. 즉 브레이크 포인트에 조건을 걸어버릴 수 있다! 브레이크 포인트에 우클릭을 하고 조건을 적어놓으면, 해당 조건에 걸릴 때만 브레이크 포인트가 작동을 하게 된다.
- 심지어 브레이크 포인트로 일시정지되었다면, 왼쪽 화살표를 드래그해 조작함으로서 원하는 명령어를 더 실행하게 하는 등, 마음대로 실행 순서를 조작할 수도 있다.

### 게임 제작

- 캐릭터 직업 등, 하나로 묶을 수 있으며 타입이 정해지는 경우엔 Enum을 설정하면 매우 도움이 된다.
- 그리고 직업을 고르는 메서드를 만든다면, 메서드의 반환 타입을 Enum으로 만들었던 ClassType으로 두어 해당 직업을 리턴하는 방식으로 메서드를 만들면 예쁜 구조가 된다.
- 이제 직업에 따라 hp, attack 등을 정해야 할 때, 가장 좋은 구조는 구조체를 만드는 것이지만 우선 거기까지 진도를 나가지 않았으므로, 두 개 이상의 변수를 한 번에 리턴받아야 한다.

```csharp
static void CreatePlayer(out int hp, out int attack) {
 ...
}

int hp;
int attack;
CreatePlayer(out hp, out attack);
```

- 따라서 이렇게 하나의 static 메서드에 out으로, 복사가 아닌 참조 방식으로 두 개 이상의 변수를 한 번에 처리하게 만들 수 있다.
    - out 파라미터가 있는 함수 내부를 구현할 때는, 항상 해당 함수 내에서 out을 무슨 값이든 정의를 해주어야 한다. 그렇지 않으면 에러를 낸다.
    - switch-case 문 등을 사용할 경우, 반드시 default를 사용하여 값을 0이라도 주어야 한다.

### 구조체

- 만약 플레이어의 데이터 컬럼이 Hp, Attack 뿐만 아닌 Mp, Dex, Int, 기타 등등의 수십개의 속성이 생겨나게 되면, 위 사항처럼 하나하나를 out으로 전부 지정하는 것은 여간 귀찮은 일이 아니다.
- 구조체는 내가 원하는 데이터의 모음집을, 자료형과 관계 없이 하나로 모아 묶어 논리 단위를 만드는 것이다.
- struct 예약어를 통해 Enum처럼 정의할 수 있다.

```csharp
struct Player {
	public int hp; // 접근지정자를 public으로 하지 않으면, 기본적으로는 은닉한다.
	public int attack;
	public ClaasType type;
}
```

- 그렇게 되면 해당 구조체를, 하나의 변수 자료형으로서 새로 정의하고, 초기화하여, 이곳저곳에 할당할 수 있게 된다.

```csharp
Player player; // 해당 구조체로 새로운 객체 생성
player.hp = 100; // 해당 객체의 hp 멤버에 값을 초기화
```

# 5. 객체지향 여행

### 객체지향의 시작

- 기존에 하던 것은 절차(procedure)지향으로, 함수를 기반으로 무언가를 만드는 것이다.
- 지금까지 어떤 기능을 만들고자 하면, 해당 기능을 하는 함수를 만들고, 조립하여 프로그램을 만들었다.
- 작고 빠른 방식으로 프로젝트를 진행할 땐 직관적이고 좋으나, 프로젝트가 커질수록 유지보수가 어려워진다.
- 함수 호출 순서가 가장 중요한 이슈가 된다.
    - 어떤 함수 안에서 함수를 호출할 때가 특히 그렇다. 만약 기획이 변경되면 전체적인 코드 흐름을 전부 수정해야하는 문제가 생긴다.
- **객체지향(OOP; Object Oriented Programming)**은, 모든 것을 객체 위주로 생각해서 프로그래밍하는 방식이다.
- 플레이어, 몬스터, NPC, 화살 등 게임 내 모든 것들이 전부 하나의 객체로서 존재하게 된다.
- 객체의 구성 요소는 **속성과 기능**으로 분류할 수 있다.
    - 속성 : hp, attack, pos 등등 데이터
    - 기능 : Move, Attack, Die 등등 해당 객체가 수행하는 행동
- 객체를 정의한다는 것은 붕어빵 틀과 유사하다. 객체를 정의한 후, 실제로 해당 객체가 필요할 때 객체를 찍어내면 된다.

```csharp
class Knight
{
	public int hp; // 접근 지정자는 보통 private로 두고, getter와 setter를 두는 편이다.
	public int attack;
	
	public void Move()
	{
		Console.WriteLine("Knight's Move");
	}
}
```
- 이렇게 만든 객체 설계도로, 메인 코드에서 객체를 생성할 수 있다.

```csharp
Knight knight = new Knight(); // new는 해당 객체를 새로 생성한다는 생성자이다.

knight.hp = 100;
knight.attack = 10;

knight.Move();
```

### 복사와 참조

- 다른 표현으로는 얕은 복사, 깊은 복사라고도 한다.

```csharp
class Knight // 클래스
{
	public int hp;
	public int attack;
}

struct Mage // 구조체
{
	public int hp;
	public int attack;
}

// 같은 역할인데 무엇이 다를까?
```

- 클래스는 요소에 대해 **참조**를 하고, 구조체는 **복사**를 한다.
- 클래스로 만든 객체가 다른 함수에 참조되어 값이 변경될 경우, 주소를 참조하기 때문에, ref 등의 연산자를 쓰지 않아도 그 객체 원본에 그대로 영향을 미치게 된다.
- 단 구조체는 해당 값을 복사한 다른 것이 넘어가기 때문에 원본엔 영향을 끼치지 않는다.
    - 거기에 더불어 구조체는 new 생성자를 쓸 필요가 없다.

```csharp
Knight knight2 = knight;

// 위와 같은 경우, 기존 knight의 주소를 참조해 넘겨주기에 둘은 같은 객체이며, 이름만 두 개가 생겼을 뿐이다.
// 정말 두 개의 객체를 원한다면

Knight knight2 = new Knight();
```

- 혹은 깊은 복사라 하여, 해당 객체 안에 새로운 메서드로 새 객체를 생성해 리턴하게 한다면 깊은 복사가 이루어져 새로운 원본이 만들어진다.

### 스택과 힙

- 프로그램을 실행하면, 운영체제에서 해당 프로그램이 쓸 메모리 영역을 준다.
- 하나는 **스택 메모리**, 하나는 **힙 메모리**이다. 물론 이것 말고도 다른 영역도 있다.
    - 스택 메모리는 불안정하고, 일시적이다.
    - 함수 안에서만 쓰는 지역 변수라던가, 함수 콜스택 위치를 저장한다.
- 구조체와 같은 복사되는 값은 메모리에 본체, 원본이 들어간다.
- 그러나 참조형인 클래스는, 메모리 안에 주소값이 들어간다.
    - 여기서 그럼 참조형의 원본은 어디있나? 한다면, 그곳이 바로 힙 메모리이다.
- 그렇다고 모든 참조가 전부 힙을 가리키고 있다고 생각하면 안된다. ref 구조체를 하게 될 경우, 참조하는 주소값이 stack  내부일 수 있다.
- 스택 영역은 프로그래머가 신경쓸 필요 없다. 공간의 크기가 알아서 늘어나고 줄어들기 때문에, 다 사용한 지역 변수도 전부 회수되기 때문에 자료구조적으로 관리 난이도가 매우 쉽다.
- 그러나 힙 영역은 한 번 메모리를 할당하고 아무런 행동도 하지 않으면 메모리를 그대로 낭비하게 된다. 따라서 언어에 따라 다르지만, 프로그래머가 반드시 메모리를 해제해야한다.
- C#은 특정 객체를 그 어떤 변수도 참조하고있지 않을 때 알아서 메모리를 해제하기 때문에, 메모리 관리 측면에서 C/C++보단 조금 더 난이도가 쉽다.

### 생성자

- 지금까지는 new로 객체 생성 후, 일일히 수동으로 속성값을 넣어주었다.
- 생성자를 사용하면 객체 생성과 동시에 속성값을 설정할 수 있다.

```csharp
class Knight
{
	public int hp;
	public int attack;
	
	public Knight() // 생성자는 클래스와 같은 이름으로, 그 무엇도 붙여선 안된다.
	{
		hp = 100;
		attack = 10;
		Console.WriteLine("기사 생성");
	}
	
	public Knight(int hp) // 인자를 받는 오버로딩이 가능하다.
	{
		this.hp = hp; // 이름이 같기 때문에 문법적 오류를 방지하기 위해 this를 쓴다.
	}
	
	public void Move()
	{
		Console.WriteLine("Knight's Move");
	}
}
```
- 위 예제에서 생성자를 오버로딩 한 부분이 attack를 빼먹었다.
- 물론 새로 쓸 수도 있지만, 코드가 너무 길어지고, 다루는 속성도 많은데 이걸 전부 관리할 수는 없으니, **빈 생성자를 우선 실행한 뒤 값을 덮어씌우는 개념**으로 접근하는 기능이 있다.

```csharp
public Knight(int hp) : this() // 빈 생성자를 우선 실행한다.
{
	this.hp = hp; // 그 후에 원하는 값을 덮어씌우게 된다.
}
```

- 이 기능을 Base라고 하며, Java에서 super와 유사한 개념이다.

### static의 정체

- static이 붙지 않은 클래스 내 필드(속성과 메서드들)는 여러 개의 객체, 인스턴스 내에서 독립적으로 기능하게 된다.
    - Knight1과 Knight2가 둘 다 공격이라는 메서드가 있어도, 둘의 성장에 따라서 공격력의 차이가 다를 수도 있다는 것이다.
- 그러나 static, 정적이라는 키워드가 붙었다면, 해당 필드는 해당 클래스의 객체에 종속되는 것이 아닌, **해당 클래스 자체에 종속**되게 된다.
    - **오로지 하나만 존재**한다는 것이 매우 중요하다.
    - Knight 클래스에서 객체를 수백개 뽑았어도, 그 수백개의 객체는 단 하나의 static 변수를 서로 공유해서 쓰고 있는 것이다.
- 필드에 사용할 수 있으므로 변수뿐만이 아닌 함수, 메서드에도 static을 사용할 수 있다.
    - 이렇게 되면 해당 클래스에 종속되어서, 객체에서 발동하는게 아닌 클래스 자체로 발동하는 것이 가능하다.
    - 중요한 것은, 모든 클래스가 사용하기 때문에, **static 메서드 내부에선 필드 변수 값을 건드릴 수 없다! this 키워드는 당연히 사용하지 못한다.**
    - static 메서드 안에서는 static 필드만 수정할 수 있게 되는 것이다.

```csharp
// 일반적인 메서드를 호출할 때
Knight knight = new Knight(); // 객체 생성
knight.Attack(); // 해당 객체가 해당 행동 수행

// static 메서드를 호출할 때
Knight.Attack(); // 클래스 자체가 해당 행동을 수행하기에, 객체와 무관
```

### 상속성

- 객체지향의 3대 속성을 얘기하라고 한다면 **은닉성, 상속성, 다형성**이 있다.
- 여러 개의 RPG 직업이 있을 때, Hp나 공격력 등의 중복된 속성들이 정말 많음
- 이런 많은 속성을 전부 다 일일히 만들어버리는 것은 정말 비효율적인 작업
- 기사, 궁수, 법사, 도적을 모두 묶을 수 있는 부모 클래스를 만들어 상속시키면 된다.

```csharp
class Player
{

}

class Knight : Player // 콜론을 찍어 상속하고자 하는 부모 클래스의 이름 명시
{

}
```
- 자식 클래스를 생성하게 되면, 부모의 생성자를 우선 실행한 후 자식의 생성자를 실행하게 된다.
- 단 base를 사용하면, 기본 생성자가 아닌 부모의 인자 생성자 또한 사용할 수 있다.

```csharp
class Knight : Player // 콜론을 찍어 상속하고자 하는 부모 클래스의 이름 명시
{
	public Knight() : base(10)
	{
		// 부모의 인자 10인 생성자로 생성 후 자식을 생성하게 된다
		this.hp = 100; // this가 자신을 의미하고
		base.hp = 100; // base가 부모를 의미한다.
	}
}
```

- base 키워드를 사용해 부모의 필드나 생성자에 접근할 수 있다.

### 은닉성

- 객체지향의 3대 속성을 얘기하라고 한다면 **은닉성, 상속성, 다형성**이 있다.
- 자동차에는 정말 수백가지의 기계 부품들과 머신들의 기능이 있지만, 사용자는 핸들 돌리기, 페달 밟기, 문 여닫기만 하면 된다.
    - 자동차의 모든 기능을 전부 사용자에게 다 알려줄필요는 없고, 필요한 기능만 알려주는 것이 사용자 입장에서 더욱 용이하다.
    - 또한 엔진, 기름, 전기장치 기능을 모두 오픈한다면, 사용자가 잘못 다룰 경우 자동차가 고장나거나, 심하면 폭발할 수 있다.
    - 따라서 안전을 위해, 필요한 기능만 노출시키는 것이다.
- 지금까지는 모든 필드의 접근지정자를 public으로 두었다. 모두에게 공개하고, 수정할 수 있다는 뜻이다.
- 그러나 매우 중요한 정보이거나 사용이 제한되어야 하는 정보의 경우엔 public을 사용해선 안된다.

| public | 모두에게 공유해서 사용할 수 있다. |
| --- | --- |
| protected | 본인 클래스와 상속받은 자식 클래스에서 사용할 수 있다. |
| private (혹은 비워놓음) | 본인 클래스 내부에서 정의된 로직에서만 사용할 수 있다. |
- 그래서 보통 필드 변수들은 private로 두고, public인 게터와 세터를 열어둔다.
    - 굳이 변수를 잠궈놓고 게터세터로 하는 이유는, 이곳저곳에서 해당 변수를 조작할 때 문제가 생겼다면, 함수의 콜스택을 보고 문제가 생긴 순간을 포착하기 쉽기 때문이다.
    - 또한 해당 변수에 들어가면 안 되는 값이 들어가는 경우를 필터링하는 로직도 포함시킬 수 있다.
### 클래스 형식 변환

- 만약 RPG게임에서 기사, 법사, 궁수 직업의 클래스가 있고, 이 클래스 객체를 인자로 하는 함수가 있다면, 인자는 어떻게 넣어야 할까?

```csharp
static void EnterGame(Knight knight) {...}
static void EnterGame(Mange mage) {...}
static void EnterGame(Acher acher) {...}
```

- 모든 클래스에 대응되도록 함수를 전부 따로 만들어 오버로딩을 하는 것은 굉장히 비효율적이다.
- 여기서 쓰는 것이, 클래스의 변환성이다.
```csharp
static void EnterGame(Player player) {...}
```

- 기사, 법사, 궁수 모두 동일 속성때문에 Player라는 객체를 상속받았었다.
- 해당 함수의 인자에 기사를 넣든, 법사를 넣든 잘 작동된다.
- 잘 생각해보면, 기사나 법사가 할 수 있는 고유의 기능은 분명 있지만, 부모인 Player가 할 수 있는 것은 기사, 법사, 궁수 너나 할것 없이 상속받았기 때문에 모두가 가능하다.
- 여기까지는 좋은데, 해당 함수에서 법사만 가지고 있는 MP 자원을 써야할 수도 있다면? 그 때는 클래스의 형 변환이 필요하다.
```csharp
Player mage = new Mage(); // 가능
Mage mage = new Player(); // 불가능
```

- Player 자료형의 변수에 Mage를 넣는 것은 가능하다.  해당 변수로 조작할 것(Player의 필드와 메서드)은 모두 Mage에 있지만, Mage에서 조작해야 하는 고유의 기능이 Player 객체에는 없을 수 있기 때문이다.
    - 이는 밴다이어그램으로 해석하면 쉽다.
    - 모든 Mage는 Player인가요? → 예. 따라서 메이지는 플레이어가 되어도 좋습니다.
    - 모든 Player는 Mage인가요? → 아니오. Player중엔 기사도, 궁수도 있습니다. 따라서 Player가 메이지가 되어서는 안됩니다. 해당 Player가 기사라면 어쩌려고요?
- 그러나 Mage → Player → Mage로 변환을 해야할 때는 분명히 있다. 바로 위의 부모를 인자를 받은 함수가 그렇다.
    - Mage → Player는 간단하다. 그냥 Player 변수를 선언해서 넣어주면 된다.
    - 그러나 Player → Mage는 위에서 말한 오류로 인해 불가능하다. 이 땐 임의적으로 캐스팅을 해도 좋다고 개발자가 명시해주어야 한다.
```csharp
Player player = mage;
Mage mage = (Mage)player;
```

- 이렇게 메이지를 플레이어로 바꾸었다고 해서, 해당 객체가 메이지의 기능을 잃어버린 것은 절대로 아니다. 애초에 객체는 참조타입이다. 원본은 분명히 어딘가에 잘 갖추어져 있고, Player일 동안엔 Mage 고유의 기능을 잠시 사용하지 않는 것 뿐이다.
- 그러나 만약 캐스팅을 했으나, 예외로 인해 나이트가 (Mage) 뒤에 들어왔다면 어떻게 될까?
    - 문법상엔 아무런 문제가 없다. 그러나 당연히 프로그램을 실행하면 크래쉬가 난다.
- 때문에 한 번 해당 Player가 정말로 Mage가 맞는지 질문을 하고, 맞다면 통과하면 된다.

```csharp
bool isMage = (player is Mage);

if (isMage)
{
	Mage mage = (Mage)player;
	mage.mp -= 10;
}
```
- is라는 키워드를 사용하면, 해당 객체의 원형이 이 클래스가 맞는지를 물어볼 수 있다. 그 리턴값은 bool로 리턴된다.
- 또 다른 방식으론 as 키워드가 있다.

```csharp
Mage mage = (player as Mage); // Mage라면 한 번에 캐스팅까지 하지만, 아니라면 null 반환

if (mage != null)
{
	mage.mp -= 10;
}
```

- 맞다면 바로 캐스팅하고, 아니라면 null을 반환시켜서, null이 아니라면 원하는 행동을 수행하게끔 할 수도 있다.
- 대부분의 경우에는 as를 사용한다. as가 조금 더 대중적으로 많이 사용되고 코드도 깔끔하기 때문에, 많은 표준 프로그램이 as를 지원한다.
### null

- null은 정말 말 그대로 없다는 뜻이다.
- 내부가 비어있음을 뜻한다.
- 아무것도 참조하지 않는 객체를 만들고 싶다면, null을 이용할 수 있다.

```csharp
Knight knight = null;
```

- 만약 원하는 플레이어를 탐색하는 기능을 만들었다면, 모든 플레이어 탐색 후 원하는 플레이어를 리턴하면 되지만, 해당 플레이어를 찾지 못했다면 null을 리턴하게끔 하여 논리성을 만들 수 있다.

### 다형성

- 객체지향의 3대 속성을 얘기하라고 한다면 **은닉성, 상속성, 다형성**이 있다.
- Polymorphism, 여러 가지 형태를 가지고 있다는 의미이며, 대표적인 것이 **오버라이딩**이다.
- C# 객체지향에서 다형성을 사용하기 위해선 가상함수를 만들어야 한다.
    - 그를 위해 쓰는 키워드가 virtual, override 이다.
- 부모 클래스에서 가상 함수를 만들고, 자식들이 오버라이딩하는 것이다.
    - 오버로딩은 함수 이름의 재사용이고, 오버라이딩은 같은 함수를 다른 형태로 만드는 것이다.
- 이렇게 되면 부모 클래스로 받은 함수에서도 자식 고유의 오버라이딩 메서드를 사용하게 된다.
- C#에선 오버라이딩을 하고 싶다면, 반드시 덮어씌울 원본 함수는 가상함수여야 한다.
- 추가적으로 오버라이딩 함수 안에서 base.Move() 등 부모의 원본함수를 먼저 쓰고 내것을 사용하는 것 또한 가능하다.

```csharp
public sealed override void Move() {}
```

- 또한 sealed 키워드를 오버라이드 앞에 붙여 더 이상 자신의 자식들은 오버라이딩 하지 못하게끔 막는 것 또한 가능하다.

### 문자열 둘러보기

```csharp
string name = "Harry Potter";
```

- string은 기본적인 자료형이 아닌, 객체로서 존재하는 문자열 자료형이기 때문에 다양한 기능들을 제공한다.
- 찾기

```csharp
bool fount = name.Contains("Harry"); // true. 원하는 문자열 찾기
int index = name.IndexOf('P'); // 6. 문자의 위치 찾기, 없다면 -1 리턴
```
- 변형

```csharp
name = name + " Junior"; // 문자열 추가

string lowerCase = name.ToLower(); // 모든 문자를 소문자로
string upperCase = name.ToUpper(); // 모든 문자를 대문자로

string replaceCase = name.Replace('r', 'l'); // 앞 인자 문자를 뒤 인자 문자로 변경
```
- 분할

```csharp
string[] names = name.Split(ner char[] {' '}); // 공백을 기준으로 분할하여 배열에 저장
string subCase = name.Substring(5); // 인자 번지부터 맨 뒤까지 잘라 새로운 문자열로 리턴
```

# 6. TextRPG 2

### 플레이어 생성

- 프로젝트 솔루션에서 우클릭 - 새파일을 하여 파일을 추가할 수 있다.
    - 클래스 파일을 새로 생성해서 여러가지 클래스를 파일별로 관리할 수 있다.
    - 클래스 파일과 파일 이름은 같게 하는 것이 좋다.
- C#은 파일을 분리하여도 굳이 include를 할 필요가 없다. 같은 네임 스페이스 내라면 편하게 사용 가능하다.
- 생성자를 인자를 가진 생성자 하나만 둔다면, 아무런 인자가 없이 생성하기는 불가능하다.
    - 모든 직업군들의 상위 부모 클래스를 만들 때 이런 방식으로 ‘부모 직업’을 가지고 생성하는 것을 방지할 수 있다.
    - 또한 해당 생성자를 protected로 접근지정자를 두면 아예 생성이 불가능해진다.

### 몬스터 생성

- 플레이어와 몬스터를 모두 아우르는 Creature라는 부모 클래스 생성
- 플레이어인지 몬스터인지를 구별하기 위한 Enum 생성 후, 생성자에서 그 타입을 지정하게 함
- 이후 플레이어와 몬스터 클래스의 생성자에서 base를 활용해 크리쳐타입을 지정하여 부모 생성자를 우선 실행하고, 그 후에 몬스터의 타입을 생성자에서 인자로 받게 활용
- 이후 몬스터를 상속받는 슬라임, 오크, 스켈레톤 생성
    - 모든 클래스들이 전부 부모님 생성자를 우선 실행해야 하기에 base로 몬스터 타입을 지정
- 모든 크리쳐가 GetAttack()과 OnDamaged가 있기 때문에, 객체별로 공격력과 데미지 입기를 꺼내어 공격하도록 지정해주면 됨
- 이렇게 하면 PVP기능도 손쉽게 만들 수 있다. 데미지를 꺼내고 피해를 입는 객체만 넣어주면 되기 때문이다.

### 게임 진행

- 지금까지는 몬스터, 플레이어를 객체로 만들었다. 그러나 문제는 ‘게임 진행’ 부분이다.
- 물론 로비, 게임 진행 등의 흐름 역시 모두 객체로 만들 수 있다.
- ‘Game.cs’ 라는 클래스를 만들어 게임 매니저 역할을 하게끔 할 수 있다.
- 게임 매니저에서 Enum을 활용해 게임 모드라는 자료형을 선언
    - 로비, 마을, 필드 등의 게임 모드 정의
- Process()라는 함수를 만들고 switch case문으로 게임모드에 맞는 활동을 하게끔 플래그를 세운다.
- 이 경우 게임 모드 안에서도 플레이어를 저장하게끔 Game 클래스 안에 Player를 만들기도 한다.
- 절차지향의 경우엔 함수 안에서 함수를 호출했기 때문에 Town으로 올 땐 반드시 이전에 Lobby를 거쳐야 해서, 다른 경우에서 Town을 호출할 경우 그 스택이 꼬일 수 있었다.
- 그러나 객체지향의 경우엔 그저 객체 함수만 호출하기에, 이전에 어디서 왔는가가 전혀 중요하지 않아서, 추후 기획이 변경되어 Lobby에서 Town을 호출하지 않고 다른 곳에서 호출하더라도 유연한 대처가 가능해진다.

### 마무리

- rand를 사용해 랜덤한 몬스터를 엔카운트하는 과정을 별도로 함수로 빼서 사용할 수 있다.
- 랜덤 객체, 플레이어 객체, 몬스터 객체는 모두 클래스 위에서 별도로 선언하여 사용한다.
- 메인 전투에 들어갔다면, switch case 문 안에서 또 별도의 함수를 호출하는 것도 좋다.
    - 이런 경우엔 함수 인자로 플레이어와 몬스터를 넘겨도 되지만, 메인 객체가 그 변수 자체를 포함하고 있다면 전혀 인자로 넘기지 않아도 된다.
- 일정 확률로 도망치기 등의 함수를 만들었다면, 확률 체크 후 게임 모드만 변경하면 된다.
- 이렇게 OOP로 게임을 만드니 기능별로 함수가 분리되고, 코드도 깔끔해졌다.
- 클래스별로 자기가 도맡은 기능은 자신이 기능하도록 만드니 그 객체가 어디서 사용되든 자신이 도맡은 기능을 확실하게 수행할 수 있게 되었다.

# 7. 자료구조 맛보기

### 배열

- 자료구조에 대한 이해도가 없으면, 프로그래밍을 함에 있어서 데이터를 다루는 부분이 성립이 되지 않는다.
- 자료구조와 알고리즘은 깊은 연관성이 있다.
- 만약 몬스터가 필드에 여러 마리가 존재한다면, 지금까지의 지식으론 객체를 하나하나 생성해야했다. 하지만 이러면 관리가 매우 버거운데, 여기서 쓰이는 것이 배열이다.

```csharp
int[] a = new int[개수]; // int 형식의 데이터를 여러 개 담는 배열
Monster[] monsters = new Monster[10]

a[0] = 10;
a[1] = 20;
```

- C#에서 배열을 [] 기호를 사용해 정의한다.
- 반드시 배열을 정의했다면, new 자료형[개수] 로 데이터를 만들어 심어야 한다.

- 접근을 할 때는 인덱스로 접근한다.

```csharp
Console.WriteLine(a[2]);
```

- 배열의 가장 큰 특징은, 동일한 자료형 데이터만을 담을 수 있다는 것이다.
- 주소상으로 연속적이게 메모리에 저장된다.
- 지정한 주소 값을 초과하는 번지수를 참조해버리면 Out of Range 에러가 터진다.
```csharp
for (int i = 0; i < scores.Length; i++) {
	// ...
}
```

- 원하는 배열의 Length 필드를 사용하여 길이를 가져와 안전하게 배열의 주소를 참조할 수 있다.
- 파이썬에서의 for문처럼, C#에서도 배열을 쉽게 참조하는 for문이 있다.

```csharp
foreach (int score in scores) {
	// ...
}
```

- 배열의 0번부터 하나씩 score에 담아서 반복문 안에서 사용하게 된다.
- 가독성이 좋기 때문에 foreach문이 적합한 상황에선 아주 잘 쓰인다.
- 데이터를 넣을 때에도 한 번에 원하는 값을 이쁘게 넣는 방법도 있다.

```csharp
int[] score = new int[5] { 10, 20, 30, 40, 50 };
int[] score = new int[] { 10, 20, 30, 40, 50 }; // 크기 생략 가능
int[] score = { 10, 20, 30, 40, 50 }; // new 명시 생략 또한 가능
```

- 단, 이 경우에는 지정한 크기만큼 확실하게 값을 넣어야 한다.
- 크기를 지정하지 않으면 알아서 뒤 데이터의 크기만큼 크기를 잡는다.
- new 키워드 또한 생략할 수 있는데, 이는 동적으로 배열을 할당하는 것이 바로 보이지 않기 때문에 사람마다 호불호가 갈린다.
    - 배열은 참조 타입이다.

### 연습문제

- 정렬되지 않은 배열의 요소들을 가지고, 최댓값과 평균값을 뽑아내는 문제
- 점수를 받았을 때, 해당 점수가 들어가있는 주솟값을 리턴하는 문제, 점수가 없다면 -1 리턴
- 마지막으로 정렬을 하는 문제

```csharp
static int GetHighestScore(int[] scores)
{
	int max = scores[0];
	
	foreach (int score in scores) {
		if (max < score) {
			max = score;
		}
	}
	
	return max;
}
```
```csharp
static int GetAverageScore(int[] scores)
{
	if (scores.Length == 0)
		return 0;
		
	int sum = 0;
	
	foreach (int score in scores) {
		sum += score;
	}
	
	
	
	return (sum / scores.Length);
}
```
```csharp
static int GetIndexOf(int[] scores, int value)
{
	for(int i = 0; i < scores.Length; i++)
	{
		if (scores[i] == value)
			return i;
	}
	
	return -1;
}
```
```csharp
static void Sort(int[] scores) // 버블정렬로 구현
{
	for(int i = 0; i < scores.Length - 1; i++)
	{
		for(int j = 0; j < scores.Length - 1; j++)
		{
			if (scores[j] > scores[j + 1]) {
				int temp = scores[j];
				scores[j] = scores[j + 1];
				scores[j + 1] = temp;
			}
		}
	}
}
```
```csharp
static void Sort(int[] scores) // 선택정렬로 구현
{
	for(int i = 0; i < scores.Length; i++)
	{
		int min = i; // 가장 작은 요소의 인덱스
		
		for(int j = i; j < scores.Length; j++)
		{
			if (scores[j] < scores[min]) {
				min = j;
			}
			
			int temp = scores[i];
			scores[i] = scores[min];
			scores[min] = temp;
		}
	}
}
```
### 다차원 배열

- 지금까지의 배열은 일차원이며, 다양한 경우에서 다차원 배열이 필요한 경우가 자주  필요하다.
    - 특히 이차원 배열이 정말 많이 쓰인다.
    - 특히 바람의 나라같은 상하좌우의 게임 월드에선 좌표로 2차원 배열을 잘 쓸 수 있다.

```csharp
int[,] arr = new int [2, 3]; // 왼쪽의 행의 크기, 오른쪽이 열의 크기

arr[0, 1] = 1;
```

- 대괄호 안에 콤마를 넣음으로서 2차원 배열임을 표시
- 초기화를 하고 싶을 땐 중괄호를 여러 겹 사용하여 초기화
- 2차원 배열에서 열의 크기를 알고 싶을 때 Length를 쓰면 모든 요소의 개수를 리턴해버린다.
- 따라서 GetLength(1); 를 사용하면 열의 크기를 알 수 있다.
- 각 차원마다 크기가 다른 가변 배열이 존재한다. 잘 쓰지는 않는다.

```csharp
int[][] p = new int[3][];
a[0] = new int [3];
a[1] = new int [6];
a[2] = new int [2];
```

### List

- 배열의 단점은 초기화하는 시점에서 크기가 고정된다는 점이다.
- 그래서 크기를 동적으로 바꾸는, 동적 배열인 List가 있다.
- 원하는 크기보다 더 큰 크기가 필요하게 되면, 그 때 새로운 배열을 초기화 후 데이터를 이주하는 방식으로 동적 리사이징이 이루어진다.

```csharp
using System.Collections.Generic;

List<int> list = new List<int>();
List<float> list = new List<float>();
```

- 여기서 쓰는 꺽쇠 <>는 제네릭이라고 하여 어떠한 자료형이든 넣을 수 있는 키워드이다.
```csharp
list.Add(1); // 끝에다가 1이라는 요소 추가

// 삽입 삭제
list.Insert(2, 999); // 2번지에 999를 삽입, 뒤 요소들은 한칸씩 미뤄짐
list.Remove(3); // 가장 먼저 만나는 3이라는 요소를 삭제
list.RemoveAt(0); // 0번 인덱스에 있는 요소를 삭제
list.Clear(); // 리스트 내용 초기화
```

- 동적 배열 자료구조를 알고있다면 알겠지만, 리스트 내부에 값을 삽입하고 리사이징되는 것은 자료구조 측면에서 그다지 효율적이지 않다.
- 리사이징 과정에서 복사가 필연적으로 이루어지기 때문이다.

### Dictionary

- 리스트 또한 단점이 있다.
    - 게임 내 플레이어, 몬스터는 대부분 ID를 부여하여 ID로 검색 및 식별을 하게 된다.
    - ID : 액션으로 보통 네트워크와 클라이언트가 소통을 하게 되는데, 리스트로 구현을 하게 되면 리스트를 두 개 만들거나, 모든 몬스터, 플레이어 객체의 크기만큼 리스트를 초기화해야한다.
- 이 때 필요한 것이 Key → Value, 즉 키가 있다면 해당 값을 빠르게 찾아오는 자료구조이다.
- 이것이 딕셔너리, Dictionary이다.

```csharp
using System.Collections.Generic;

Dictionary<int, Monster> dic = new Dictionary<int, Monster>();

dic.Add(0, new Monster()); // Key : 0 / Value : Monster 객체
dic[5] = new Monster(); // Key : 5 / Value : Monster 객체

dic[5000] // 5000번 Key를 가진 몬스터
```

- 딕셔너리는 존재하지 않는 Key를 조회하려고 하면 에러가 터진다.
- 따라서 해당 Key가 존재하는지 한 번 체크하는 과정도 좋다.

```csharp
Monster mon;
bool found = dic.TryGetValue(20000, out mon);

// 만약 20000번의 몬스터가 있다면 mon에 할당, found가 true
// 만약 20000번의 몬스터가 없다면 mon은 null, found는 false
```

```csharp
dic.Remove(7777); // 7777번 ID 요소 삭제
dic.Clear();
```

- 딕셔너리는 해시, HashTable을 이용하기 때문에 훨씬 검색하는 속도가 빠르다.
- 키 값을 해시를 돌려 나오는 값을 토대로 변수를 분할하여 이곳저곳에 저장한다.
- 추후 어떤 키 값을 찾을 때, 똑같은 해시 함수를 돌려 나온 바구니만 검색하면 아주 빠르게 검색이 가능하다.
- 단 해시 테이블을 많이 마련해두기 때문에 메모리가 많이 필요하다.
    - 즉, 메모리를 많이 내주고, 성능을 많이 취하는 자료구조이다.

# 8. 알아두면 유용한 기타 문법

### Generic (일반화)

- 특정 자료구조를 사용할 때, 꺽쇠 안에 원하는 자료형을 삽입하는 것.
- List<int> 처럼 그 안에 원하는 자료형을 넣음으로서 어떤 자료형이든 호환되게 한다.

```csharp
class MyList<T>
{
	T[] arr = new T[10];
	
	public T GetItem(int i)
	{
		return arr[i];
	}
}

Main() {
	MyList<int> list1 = new MyList<int>();
	MyList<float> list1 = new MyList<float>();
	MyList<Monster> list1 = new MyList<Monster>();
}
```

```csharp
static void Test<T>(T input) {

}

Main() {
	Test<int>(3);
	Test<float>(3.0f);
}
```

- 한 마디로 자료형을 위한 파라미터 라고도 할 수 있다.
- 자료형이 여러개인 버전의 함수를 다양하게 만들지 않고, 제네릭을 사용해 함축시킬 수 있다.
- 한 클래스나 함수에서 사용해야하는 제네릭이 여러개라면 <T, K> 처럼 쉼표로 구분할 수 있다.

```csharp
class MyList<T> where T : class {} // 반드시 참조 타입인 클래스이어야 한다
class MyList<T> where T : new() {} // 반드시 어떠한 인자도 받지 않는 기본 생성자여야 한다
class MyList<T> where T : Monster {} // T는 Monster나 그걸 상속받는 클래스이어야 한다
```

- where 키워드를 사용하여 제네릭에 조건을 걸어둘 수 있다.

### Interface (인터페이스)

- 추상 클래스 : 클래스를 설계할 때 무언가의 기능을 만들도록 강요하는 클래스
    - 반드시 원하는 메서드를 오버라이딩해야하도록 하는 것

```csharp
abstract class Monster // abstract 키워드를 사용
{
	public virtual void Shout(); // 추상 클래스이기 때문에 본문을 정의하면 안된다.
}

class Orc : Monster
{
	public override void Shout() {} // 반드시 오버라이딩해야 한다.
}
```

- 추상 클래스로 만든 클래스로는 객체를 생성할 수 없다.
- 추상 클래스의 메서드는 본문을 정의할 수 없다.
- 해당 추상 클래스를 상속받는 클래스는 반드시 해당 메서드를 오버라이딩해야 한다.

```csharp
// 아래와 같은 다중 상속은 C#에선 지원하지 않는다!
class FlyableOrc : Orc, Flyable
{
	// Error!
}
```

- 추상 클래스를 통해 강요받고싶은 메서드가 여러 개 있어 다중 상속을 받고자 한다면, C#에선 다중 상속을 받을 수 없다.
    - 다중 상속을 받은 후 특정 메서드를 실행하면 부모 중 어떤 부모의 메서드를 실행해야 하는지 애매한 죽음의 다이아몬드 문제가 발생하기 때문이다.
- 다중 상속의 문제는 양쪽 부모가 모두 정의한 내용이 충돌하는 문제이다.
- 한 마디로 다중 상속을 원한다면, 구현 강요 자체는 이루어지나 그 내용 정의는 너가 알아서 해! 라는 의미를 내포하는 인터페이스를 사용한다면 다중 상속과 유사한 작업을 할 수 있다.
```csharp
abstract class Monster
{
	public virtual void Shout();
}

interface IFlyable // 인터페이스라는 키워드를 사용, 앞에 I를 붙이는 것이 불문율
{
	void Fly(); // 인터페이스로 만든 메서드는 접근 지정자 등 키워드를 붙이지 않는다.
}

class FlyableOrc : Monster, IFlyable // 인터페이스를 포함하여 다중 상속 가능
{
	public override void Shout() {}
	public void Fly() {}
}
```

- 인터페이스 속 메서드는 접근 지정자나 virtual같은 키워드 없이, return 자료형과 이름만 붙여서 내용을 정의하지 않고 만든다.
- 이렇게 추상 클래스와 인터페이스를 사용하는 이유는 추후 해당 클래스나 인터페이스를 사용하는 새로운 클래스를 만들 때 반드시 지켜야 할 제약 조건을 두는 것이다.
- 그를 위해 하는 것이 추상화, 즉 클래스를 추상 클래스로 만드는 작업이다.
- 그렇다면 이 인터페이스는 많은 사람들의 협업 외에는 쓰이지 않는 문법인가? 그것은 전혀 아니다. 혼자 게임을 만들 때에도 문법적으로 매우 도움이 되는 부분이 있다.

```csharp
static void DoFly(IFlyalbe flyable) { // 메서드의 파라메터 자료형이 인터페이스
	// IFlyable 인터페이스가 가지고 있는 메서드만 실행 가능
	flyable.Fly();
}

Main()
{
	FlyableOrc orc = new FlyableOrc(); // 플라이어블 오크 생성
	DoFly(orc); // orc는 IFlyable 인터페이스를 상속받았기 때문에 전달 가능
}
```

- 위와 같은 식으로 특정 인터페이스를 상속받은 클래스라면 모두 파라메터로 전달 가능한 메서드나 함수를 만들 수 있다.

<aside>
💡

격투 게임을 만든다고 쳐보자. 현재는 캐릭터가 10개 있고, 모든 캐릭터는 필살기를 포함한다.

그렇다면 기본 캐릭터형을 만들고 필살기 메서드를 만든 뒤 추상 클래스로 하여,
격투 게임의 캐릭터들에게 해당 추상 클래스를 상속받을 수 있다.

그러나 그 중 악당 캐릭터들은 ‘악당 필살기’ 를 사용할 수 있다고 쳐보자.
그렇다면 악당 필살기를 강요하는 인터페이스를 만들어 상속받을 수 있고,
전투 매니저에서 해당 인터페이스를 파라메터로 하는 메서드를 만들 수 있다.

이렇게 되면 추후 게임이 업데이트되어 새로운 악당 캐릭터가 나오더라도,
위 메서드는 기존 캐릭터뿐만 아니라 모든 ‘악당’ 인터페이스를 상속받는 캐릭터들을 대상으로 한
메서드이기 때문에 신규 악당 캐릭터도 악당 인터페이스를 상속받았다면 사용 가능해진다!

</aside>

### Property (프로퍼티)

- 프로퍼티에 대해 알기 위해선 은닉성에 다시 집중할 필요가 있다.
    - 특정 멤버 변수를 public으로 열기 보다는 Getter, Setter를 쓰는 것이 유용할 때가 많다.
- 그러나 변수가 굉장히 많다면 덩달아 Get과 Set이 굉장히 많아진다.
- C#은 이를 조금 더 편리하게 하기 위한 문법인 프로퍼티가 마련되어있다.

```csharp
class Knight
{
	protected int hp;
	
	public int Hp // 프로퍼티는 이름 뒤에 괄호가 아예 붙지 않는다.
	{
		get { return hp; }
		set { hp = value; } // 여기서 value라는 변수는 프로퍼티에 예약된 키워드이다.
	}
}

static void Main()
{
	Knight knight = new Knight();
	
	knight.Hp = 100; // 알아서 set 프로퍼티 사용
	int hp = knight.Hp; // 알아서 get 프로퍼티 사용
}
```
- 프로퍼티 안의 get, set 앞에 private 등의 접근 지정자를 붙일 수 있다.
- 여기서 더 나아가 자동구현 프로퍼티라는 편리한 방식이 존재한다.
    - 멤버 변수 필드를 선언하고, 프로퍼티를 만드는데, 여기서 멤버 변수 필드를 정의하는 과정을 스킵할 수 있다.

```csharp
class Knight
{
	// 멤버 변수 필드는 스킵한다.
	public int Hp { get; set; }
	
	// 위 한 줄은 아래와 같은 역할을 한다.
	private int _hp;
	public int GetHp() { return _hp; } // 물론 실제로 이 이름의 함수가 만들어지는건 아니다.
	public void SetHp(int value) { _hp = value; }
}

static void Main()
{
	Knight knight = new Knight();
	
	knight.Hp = 100; // 알아서 set 프로퍼티 사용
	int hp = knight.Hp; // 알아서 get 프로퍼티 사용
}
```

### Delegate (대리자)

<aside>
💡

사장님에게 전달할 용건이 있어서 전화를 걸었는데,
대리자인 ‘비서’ 가 전화를 받았다.

우리는 연락처 / 용건을 남겼고,
추후 사장님이 거꾸로 우리에게 연락을 주게 된다. (콜백)

</aside>

- 대표적으로 UI 작업을 할 때 많이 사용되는 문법이다.
- UI는 버튼을 눌렀을 때 특정 액션을 하는 경우가 많은데, 여기서 UI 코드는 실제 게임 로직과 완전히 분리를 시키는 것이 좋다.
    - 이렇게 UI에서 별도로 제공된 함수는 그 함수 내부를 일일히 수정하지 않고, 평생 해당 함수를 활용해야 하는 경우가 많다. 따라서 실제 게임 로직과 연관이 되어있다면 로직이 변경될 때마다 해당 UI 함수도 변경해야하는 번거로움이 발생한다.
    - 실질적으로 내장 라이브러리 속 함수들을 우리가 프로그래밍할 때 수정할 일은 없지 않은가.
- 즉, 어떤 함수의 **파라메터로 함수를 넘겨**버려서, 그 함수 안에서 해야할 행동을 호출할 때 정하는 방식이 존재한다.

```csharp
static void ButtonPressed(/* 함수 자체를 인자로 넘긴다 */)
{
	// 함수를 호출();
}

Main()
{
	ButtonPressed(/* 일어나기를 원하는 함수 */);
}
```

- 이런 식으로 함수 내부에서 역으로 우리의 기능을 호출시키는 것을 콜백이라고 한다.
```csharp
delegate int OnClicked();
// delegate가 붙었으니 형식은 형식이나, 함수 자체를 인자로 넘겨주는 형식
// 반환은 int, 입력은 void, 이름은 OnClicked

static void ButtonPressed(OnClicked clickedFunction)
{
	clickedFunction();
}

static int TestDelegate()
{
	Console.WriteLine("Hello Delegate"); // 실행 결과
	return 0;
}

Main()
{
	ButtonPressed(TestDelegate);
}
```

- 혹은 델레게이트 객체를 만들어서, 해당 객체에 원하는 함수를 넣어놓고 사용할 수 있다.
- 이렇게 사용하게 되면 델레게이트 체이닝, 즉 여러 함수를 순서대로 묶어 한 번에 매크로처럼 활용하는 것이 가능하다.

```csharp
delegate int OnClicked();

static void ButtonPressed(OnClicked clickedFunction)
{
	clickedFunction();
}

// 1번 함수
static int TestDelegate1()
{
	Console.WriteLine("Hello Delegate 1");
	return 0;
}

// 2번 함수
static int TestDelegate2()
{
	Console.WriteLine("Hello Delegate 2");
	return 0;
}

Main()
{
	OnClicked clicked = new OnClicked(TestDelegate1);
	clicked += TestDelegate2; // 체이닝
	
	ButtonPressed(clicked); // 두 함수를 한 번에 실행
}
```

- 한 마디로 아래의 예시처럼, 여러 함수를 하나의 대리자가 해줄 수 있는 것이다.

```csharp
delegate void dele(int a);

Main()
{
	dele d; // 델리게이트 변수 생성
	
	d = Method1;
	d(10); // Method 1이라는 이름의 메서드 실행
	
	d = Method2;
	d(20); // Method 2이라는 이름의 메서드 실행
}
```

- 즉 여기서 d는 return이 void이고, 인풋이 int인 모든 함수들을 대리하는 대리자가 될 수 있다.
- d = new dele(Method1); 처럼 객체 생성도 되고, 위처럼 d = Method1; 로 바로 매길 수 있다.

### Event(이벤트)

- 델리게이트는 그 어떤 곳에서도 호출이 될 수 있기 때문에 정말 중요한 대리자가 원하지 않는 곳에서 임의적으로 호출될 수 있는 단점이 있다.
- 그래서 델리게이트를 wrapping하는, Event라는 문법이 존재한다.
- 특정 조건이 만족했을 때, 특정 신호를 모두에게 브로드캐스팅하고, 해당 이벤트를 구독한 객체들은 그 신호를 수신하는 방식이다.

```csharp
class InputManager
{
	// 키보드나 마우스의 입력을 감지해서 게임 로직에 알려주는 클래스
	
	public delegate void OnInputKey();
	public event OnInputKey InputKey; // 이벤트로 만들어 델리게이트 변수 생성
	
	public void Update()
	{
		if (Console.KeyAvailable == false)
			return;
		
		ConsoleKeyInfo info = Console.ReadKey();
		
		if (info.Key == ConsoleKey.A)
		{
			// A 입력 사실을 브로드캐스팅
			// 해당 부분에 직접 게임속 로직을 넣는 것은 매우 비효율적
			
			InputKey();
		}
	}
}

static void OnInputTest()
{
	Console.WriteLine("Input Received!");
}

Main()
{
	InputManager inputManager = new InputManager();
	
	// 구독 신청, 신호를 받았을 때 수행하고 싶은 로직
	inputManager.InputKey += OnInputTest;
	
	while (true)
	{
		inputManager.Update();
	}
}
```
- 이렇게 Event로 만든 델리게이트 함수는 임의로 호출할 수 없다.
- 반드시 구독 과정을 거쳐야만 브로드캐스팅을 받았을 때 약속된 로직이 실행된다.
- -= 연산자를 사용해 원하는 로직의 구독 취소를 할 수도 있다.
- 위처럼 특정 객체들이 구독을 한 후, 구독자들에게 특정 조건 달성 시 이벤트를 쏘는 것을 옵저버 패턴이라고 한다.

### Lambda (람다식)

- 일회용 함수를 만드는 문법
- 보통 함수는 코드를 재사용하기 위해 쓰는데, 가끔 있는 재사용 필요 없는 일회용 함수가 필요할 때 사용한다.
    - 예를 들어 인벤토리를 열어 특정 아이템을 찾는 로직에서 사용된다.
    - 지금까지 배웠던 쉬운 방법은 FindWeapon이라는 함수를 하나 만들어서, 해당 함수에서 foreach문으로 인벤토리를 검색해서 원하는 아이템 타입이 감지되면 리턴하는 방식이다.
- 그러나 위와 같이 인벤토리를 탐색해서 아이템을 찾는 방식에는 단점이 있다.
    - 아이템을 찾고자 할 때 기준으로 삼을 검색 키워드가 여러개라면, 함수도 여러 개가 된다.
    - 예를 들어 아이템 이름, 종류, 레어리티, 기간제 유무 등 다양한 검색 키워드가 존재할 수 있는데, 이럴 경우 종류, 레어리티 등이 전부 하나하나의 Enum이기 때문에 깔끔하게 파라미터를 정의하여 함수 안에 다양한 처리를 넣는 것이 번거롭다.
- 여기서 조금 더 개선한 점은, **델리게이트**를 이용하는 것이다.
    - 델리게이트 키워드를 넣은 함수는 인자로 넣을 수 있는 함수가 된다.
    - 그러나 델리게이트를 만들더라도, 해당 델리게이트 안에서 필요한 함수들을 모두 개별적으로 만들어야 하는 것은 마찬가지이다.

```csharp
delegate bool ItemSelector(Item item); // 델리게이트

static Item FindItem(ItemSelector selector) {}

static bool IsWeapon(Item item) // 탐색 조건 함수, 여러 버전이 존재할 수 있음
{
	return item.ItemType == ItemType.weapon;
}

Main()
{
	Item item = FindItem(IsWeapon); // 검색 결과를 리턴받는 명령어
}
```

- 위와 같은 코드가 있을 때, IsWeapon말고도 이것이 방패인지, 악세사리인지, 레어도가 높은지 등등 다양한 버전이 생길 터인데, 그럴 때마다 저렇게 함수를 계속 만들어버리면 함수가 무분별하게 늘어날 것이다.
- 함수 내 기능이 비교적 간단하고, 똑같은 버전이 여러 개 계속해서 만들어질 것 같을 때, 이 때 Lambda를 사용할 수 있다.

```csharp
delegate bool ItemSelector(Item item); // 델리게이트

static Item FindItem(ItemSelector selector) {}

Main()
{
	Item item = FindItem(delegate (Item item) {
		return item.ItemType == ItemType.weapon;
	});
}
```

- IsWeapon이라는 함수의 이름을 짓지 않고, 내용물을 그대로 델리게이트 인자 안에 함수로 넣어버려 익명 함수, 혹은 무명 함수로 만들 수 있다.
    - 이 때 필요한 것은 인자 앞에 delegate 키워드를 붙이는 것이다.
    - 저 함수가 다양한 곳에서 사용될 것이 아닌, 정말 저 때 한 번 사용될 것이라면 매우 좋다.
- 그러나 이 함수는 아직 람다 함수는 아니고, 그냥 무명 함수, 혹은 익명 함수이다.
- 추후 C#이 이 과정마저 단축하기 위해 람다 문법을 만들었다.

```csharp
delegate bool ItemSelector(Item item); // 델리게이트

static Item FindItem(ItemSelector selector) {}

Main()
{
	Item item = FindItem((Item item) => { return item.ItemType == ItemType.weapon; });
}
```

- delegate 키워드를 제거하고, ⇒라는 화살표 기호를 사용하여 람다 함수를 만들 수 있다.
- 물론 델리게이트 객체를 new로 만들어서 안에 넣으면 변수화하여 여러번 사용할 수 있다.

### Func, Action

- 델리게이트 자체는 함수 안에 인자로 넣을 수 있는 형식이다.
- 이 델리게이트에도 제네릭을 사용하여 인자와 리턴을 임의로 설정할 수 있다.

```csharp
delegate Return MyFunc<T, Return>(T item);
delegate Return MyFunc<T1, T2, Return>(T1 item1, T2 item2);
delegate Return MyFunc<Return>();
```

- 위와 같은 버전으로 인자가 여러개인 버전, 리턴이 void인 버전의 델리게이트를 만들면 이런 형식이 필요할 때 MyFunc만 쓰면 모든 곳에 적용이 된다.
- 이걸 알고, C#에선 이미 위와같은 델리게이트를 만들어두었다.

```csharp
Func<Item, bool>();
Action<Item>();
```

- 즉, 델리게이트를 직접 선언하지 않아도, 이미 만들어진 프리셋이 존재한다.
- 반환 타입이 필요할 경우 Func, 반환 타입이 필요 없을 경우 Action을 사용한다.
- Func와 Action 모두 최대 16개까지의 인풋 제네릭이 존재하므로 웬만해선 다 가능하다.
- 따라서 위의 람다 함수를 Func로 사용한다면

```csharp
Func<Item, bool> selector = (Item item) => { return item.ItemType == ItemType.weapon; };

Item item = FindItem(selector)
```

### Exception (예외 처리)

```csharp
try
{

}
catch (Exception e)
{

}
```

- try문 안에서 명령을 수행하다가 에러가 발생하면 catch문을 실행하는 예외처리문
- 소프트웨어 개발 시엔 매우 중요하나, 게임 개발에선 사실 그렇게 많이 사용되는 문법은 아니다.
- try 안에서 일어나는 예외적인 상황은 여러 가지가 있을 수 있다.
    - 0으로 나눌 때
    - 잘못된 메모리를 참조 (널 참조)
    - 오버플로우 등등
- 여기서 Exception은 모든 오류가 전부 포함되어 들어갈 수 있는 만능 오류 자료형이다.
- 오류 종류에 따라서 예외 처리를 다르게 할 수 있다. 이럴 땐 catch를 여러 개 쓰고, 자료형을 다른 걸로 나누면 된다.

```csharp
try {}
catch (DivideByZeroException e) {}
catch (Exception e) {} // Exception은 최상위 조상이기 때문에 가장 밑에다가 둔다.
```

- 중요한 것은 에러가 났을 때, 에러가 난 줄을 포함해 그 아래의 명령어들은 실행이 되지 않는다.
- 만약 에러가 났든, 나지 않았든 최종적으로 실행되어야 하는 구문이 있다면 finally를 사용한다.

```csharp
try {} // 실행
catch () {} // 에러 시 실행
finally {} // 에러가 났든 안났든 최종적으로 실행
```

- finally 안에는 DB 접속 해제, 파일 정리 등등을 넣을 수 있다.
- 또한 우리가 미리 에러를 정의하여, 정의된 에러를 던질 수 있다.

```csharp
class TestException : Exception // Exception을 상속받아야 한다
{

}

Main()
{
	try
	{
		// 만약 에러가 일어났다면
		throw new TestException();
	}
	catch (TestException e)
	{
	
	}
}
```

- 그러나 게임에서는 보통 크래시가 나면, 예외 처리를 하기 보다는 크래시가 나도록 냅두고, 최대한 빨리 크래시를 해결하도록 움직이는 것이 중요하다.
- 실질적으로 게임 로직 안에서 유용하게 사용될 때는 네트워크 접속, 로그인 시도 후 에러가 났을 때 오류가 났음을 알려주는 용도에서 잘 쓰인다.

### Reflection (리플렉션)

- 쉽게 말해 X-Ray를 찍는 것이다.
- 우리가 만든 모든 클래스들은 전부 .GetType()이라는 메서드를 정의하지 않아도 사용할 수 있다.
- 왜냐면 C#에서의 모든 객체들은, 전부 최상위 클래스인 object를 포함하고 있고, 그 object에 포함되어있는 메서드이기 때문이다.
    - 그 외에도 Equals, ToString 등등 다양한 메서드가 존재한다.

```csharp
using System.Reflection;

Type type = monster.GetType(); // 이 문법을 사용해 몬스터의 타입을 알 수 있다.

var fields = type.GetFields(System.Reflection.BindiingFlags.Public
	| System.Reflection.BindiingFlags.NonPublic
	| System.Reflection.BindiingFlags.Static
	| System.Reflection.BindiingFlags.Instance); // 타입에서 원하는 정보를 검색할 수 있다.
	
	
foreach (FieldInfo field in fields) // 받은 필드들을 모두 돌아볼 수 있다.
{
	string access = "protected";
	if (field.IsPublic) access = "public";
	else if (field.IsPrivate) access = "private";
	
	Console.WriteLine($"{access} {field.FieldType.Name} {field.Name}");
}
```

- 위 문법을 통해 원하는 클래스의 필드를 전부 런타임 내부에서 볼 수 있다.
- 그 외에도 프로퍼티나 생성자 정보, 이벤트, 인터페이스, 함수 등등을 모두 열어볼 수 있다.