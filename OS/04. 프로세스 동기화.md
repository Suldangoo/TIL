# Chapter 12 : 프로세스 동기화

## 동기화란

### 동기화의 의미

- 동시다발적으로 실행되는 많은 프로세스는 서로 데이터를 주고받고 협력하며 실행될 수 있다.
- 이렇게 협력적으로 실행되는 프로세스는 마구 동시에 실행해선 안되고, **동기화**가 필수이다.
- **프로세스 동기화**란 프로세스들 사이의 수행 시기를 맞추는 것을 의미한다.
- 수행 시기를 맞추는 것은 크게 아래 두 가지를 일컫는다.
  1. 실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기
  2. 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기
- 즉, 동기화는 특정 자원에 접근할 때 한 개의 프로세스만 접근하게 하거나, 올바른 순서대로 실행하게 하는 것을 의미한다.
- 동기화에는 실행 순서 제어를 위한 동기화와, 상호 배제를 위한 동기화가 있다.
- **실행 순서 제어를 위한 동기화**
  - 만약 reader 프로세스와 writer 프로세스가 동시에 실행된다면, 반드시 writer 프로세스가 먼저 실행되어 데이터가 쓰여져야 reader 프로세스를 실행할 수 있다.
  - 이런 경우를 위해 동시에 실행되는 프로세스를 올바른 순서대로 실행할 수 있어야 한다.
- **상호 배제를 위한 동기화**
  - 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘이다.
  - 동기화가 제대로 이루어지지 않으면, 예를 들어 변수의 값에 영향을 주는 프로세스들이 여러 개 실행될 때 제대로 저장이 이루어지지 않을 수 있다.
  - 반드시 동시 사용이 불가능한 데이터를 사용할 때에는 해당 데이터를 사용하는 프로세스가 사용이 종료되어야 다음 프로세스가 접근하도록 해야 한다.

### 생산자와 소비자 문제

- 상호 배제를 위한 동기화 중 고전적이고 유명한 문제로 **생산자와 소비자 문제**가 있다.
- 이 문제는 물건을 계속해서 생산하는 프로세스인 생산자와, 물건을 계속해서 소비하는 프로세스인 소비자로 이루어져 있다.
- 총합이라는 변수에 10을 초기화하고, 이 프로세스들을 동시에 각각 100,000번 동시에 실행하면 10 그대로 있어야 할 것 같지만 실행 결과 매우 이상한 값이 나타난다.
- 이것은 프로세스가 제대로 동기화되지 않았기 때문에 발생한 문제이다.
- 생산자가 소비자의 작업이 끝나기도 전에 총합을 수정하고, 반대로 소비자도 생산자의 작업이 끝나기도 전에 총합을 수정하니 발생하는 문제이다.

### 공유 자원과 임계 구역

- 위의 총합 문제나 생산자와 소비자 문제 모두 **전역 변수**라는 공동 자원을 두고 작업했다.
- 이러한 자원을 **공유 자원**(Shared Resource)이라고 한다.
- 공유 자원은 전역 변수가 될 수도 있고, 파일이 될 수도 있고, 입출력장치나 보조기억장치가 될 수도 있다.
- 또한 동시에 실행하면 문제가 발생하는  자원에 접근하는 코드 영역을 **임계 구역**이라고 한다.
- A 프로세스가 한 자원을 차지할 때 임계 구역에 들어간다고 표현하고, 그 자원을 전부 사용했다면 임계 구역에서 나온다고 표현한다.
- 임계 구역은 동시에 두 개 이상의 프로세스가 접근하면 안 되는 영역이지만, 잘못된 실행으로 인해 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우를 **레이스 컨디션**이라고 한다.
- 레이스 컨디션이 발생하면 생산자와 소비자 문제처럼 데이터의 일관성이 깨지는 경우가 발생한다.
- 고급 언어로 한 줄만에 표현되는 명령이어도, 저급 언어로 변환되며 여러 줄로 표현될 수 있기 때문에 그 여러 줄을 실행하던 도중 문맥 교환이 일어나게 되면 문제가 발생하는 것이다.
- 운영 체제는 임계 구역 문제를 해결하기 위해, 즉 상호 배제를 위한 동기화를 위해 세 가지 원칙을 반드시 지킨다.
  1. 상호 배제 : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.
  2. 진행 : 임계 구역에 어느 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 진입할 수 있어야 한다.
  3. 유한 대기 : 한 프로세스가 임계 구역에 진입하고 싶다면, 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다. 즉, 임계 구역에 들어가려고 무한정 대기해서는 안 된다.

## 동기화 기법

- 어떻게 해야 임계 구역에 오직 하나의 프로세스만 진입하게 하고, 올바른 실행 순서를 보장할 수 있을까?
- 이를 위한 것이 대표적인 동기화 도구인 뮤텍스 락, 세마포, 모니터이다.

### 뮤텍스 락

- 뮤텍스 락을 이해할 땐 1인용 탈의실을 생각하면 편하다.
- 탈의실 내부가 비어있는지(임계 구역을 프로세스가 사용중인지) 알려면, 자물쇠가 걸려있는지 확인하면 된다. 자물쇠가 걸려 있지 않다면 탈의실을 이용하면 된다.
- 이 자물쇠 기능을 코드로 구현한 것이 **뮤텍스 락**(Mutex Lock)이라는 상호 배제를 위한 동기화 도구이다.
- 매우 단순한 형태의 뮤텍스 락은 전역 변수 하나와 두 개의 함수로 구현할 수 있다.
  - 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 look
  - 임계 구역을 잠그는 역할 : acquire 함수
  - 임계 구역 잠금을 해제하는 역할 : release 함수
- **acquire 함수**는 프로세스가 임계 구역에 진입하기 전에 호출하는 함수이다.
  - 만일 임계 구역이 잠겨있다면 열릴 때까지 (lock이 false가 될 때까지) 임계 구역을 반복적으로 확인하고, 열려있다면 잠그는 (lock을 true로 만드는) 함수이다.
  - 반복적으로 열려있는지 확인하기 때문에 쉴 새 없이 잠금을 확인하는데, 이런 대기 방식을 **바쁜 대기**(busy wait)라고 합니다.
- **release 함수**는 임계 구역에서의 작업이 끝나고 호출하는 함수이다.
  - 현재 잠긴 임계 구역을 열어주는 (lock을 false로 바꾸는) 함수이다.

### 세마포

- **세마포**(Semaphore)는 뮤텍스 락과 비슷하나 좀 더 일반화된 방식의 동기화 도구이다.
- 공유 자원이 여러 개 있을 경우, 여러 개의 프로세스가 각각 공유 자원에 접근할 수 있도록 일반화한 동기화 도구이다.
- 세마포엔 **이진 세마포**와 **카운팅 세마포**가 있고, 이진 세마포는 뮤텍스 락과 비슷한 개념이며 카운팅 세마포가 여러 공유 자원을 다룰 수 있는 세마포이다.
- 세마포는 철도 신호기에서 유래한 단어로, 멈춤 신호에서 가도 좋다라는 신호로 바뀌었을 때 철도가 출발하는 것과 유사하다.
- 매우 단순한 형태의 세마포는 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 구현할 수 있다.
  - 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 전역변수 S
  - 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait 함수
  - 임계 구역 앞에서 기다리는 프로세스에 '가도 좋다' 신호를 주는 signal 함수
- 임계 구역 진입 전후로 wait()와 signal()을 호출한다.
- **wait 함수**는 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 반복적으로 확인하다가, 하나 이상이라면 S를 1 감소시킨 뒤 임계 구역에 진입시킨다.
- **signal 함수**는 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다.
- 그러나 세마포 역시 뮤텍스 락과 마찬가지로 바쁜 대기를 하기 때문에 CPU 주기를 낭비한다.
- 그 문제를 해결하기 위해 세마포는 더욱 좋은 방법을 사용한다.
  - wait 함수는 만일 사용할 수 있는 자원이 없다면, 해당 프로세스를 대기 상태로 만든다.
  - 그 프로세스의 PCB를 세마포를 위한 대기 큐에 삽입한다.
  - 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면, signal함수는 대기중인 프로세스를 큐에서 제거하고 준비 상태로 변경시킨 뒤 준비 큐로 옮긴다.
- 세마포를 활용하면 실행 순서 제어를 위한 동기화도 간단하다.
  - 먼저 실행시켜야 할 프로세스 뒤에 signal 함수를 두고, 이후에 실행할 프로세스 앞에 wait 함수를 붙이면 된다.
  - 이렇게 되면 어떤 프로세스가 먼저 실행되던 반드시 순서가 지켜지게 된다.

### 모니터

- 세마포는 일일이 wait와 signal을 명시해야 하기에 매우 번거롭다.
- 세마포를 누락하거나, wait와 signal의 순서를 헷갈리거나, 중복해서 사용하는 에러가 존재할 수 있다.
- 이에 최근에 등장한 동기화 도구가 **모니터**이며, 세마포에 비해 사용자가 사용하기 훨씬 편리하다.
  - 모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리한다.
  - 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근할 수 있다.
  - 공유 자원에 접근하고자 하는 프로세스는 큐에 삽입되고, 삽입된 순서대로 공유 자원을 이용한다.
  - 즉 인터페이스 자리에 하나의 프로세스만 들어오므로 상호 배제를 위한 동기화를 제공한다.
  - 또한 특정 조건을 바탕으로 프로세스를 실행하고 일시 중단할 때 **조건 변수**를 사용하는데, 이 변수는 프로세스나 스레드의 실행 순서를 제어하는 용도로 실행 순서 제어를 위한 동기화도 제공된다.
- 조건 변수로는 wait와 signal 연산을 수행할 수 있다.
  - wait는 호출한 프로세스의 상태를 대기 상태로 전환, 일시적으로 조건 변수에 대한 대기 큐에 삽입한다.
  - 이 대기 큐는 모니터에 진입하기 위해 삽입되는 상호 배재를 위한 큐가 아니다. 이 큐는 이미 진입한 프로세스의 실행 조건이 만족될 때까지 잠시 중단하기 위한 큐이다.
  - wait으로 일시 중지된 프로세스는 다른 프로세스의 signal연산에 의해 실행이 재개될 수 있다.
  - signal은 wait를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산이다.
  - 모니터 안에는 하나의 프로세스만이 있을 수 있기 때문에 wait를 호출했던 프로세스는 signal을 호출한 프로세스가 모니터를 떠난 뒤에 실행되거나, signal을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤 다시 signal을 호출한 프로세스의 수행을 재개한다.
- 중요한 것은 아래와 같은 프로세스 실행 순서 제어를 위한 동기화를 제공하는 것이다.
  1. 특정 프로세스가 아직 실행될 조건이 되지 않았다면 wait를 통해 실행을 중단한다.
  2. 특정 프로세스가 실행 조건이 충족되었다면 signal을 통해 실행을 재개한다.