# Chapter 03 : 명령어

## 소스 코드와 명령어

- 컴퓨터는 명령어를 처리하는 기계인데, 프로그래밍 언어로 만든 소스 코드도 작동한다.
- 즉, 모든 소스 코드는 **컴퓨터 내부에서 명령어로 변환**된다.

### 고급 언어와 저급 언어

- C, C++ 등의 언어는 언뜻보면 컴퓨터가 이해할 수 있을 것 같지만, 아니다.
- **고급 언어** : 우리가 프로그램을 만들 때 사용하는 언어이며, 사람을 위한 언어.
    - C, C++, Java, Python 등
- **저급 언어** : 컴퓨터가 직접 이해하고 실행할 수 있는 언어.
    - **기계어**와 **어셈블리어**
- 즉, 사람이 C, C++과 같은 고급 언어로 작성된 소스 코드를 실행하려면 반드시 저급 언어, 즉 명령어로 변환되어야 한다.
- 기계어란 0과 1의 명령어 비트로 이루어진 언어. 이진수 혹은 십육진수로 표현된다. 즉, 사람이 굉장히 읽기 힘들고 난해하다.
- 어셈블리어란, 기계어를 그나마 읽기 편한 형태로 번역한 언어.
- 그럼 개발자는 저급 언어를 알 필요가 전혀 없지 않나? 라고 생각할 수 있지만, 이는 반만 맞는 말이다. 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 개발자 분야는, 어셈블리어를 많이 이용한다.
- 어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하고 어떤 절차로 작동하는지 가장 근본적인 단계부터 추적하고 관찰할 수 있기 때문에, ‘작성의 대상’일 뿐만 아니라 ‘관찰의 대상’이기도 하다.

### 컴파일 언어와 인터프리터 언어

- 고급 언어가 저급 언어로 변환되어 실행되는 방식에는 **컴파일 방식**과 **인터프리트 방식**이 존재.
- 컴파일 방식으로 작동하는 프로그래밍 언어는 **컴파일 언어**, 인터프리트 방식으로 작동하는 프로그래밍 언어는 **인터프리터 언어**라고 한다.

- **컴파일 언어**
    - 컴파일러에 의해 소스 코드 **전체가 한 번에 저급 언어로 변환**되어 실행되는 고급 언어.
    - 대표적인 컴파일 언어로는 **C**가 있다.
    - 소스 코드 전체를 저급 언어로 변환하는 과정을 **컴파일**이라고 하며, 그 컴파일을 수행해 주는 도구를 **컴파일러**라고 한다.
    - 처음부터 소스 코드를 쭉 훑어보며 문법적인 오류가 있는지, 실행 가능한 코드인지 등을 따지며 변환한다. 이 때 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패한다.
    - 컴파일이 성공적으로 수행되면 개발자가 작성한 소스 코드는 컴퓨터가 이해할 수 있는 저급 언어로 변환되는데, 이 코드를 **목적 코드**라고 한다.
- **인터프리터 언어**
    - 인터프리터에 의해 **소스 코드가 한 줄씩 실행**되는 고급 언어.
    - 대표적인 인터프리터 언어로는 **Python**이 있다.
    - 컴파일 언어와는 달리 인터프리터 언어는 소스 코드를 한 줄씩 차례로 실행한다.
    - 한 줄씩 저급 언어로 변환하여 실행해 주는 도구를 **인터프리터**라고 한다.
    - 인터프리터 언어는 컴퓨터와 대화하듯 소스 코드를 한 줄씩 실행하기 때문에 전체를 변환할 시간을 기다릴 필요가 없다.
    - 또한 오류가 하나라도 있으면 컴파일이 불가능했던 컴파일 언어와는 달리, N번 줄에 오류가 있더라도 N-1번째 줄까지는 올바르게 수행된다.
    - 인터프리터 언어가 컴파일 언어보다 빠르다고 생각할 수 있지만, **일반적으로 인터프리터 언어는 컴파일 언어보다 느리다.**

- 컴파일 언어와 인터프리터 언어는 칼로 자르듯 딱 구분되지 않는다. 파이썬도 컴파일을 하지 않는 것은 아니고, Java의 경우 저급 언어가 되는 과정에서 컴파일과 인터프리트를 동시에 수행하기도 한다.

### 목적 파일과 실행 파일

- 목적 코드로 이루어진 파일을 **목적 파일**이라고 한다.
- 마찬가지로 실행 코드로 이루어진 파일을 **실행 파일**이라고 한다.
    - 윈도우의 .exe 확장자를 가진 파일이 대표적인 실행 파일이다.
- 목적 코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업을 거쳐야 한다.
- 두 개 이상의 소스 코드들을 컴파일하면 각각 목적 코드가 되는데, 두 개 이상의 소스 코드였던 만큼 두 파일이 서로 연관되어 있을 수 있다.
- 이 여러 개의 목적 파일을 하나로 이어주어야 비로소 실행 가능한 실행 파일이 되며, 하나로 이어주는 작업이 링킹인 것이다.

## 명령어의 구조

- 기계어나 어셈블리어를 이루는 하나하나가 명령어이다. 즉, 저급 언어는 명령어들로 이루어졌다.
- 이 하나하나를 이루고 있는 명령어엔 **연산 코드, 오퍼랜드, 주소 지정 방식** 등의 개념이 있다.

### 연산 코드와 오퍼랜드

- 컴퓨터 속 명령어도 현실의 명령처럼 ‘무엇을 대상으로, 어떤 작동을 수행하라’는 구조이다.
- **명령어**는 **연산 코드**와 **오퍼랜드**로 구성되어 있다.
    - **연산 코드(Operation code)** : 명령어가 수행할 **연산**. (더해라, 빼라, 저장해라 등)
    - **오퍼랜드(Operand)** : 연산에 사용할 데이터가 저장된 **위치**. (100번지, 101번지 등)
    - 연산 코드는 연산자, 오퍼랜드는 피연산자라고도 한다.
    - 하나의 명령어에서 연산 코드가 담기는 영역을 연산 코드 필드, 오퍼랜드가 담기는 영역을 오퍼랜드 필드라고 한다.
    - 어셈블리어에서의 연산 코드엔 push, pop, mov, add, ret 등이 존재한다.
- **오퍼랜드**
    - 오퍼랜드는 **연산에 사용할 데이터** 혹은 **연산에 사용할 데이터가 저장된 위치**를 의미한다.
    - 따라서 숫자와 문자 등을 나타내는 **데이터** 또는 **메모리나 레지스터 주소**가 있을 수 있다.
    - 대부분 직접 데이터를 명시하기보단 데이터가 저장된 위치가 담겨있어서 **주소 필드**라고도 부른다.
    - 오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한 개 혹은 두 개 혹은 세 개 등 여러 개가 있을 수도 있다.
        - 0-주소 명령어 : 오퍼랜드가 하나도 없는 주소 지정 방식
        - 1-주소 명령어 : 오퍼랜드가 한 개인 주소 지정 방식
        - 2-주소 명렁어 : 오퍼랜드가 두 개인 주소 지정 방식
        - 3-주소 명령어 : 오퍼랜드가 세 개인 주소 지정 방식
- **연산 코드**
    - 연산 코드는 **명령어가 수행할 연산**을 의미한다.
    - 연산 코드의 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 크게 네 가지로 나뉜다.
        1. 데이터 전송
        2. 산술/논리 연산
        3. 제어 흐름 변경
        4. 입출력 제어
    - 데이터 전송 명령어의 경우 **MOVE, STORE, LOAD, PUSH, POP** 등이 존재한다.
        - 데이터를 옮기거나, 저장하거나, 불러오거나, 스택에 저장하거나, 스택에서 가져오기
    - 산술/논리 연산 명령어의 경우 **ADD, SUB, INCREMENT, AND, OR, COMPARE** 등이 존재한다.
        - 덧셈 뺄셈 등 사칙연산, 오퍼랜드에 1을 더하라, 논리 연산, 두 개의 값 비교
    - 제어 흐름 변경 명령어의 경우 **JUMP, HALT, CALL, RETURN** 등이 존재한다.
        - 특정 주소로 실행 순서 옮기기, 실행 멈추기, 되돌아올 주소 저장하고 점프, 저장한 주소로 돌아가기
    - 입출력 제어 명령어의 경우 **READ, WRITE, START IO, TEST IO** 등이 존재한다.
        - 특정 입출력 장치로부터 데이터 읽기, 쓰기, 입출력 장치 시작, 상태 확인

### 주소 지정 방식